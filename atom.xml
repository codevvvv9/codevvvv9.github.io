<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuShaoLin&#39;s Blog</title>
  
  <subtitle>悟已往之不谏，知来者之可追</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codevvvv9.github.io/"/>
  <updated>2018-12-29T14:17:07.884Z</updated>
  <id>https://codevvvv9.github.io/</id>
  
  <author>
    <name>shaolin-wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Deepin配置Java环境</title>
    <link href="https://codevvvv9.github.io/2018/12/29/Deepin%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83/"/>
    <id>https://codevvvv9.github.io/2018/12/29/Deepin配置Java环境/</id>
    <published>2018-12-29T13:56:32.000Z</published>
    <updated>2018-12-29T14:17:07.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载JavaSe开发包"><a href="#下载JavaSe开发包" class="headerlink" title="下载JavaSe开发包"></a>下载<code>JavaSe</code>开发包</h2><ul><li><code>Oracle官网下载</code>，<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">地址</a></li></ul><p><img src="https://i.loli.net/2018/12/29/5c277f76ae39e.png" alt=""></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul><li>下载完之后，解压，记住目录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在你的.bashrc 或者 .zshrc，以及 /etc/profile添加如下代码</span></span><br><span class="line">export JAVA_HOME=/home/wsl/Documents/jdk1.8.0_191</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"><span class="comment">// etc要想生效还要source</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><code>deepin</code>有内置的<code>openJDK</code>，会影响<code>Oracle</code>的<code>JDK</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看版本多了一个_JAVA_OPTIONS</span></span><br><span class="line">java -version</span><br><span class="line"> </span><br><span class="line">Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp</span><br><span class="line">java version <span class="string">"1.8.0_05"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_05-b13)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.5</span>-b02, mixed mode)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/12/29/5c27810304718.png" alt=""></p><ul><li>多余文件的文本内容</li></ul><p><img src="https://i.loli.net/2018/12/29/5c2781b63bd6c.png" alt=""></p><ul><li>终极解决方案</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上面配置的环境变量前面添加</span></span><br><span class="line">unset _JAVA_OPTIONS</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载JavaSe开发包&quot;&gt;&lt;a href=&quot;#下载JavaSe开发包&quot; class=&quot;headerlink&quot; title=&quot;下载JavaSe开发包&quot;&gt;&lt;/a&gt;下载&lt;code&gt;JavaSe&lt;/code&gt;开发包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Oracle官网下
      
    
    </summary>
    
      <category term="LearnJava" scheme="https://codevvvv9.github.io/categories/LearnJava/"/>
    
    
      <category term="Java" scheme="https://codevvvv9.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>记录用户状态</title>
    <link href="https://codevvvv9.github.io/2018/10/21/%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81/"/>
    <id>https://codevvvv9.github.io/2018/10/21/记录用户状态/</id>
    <published>2018-10-21T14:56:12.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要记录本周开发中遇到的一个问题——记录用户状态。</p><h3 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h3><p>我们做的产品是某款安检产品的数据集中管理，主要是为了处理AI所需的样本，我们通过web进行标注任务、数据传输任务、设备型号、设备类型、存储源、传输协议等等的管理与分配，以上各种东东的管理（各种简单的复杂的增删改查）是我负责。<a id="more"></a></p><p>那是一个风和日不丽的周一，<code>leader</code>说客户（其实就是某个人脸识别的兄弟部门）需要一项训练集的管理web，毫无疑问的，这个任务是我的。AI嘛，说白了就是不断训练数据，获得模型，再训练，再通过新的数据进行测试，根据结果再通过新数据训练，再得到算法模型，再测试，周而复始的调参。所以训练集必须要好好管理啊。</p><p>那么，当我创建一个新的训练集的时候，训练集本身包含5个自有属性，还要通过一个数据包的查询接口来获得的数据包，以上的5个自有属性+这个数据包（不知道有多少，反正是通过另外三个查询条件获得数据包内容）组成一条数据集。</p><p>这条训练集数据可以被编辑、被删除、被导出。</p><p>编辑的业务场景是：点击编辑时首先通过获得当前项训练集的<code>id</code>的接口来回显数据库中存储的数据，而训练集只有那五个自有属性可以被修改，数据包的内容以及创建时的三个查询条件（也就是创建时的查询状态）不可修改。</p><p>基于上面的业务场景，我添加一条新的训练集的时候，该训练集的五个自有属性+数据包+<strong>查询状态</strong>都应该存储到数据库中。</p><p>而一开始与我对接的java后台的数据库中表没有对应字段去存储查询状态，我与之进行第一轮交涉，经过思考，他觉得这样太复杂，因为这个查询条件没有单独的<code>id</code>去存储，需要再建新的数据库表，希望前台来处理这个状态，因为通过数据包的查询接口获得了表征查询获得的所有数据包的一串标识码和数据包总数，他认为我可以通过一个对象记住，然后编辑时再把它关联回去。既然后台要建表，还要建新的实体类，比较复杂，那我前台看看处理下。</p><p>可是，我一思考，这个查询条件要与该条训练集绑定才能保证编辑该条训练集的时候回显正常 的数据，也就是说要把查询状态与该训练集的<code>id</code>关联起来， 那么问题来了，添加的时候，并没有<code>id</code>，此<code>id</code>是往数据库存储时后台自动生成的，前台也没法拿到这个<code>id</code>，那么我也没法通过一个对象把查询状态+<code>创建该训练集的id</code>存储起来，好像前台也没法处理。</p><p>可是这个任务必须要做啊，我和后台的小伙伴两个萌新大眼瞪小眼。</p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>没办法了，去跟<code>leader</code>商量了，结果人家云淡风轻的说：</p><ol><li>后台在表里面建个<code>searchCondition</code>字段，给它个长点的字符串格式。</li><li>前台创建时把查询条件包装成一个大字符串，数据库就存这个大字符串就行了。</li><li>编辑时前台拿到那个长字符串，再解析，分别把数据回填到查询状态的<code>form</code>里面就行了。</li></ol><p>听完之后我俩回来后，讨论了一下就开始干了，有了明确的方向干活就是快啊。</p><h4 id="改造添加时的方法"><a href="#改造添加时的方法" class="headerlink" title="改造添加时的方法"></a>改造添加时的方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (action === <span class="string">"add"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> searchCondition = &#123;</span><br><span class="line">        businessType: <span class="keyword">this</span>.form.businessType,</span><br><span class="line">        <span class="comment">//时间戳处理，原始处理是new Date().getTime(),应使用其他方法去处理时间戳的问题</span></span><br><span class="line">        uploadTime: <span class="keyword">this</span>.form.uploadTime,</span><br><span class="line">        plotTask: <span class="keyword">this</span>.form.plotTask</span><br><span class="line">    &#125;</span><br><span class="line">    axios.post(<span class="string">`<span class="subst">$&#123;base_url&#125;</span>/trainSet/...`</span>, &#123;</span><br><span class="line">      <span class="comment">//其他代码</span></span><br><span class="line">      searchCondition: <span class="built_in">JSON</span>.strinify(searchCondition)</span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//代码...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑时的方法"><a href="#编辑时的方法" class="headerlink" title="编辑时的方法"></a>编辑时的方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">showFormData(id) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = &#123;</span><br><span class="line">        id = <span class="keyword">this</span>.form.id,</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    axios.get(<span class="string">`<span class="subst">$&#123;base_url&#125;</span>/trainSet/getTrainSetById?id=<span class="subst">$&#123;val.id&#125;</span>`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> data = res.data.data</span><br><span class="line">          <span class="keyword">let</span> searchConditionJSON = <span class="built_in">JSON</span>.parse(data.searchCondition)</span><br><span class="line">          <span class="keyword">this</span>.form.businessType = searchConditionJSON.businessType</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//或者直接用解构，通过查询条件再调一遍查询的接口即可获得所有的数据包以及总数目</span></span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>具体问题还是没法深入到代码层面去分析，对于数据库的知识比较匮乏，不知道如何去抽象业务场景。</p><p>原来<code>JSON</code>的基本玩法这么玩。</p><p>多思考，多请教，多记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要记录本周开发中遇到的一个问题——记录用户状态。&lt;/p&gt;
&lt;h3 id=&quot;问题的来源&quot;&gt;&lt;a href=&quot;#问题的来源&quot; class=&quot;headerlink&quot; title=&quot;问题的来源&quot;&gt;&lt;/a&gt;问题的来源&lt;/h3&gt;&lt;p&gt;我们做的产品是某款安检产品的数据集中管理，主要是为了处理AI所需的样本，我们通过web进行标注任务、数据传输任务、设备型号、设备类型、存储源、传输协议等等的管理与分配，以上各种东东的管理（各种简单的复杂的增删改查）是我负责。
    
    </summary>
    
      <category term="三省吾身" scheme="https://codevvvv9.github.io/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
      <category term="think" scheme="https://codevvvv9.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM</title>
    <link href="https://codevvvv9.github.io/2018/09/19/%E8%99%9A%E6%8B%9FDOM/"/>
    <id>https://codevvvv9.github.io/2018/09/19/虚拟DOM/</id>
    <published>2018-09-19T15:46:07.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习底层的虚拟DOM原理</p></blockquote><p>二话不说，直接上代码</p><h3 id="基本的代码如下："><a href="#基本的代码如下：" class="headerlink" title="基本的代码如下："></a>基本的代码如下：<a id="more"></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeData = &#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  children: [&#123;</span><br><span class="line">      tag: <span class="string">'p'</span>,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        tag: <span class="string">'span'</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">          tag: <span class="string">'#text'</span>,</span><br><span class="line">          text: <span class="string">'wushao.xyz'</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'span'</span>,</span><br><span class="line">      children: [&#123;</span><br><span class="line">        tag: <span class="string">'#text'</span>,</span><br><span class="line">        text: <span class="string">'wushao.com'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">等同于这段html代码</span></span><br><span class="line"><span class="comment">&lt;div&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;</span></span><br><span class="line"><span class="comment">    &lt;span&gt;wushao.xyz&lt;/span&gt;</span></span><br><span class="line"><span class="comment">  &lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;span&gt;wushao.com&lt;/span&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ES6的写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tag, children, text) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tag === <span class="string">'#text'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tag)</span><br><span class="line">    <span class="keyword">this</span>.children.forEach(<span class="function"><span class="params">vChild</span> =&gt;</span> &#123;</span><br><span class="line">      el.appendChild(vChild.render())</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建虚拟dom节点的简便函数</span></span><br><span class="line"><span class="comment"> * @param &#123;标签名&#125; tag </span></span><br><span class="line"><span class="comment"> * @param &#123;子标签&#125; children </span></span><br><span class="line"><span class="comment"> * @param &#123;文本值&#125; text </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v</span>(<span class="params">tag, children, text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果没有tag,第二个参数是字符串的话</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">'string'</span>) &#123;</span><br><span class="line">    text = children</span><br><span class="line">    children = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(tag, children, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ES5的写法</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; tag </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; children </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; text </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vNode</span>(<span class="params">tag, children, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tag = tag</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">  <span class="keyword">this</span>.text = text</span><br><span class="line">&#125;</span><br><span class="line">vNode.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.tag === <span class="string">'#text'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tag)</span><br><span class="line">  <span class="keyword">this</span>.children.forEach(<span class="function"><span class="params">vChild</span> =&gt;</span> &#123;</span><br><span class="line">    el.appendChild(vChild.render())</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例说明</span></span><br><span class="line"><span class="keyword">let</span> vNode1 = v(<span class="string">'div'</span>, [</span><br><span class="line">  v(<span class="string">'p'</span>, [</span><br><span class="line">    v(<span class="string">'span'</span>, [v(<span class="string">'#text'</span>, <span class="string">'wushao.xyz'</span>)])</span><br><span class="line">  ]),</span><br><span class="line">  v(<span class="string">'span'</span>, [</span><br><span class="line">    v(<span class="string">'#text'</span>, <span class="string">'wushao.com'</span>)</span><br><span class="line">  ])</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log(vNode1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span><br><span class="line">root.appendChild(vNode1.render()) <span class="comment">//把虚拟的dom映射进了真实的dom结构里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vNode2 = v(<span class="string">'div'</span>, [</span><br><span class="line">  v(<span class="string">'p'</span>, [</span><br><span class="line">    v(<span class="string">'span'</span>, [v(<span class="string">'#text'</span>, <span class="string">'wushao.xyz'</span>)])</span><br><span class="line">  ]),</span><br><span class="line">  v(<span class="string">'span'</span>, [</span><br><span class="line">    v(<span class="string">'#text'</span>, <span class="string">'wushao.com'</span>)</span><br><span class="line">  ]),</span><br><span class="line">  v(<span class="string">'span'</span>, [</span><br><span class="line">    v(<span class="string">'#text'</span>, <span class="string">'wushao'</span>)</span><br><span class="line">  ])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#change'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  root.innerHTML = <span class="string">''</span></span><br><span class="line">  root.appendChild(vNode2.render())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较前后两个节点</span></span><br><span class="line"><span class="comment"> * @param &#123;要比较的DOM结构&#125; parent </span></span><br><span class="line"><span class="comment"> * @param &#123;旧的节点&#125; newVNode </span></span><br><span class="line"><span class="comment"> * @param &#123;*新的节点 oldNode </span></span><br><span class="line"><span class="comment"> * @param &#123;索引&#125; index </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchElement</span>(<span class="params">parent, newVNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    <span class="comment">//新增元素</span></span><br><span class="line">    parent.appendChild(newVNode.render())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!newVNode) &#123;</span><br><span class="line">    parent.removeChild(parent.childNodes[index])</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newVNode.tag !== oldNode.tag || newVNode.text != oldNode.text)&#123;</span><br><span class="line">    parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newVNode.children.length || i &lt; oldNode.children.length; i++) &#123;</span><br><span class="line">      patchElement(parent.childNodes[index], newVNode.children[i], oldNode.children[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以在HTML中直接测试"><a href="#可以在HTML中直接测试" class="headerlink" title="可以在HTML中直接测试"></a>可以在<code>HTML</code>中直接测试</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>虚拟DOM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"change"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./v-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习底层的虚拟DOM原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二话不说，直接上代码&lt;/p&gt;
&lt;h3 id=&quot;基本的代码如下：&quot;&gt;&lt;a href=&quot;#基本的代码如下：&quot; class=&quot;headerlink&quot; title=&quot;基本的代码如下：&quot;&gt;&lt;/a&gt;基本的代码如下：
    
    </summary>
    
      <category term="Vue的学习" scheme="https://codevvvv9.github.io/categories/Vue%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Vue" scheme="https://codevvvv9.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SEO不完全指北</title>
    <link href="https://codevvvv9.github.io/2018/09/02/SEO%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/"/>
    <id>https://codevvvv9.github.io/2018/09/02/SEO不完全指北/</id>
    <published>2018-09-02T13:49:34.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个周末学习了一下关于把个人站点进行SEO的初级操作，觉得很有意思，以此文记录一下，如果你也使用<code>HEXO</code>那将会有帮助。</p><blockquote><p><code>SEO</code>指 <code>Search Engine Optimization</code>，意指搜索引擎优化的意思，通过必要的网站结构的设计让<code>spider</code>机器人爬取有用的数据，提高网站在搜索时的排名与在相关领域的权重。</p></blockquote><h3 id="百度站长"><a href="#百度站长" class="headerlink" title="百度站长"></a>百度站长</h3><p>国内的话，首推<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长</a>，前提是你要有自已 的域名了。<a id="more"></a></p><h4 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h4><p>按照下图操作</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/21158660.jpg" alt="百度添加网站"></p><p>前面两部基本没问题，注意一下第三步的操作：</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/71723786.jpg" alt="第三步验证操作"></p><ul><li>通常选择文件验证和CNAME验证，我选择的是文件验证，这里要把百度的验证文件放到你的域名的根目录下，具体的在这里指：<code>source</code>目录下，要注意如果是html文件要使用如下代码处理，防止后续部署时把html文件给处理了。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line">FZKjy3o3f6 //你的验证文件的内容，显然百度分配给每个人都不一样</span><br></pre></td></tr></table></figure><h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><ol><li>首先安装两个插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><ol start="2"><li>修改项目根目录下的<code>_config.yml</code> 的URL</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: http:<span class="comment">//wushao.xyz //你的个人站点的名字</span></span><br><span class="line">root: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">permalink: :year/</span>:month/:day/:title/ <span class="comment">//这里将会在后续的URL持久化章中优化</span></span><br></pre></td></tr></table></figure><ol start="3"><li>进行如下代码的部署，在根目录下的<code>public</code>目录生成<code>sitemap.xml</code> 和 <code>baidusitemap.xml</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d <span class="comment">//相当于hexo generate 然后 hexo deploy</span></span><br></pre></td></tr></table></figure><ol start="4"><li>把上面生成的<code>sitemap.xml</code>提交给百度，按照第一章的做法把站点添加到百度后，按照下图的方式提交</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/81973081.jpg" alt="链接提交"></p><p> 这里有两种方式提交，很明显选择自动提交——主动推送的方式，注意这里的<code>token</code>，很重要</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/21550135.jpg" alt="主动提交方式"></p><p>使用如下代码完成主动推送</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//1.先安装插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-baidu-url-submit</span> <span class="bullet">--save</span></span><br><span class="line"><span class="string">//2.在根目录下的_config.yml</span> <span class="string">添加baidu_url_submit属性</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接,最新的100个链接，想写几个写几个</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">wushao.xyz</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line"><span class="attr">  token:</span>  <span class="comment"># 请注意这是您的秘钥，就是上图模糊处理的那个所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在public目录下</span></span><br><span class="line"><span class="string">//3.修改根目录下的_config.yml</span> <span class="string">的deploy属性,注意有两个deploy时的格式！！！</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span></span><br><span class="line"><span class="attr">        github:</span> <span class="string">你的github</span></span><br><span class="line"><span class="attr">        coding:</span> <span class="string">你的coding</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><p>下面介绍几个优化爬取的方法</p><hr><h4 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加<code>robots.txt</code></h4><p>这里是为了告诉搜索引擎哪些可以爬取哪些不可以爬取，在<code>source</code>目录下添加<code>robots.txt</code>，文本内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/tags/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/posts/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/vendors/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/js/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/css/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/fonts/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/vendors/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/fancybox/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Sitemap:</span> <span class="attr">https://你的站点/sitemap.xml</span> <span class="string">//</span></span><br><span class="line"><span class="attr">Sitemap:</span> <span class="attr">https://你的站点/baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/8846523.jpg" alt="robots.txt内容"></p><h4 id="Url持久化"><a href="#Url持久化" class="headerlink" title="Url持久化"></a><code>Url</code>持久化</h4><p>还记的<code>_config.yml</code>里面关于<code>url</code>的描述嘛。<code>permalink</code>属性中的<code>/</code>决定了你的<code>url</code>有几级，通常引擎只会爬取三层，而且对于汉字的处理不完美，可是你的文章名字难免会有汉字，所以这里要进行必要的转化。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # URL</span></span><br><span class="line"><span class="comment"># ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">你的站点名字</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="string">//优化处</span></span><br></pre></td></tr></table></figure><ul><li>借助<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>插件，感谢大神的插件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-abbrlink</span> <span class="bullet">--save</span></span><br><span class="line"><span class="string">//</span> <span class="string">Modify</span> <span class="string">permalink</span> <span class="string">in</span> <span class="string">config.yml</span> <span class="attr">file:</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">  alg:</span> <span class="string">crc32</span>  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line"><span class="attr">  rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br><span class="line"><span class="string">//部署完之后所有的url如下所示</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//wushao.xyz/posts/6ed52419.html</span> <span class="string">//6ed52419这个就代表你原来的名字</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//wushao.xyz/posts/7a43570f.html</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//wushao.xyz/posts/7b3b172b.html</span></span><br><span class="line"><span class="attr">http:</span><span class="string">//wushao.xyz/posts/77ac3545.html</span></span><br></pre></td></tr></table></figure><ul><li>此时你会发现你以前的的文章标题会有变化</li></ul><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/83087096.jpg" alt=""></p><h3 id="Google站长"><a href="#Google站长" class="headerlink" title="Google站长"></a><code>Google</code>站长</h3><p><code>Google</code>的方便多了，直接<a href="https://www.google.com/webmasters/#?modal_active=none" target="_blank" rel="noopener">google站长</a>，然后进<code>Search console</code>,添加属性就是添加个人站点的意思，后续步骤和上面一样，但是收录的速度快多了。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-9-2/53903614.jpg" alt="Search console"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个周末学习了一下关于把个人站点进行SEO的初级操作，觉得很有意思，以此文记录一下，如果你也使用&lt;code&gt;HEXO&lt;/code&gt;那将会有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;SEO&lt;/code&gt;指 &lt;code&gt;Search Engine Optimization&lt;/code&gt;，意指搜索引擎优化的意思，通过必要的网站结构的设计让&lt;code&gt;spider&lt;/code&gt;机器人爬取有用的数据，提高网站在搜索时的排名与在相关领域的权重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;百度站长&quot;&gt;&lt;a href=&quot;#百度站长&quot; class=&quot;headerlink&quot; title=&quot;百度站长&quot;&gt;&lt;/a&gt;百度站长&lt;/h3&gt;&lt;p&gt;国内的话，首推&lt;a href=&quot;https://ziyuan.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度站长&lt;/a&gt;，前提是你要有自已 的域名了。
    
    </summary>
    
      <category term="前端之外" scheme="https://codevvvv9.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    
    
      <category term="SEO" scheme="https://codevvvv9.github.io/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>最强的团队</title>
    <link href="https://codevvvv9.github.io/2018/08/31/%E6%9C%80%E5%BC%BA%E7%9A%84%E5%9B%A2%E9%98%9F/"/>
    <id>https://codevvvv9.github.io/2018/08/31/最强的团队/</id>
    <published>2018-08-31T13:33:32.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="所在的团队"><a href="#所在的团队" class="headerlink" title="所在的团队"></a>所在的团队</h3><p>入职已经有一个半月了，目前的团队氛围对于我这个新人来说，就一句话<strong>如鱼得水</strong>，感谢机缘，能让我在转行的第一份工作中遇见这个团队，而我也会为了这个团队努力工作，让前端的大旗迎风飞扬。<a id="more"></a></p><p>团队组成由4个java后端、1个Python后端、3个前端、1个架构师。</p><ul><li>java四人组构成：3个主力web服务，使用sprintboot等先进技术， 1个使用各种大数据技术的java小头目。Python后端主要负责系统的基础架构，比较高深。</li><li>Python大牛是南京土著，开车贼梦，公认的飙车王，宽高比几乎相同，哈哈，当然了，很nice的队友，给我普及了很多南京的知识，同时多线支持南京的机器学习计算平台的开发，强！！！</li><li>接下来重点介绍前端阵容，前端项目毫无疑问使用Vue全家桶技术，由两位女生和我组成，两位女生和我年纪一样，但是我读研期间人家已经夯实好了前端技术，她俩人都超级好，总是结伴讨论问题，对我的vue提升帮助很大，尤其是小leader——玥之魔法师，她炒鸡耐心，总结：炒鸡nice的小组织。</li><li>架构师是从业10多年的大牛，虽然不懂前端，所以就由玥之魔法师组织，但是他的宏观把握力、带队能力、沟通写作、各个部门协调资源、做人做事的风格，让我叹为观止，原来程序员也可以这么风趣幽默，给团队成员极大的自由空间，后面我将重点讲讲大佬的故事。</li></ul><p>说实话，以我目前的能力来说，遇到这么一个团队，对于刚转行过来的人来说，有幸也有不幸。幸的是：有充足的时间去丰富自己的js技能，打磨我的vue技能，极大的空间去发掘潜力，不幸的是：没有紧迫的互联网急速迭代的产品，客户都是固定的。不过后来也想通了，当下选择的就是最棒的，坦然接受这个角色，做好自己，很怕自己又折在好高骛远的毛病上。18年的上半年，浪费了很多时间，导致自己在算法数据结构、计算机网络的学习上欠缺了相当多，这是后期要与js一起恶补的方向。</p><p>这段时间的总结和未来正如我的slogan一样，道阻且长，以梦为马，不忘初心。👊</p><h3 id="学会解放生产力"><a href="#学会解放生产力" class="headerlink" title="学会解放生产力"></a>学会解放生产力</h3><p>还记得我前面说的大佬吗，他在工作两年时就已经带领一个8人团队做出一番大事了，他也鼓励我们在工作到2-3年时要刻意的去培养管理的技能与意识，而不仅仅是敲代码。</p><h4 id="善假于物也"><a href="#善假于物也" class="headerlink" title="善假于物也"></a>善假于物也</h4><ol><li>使用<strong>jira</strong>。大佬鼓励我们使用jira进行项目的各个任务的分解，同时进行任务流的分解，不同的任务流分配不同的时间比如3w，2h，1d，让整个团队看到各自的时间分配与做的东西，这不就是各大畅销书提倡的时间管理技巧嘛，例如西红柿时间管理法、四象限时间管理法，从来没有想到在程序员生涯中会用到这些，我以为就是坐那敲代码，调bug而已。可能其他大厂也都用的各种管理技巧，可能比我们的很高级，但是我的体会是：入行以后就要专业，你要体现出你是专业的，不是学校、或者二流程序员做事的风格，你要有一个专业的做事风格，告诉别人，我是一流的技术人员，所以团队的第一天就这么要求，真的对我的职业生涯有很大的帮助与启发。</li><li>及时提出帮助。大佬每日早晨给我们开会，他使用邮件做了一个定时发送，他起的名字是 “每日站会”，每天早晨傍晚都会收到它。这个定时事件流或者会议的功能，早就有了，但是从来没用过的团队大有人在，工具就摆在那里，不会用或者不擅于利用，这真是极大的浪费啊。我们站会的精髓是：“昨天做了什么，今天做什么，需要什么帮助”，我最大的体会是第三点——需要什么帮助。人，都有一个毛病，觉得自己很牛，多花点时间总会搞出来，后来人类总结了一个成语叫自以为是，尤其在技术人员中，这一点尤甚，工作几年后，技术有了进步，就一头扎进代码，出不来了，明明可以请教一下就解决了，非要自己研究，导致莫名的加班，假如此时，你及时向上级请求这个帮助，提高了处理效率，还能节省时间研究其他的东西，真实的代码产出率也会上升。当然上述的问题是指浅层次的疑难问题，像复杂的业务逻辑、源码分析，还是要自己深入理解，花很大气力的，至于上述的及时提出帮助具体指什么，聪明人读到这里应该已经懂了。所以如果没有懂，具体场景具体分析也应该作为一项必备技能。大佬的这个要求每天都会让我反思，我是否可以借别人的帮助，一起解决问题，提高协作能力。</li></ol><p>上述的两点可以简单的归纳为一句：善假于物也，古人的大智慧历久弥新啊。</p><blockquote><p>君子生非异也，善假于物也。</p></blockquote><h4 id="集腋成裘"><a href="#集腋成裘" class="headerlink" title="集腋成裘"></a>集腋成裘</h4><p>提早规避错误，每日提交代码，使用git管理代码，这就引出了持续集成——<strong>CI</strong>的概念，我们前端每日凌晨4点自动bulid,通过后才会打包一个包，如果当前节点有问题，及时修改，不至于到了后期，一整合，发现错误时已经尾大不掉，无法及时有效定位错误了，即使能定位，也会花费大量时间在测试上，以上我对持续集成的简单理解。</p><p>具体执行起来使用<strong><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></strong>。这又是一个大话题了，后期会继续深入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;所在的团队&quot;&gt;&lt;a href=&quot;#所在的团队&quot; class=&quot;headerlink&quot; title=&quot;所在的团队&quot;&gt;&lt;/a&gt;所在的团队&lt;/h3&gt;&lt;p&gt;入职已经有一个半月了，目前的团队氛围对于我这个新人来说，就一句话&lt;strong&gt;如鱼得水&lt;/strong&gt;，感谢机缘，能让我在转行的第一份工作中遇见这个团队，而我也会为了这个团队努力工作，让前端的大旗迎风飞扬。
    
    </summary>
    
      <category term="三省吾身" scheme="https://codevvvv9.github.io/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
      <category term="think" scheme="https://codevvvv9.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>工作小结-1</title>
    <link href="https://codevvvv9.github.io/2018/08/28/%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93-1/"/>
    <id>https://codevvvv9.github.io/2018/08/28/工作小结-1/</id>
    <published>2018-08-28T15:22:20.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scrollTop的兼容性问题"><a href="#scrollTop的兼容性问题" class="headerlink" title="scrollTop的兼容性问题"></a>scrollTop的兼容性问题</h2><p>在做移动端布局时，监控touchmove事件经常会使用<strong>scrollTop</strong>来模拟页面的滑动距离，但是</p><ul><li>仅仅使用document.body.scrollTop来进行滑动距离的判断，会失效 <a id="more"></a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.scrollTop &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'滑动距离大于100像素'</span>);</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'滑动距离小于100像素'</span>);</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-8-28/24266651.jpg" alt=""></p><p>此时应该考虑兼容性，不应该去监听body的滚动距离，而应该去监听html元素的滚动距离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line"><span class="keyword">if</span> (scrollTop &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'滑动距离大于100像素'</span>);</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'滑动距离小于100像素'</span>);</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-8-28/43484629.jpg" alt=""></p><p>上图才是正确的结果，当滚动距离大于100像素时，出现回到顶部的按钮。</p><h3 id="事件戳的转化问题"><a href="#事件戳的转化问题" class="headerlink" title="事件戳的转化问题"></a>事件戳的转化问题</h3><h3 id="URL里的token分析"><a href="#URL里的token分析" class="headerlink" title="URL里的token分析"></a>URL里的token分析</h3><p>为了web安全考虑一般在路径里面后端会传入一个token来标识用户，防止反复攻击，例如<strong><a href="http://10.20.20.109/?nuctoken=111#/" target="_blank" rel="noopener">http://10.20.20.109/?nuctoken=111#/</a></strong>，只有带有nuctoken才会访问到正确的页面，如果没有就会显示errorpage</p><h3 id="i18n在vue中的使用"><a href="#i18n在vue中的使用" class="headerlink" title="i18n在vue中的使用"></a>i18n在vue中的使用</h3><p>为了扩展字符的国际化语言，使用i18n，在vue中单独把汉字字端放到一个cn.js文件中，相当于一个字典。</p><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$t(<span class="string">'字典中某个字段的名字'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;scrollTop的兼容性问题&quot;&gt;&lt;a href=&quot;#scrollTop的兼容性问题&quot; class=&quot;headerlink&quot; title=&quot;scrollTop的兼容性问题&quot;&gt;&lt;/a&gt;scrollTop的兼容性问题&lt;/h2&gt;&lt;p&gt;在做移动端布局时，监控touchmove事件经常会使用&lt;strong&gt;scrollTop&lt;/strong&gt;来模拟页面的滑动距离，但是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅仅使用document.body.scrollTop来进行滑动距离的判断，会失效
    
    </summary>
    
      <category term="三省吾身" scheme="https://codevvvv9.github.io/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
      <category term="think" scheme="https://codevvvv9.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>Vue的组件间通信</title>
    <link href="https://codevvvv9.github.io/2018/05/07/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://codevvvv9.github.io/2018/05/07/Vue的组件间通信/</id>
    <published>2018-05-07T09:51:51.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>组件是插槽式的，例如某个页面有两个组件，其中搜索作为其中一个组件，当它作为组件的时候，它作为子组件的时候需要把参数通过属性的方式传递进来，通知父组件的时候通过触发事件来进行通信。</p><p>以上是组件化的简单描述，与模块化的组要区别在于组件化课深度定制不同的属性，借助父组件的参数值。</p><p>那么问题来了，组件间如何进行通信呢？<a id="more"></a></p><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p>最经典的通信方式就是：父组件与子组件之间进行通信。</p><h3 id="组件的基本写法"><a href="#组件的基本写法" class="headerlink" title="组件的基本写法"></a>组件的基本写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'shareLink'</span>, &#123;</span><br><span class="line">  data() &#123;&#125;,</span><br><span class="line">  props: [<span class="string">'shareLink'</span>],</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  template: <span class="string">``</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述的代码就创建了一个名为<code>shareLink</code>的组件，并且可传递一个名为<code>shareLink</code>的参数值。</p><p>但是注意：</p><ul><li>HTML的规范规定，标签名与属性名都必须是小写字母，所以上述的组件在HTML代码里面默认写成<code>share-link</code></li><li>组件里面的<code>data</code>必须是函数，而不是app.js中的对象写法。</li></ul><p>具体一点的写法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'share'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'shareLink'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="share" v-cloak&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;</span></span><br><span class="line"><span class="string">        请将下面链接分享给面试官</span></span><br><span class="line"><span class="string">      &lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;textarea readonly&gt;&#123;&#123;shareLink&#125;&#125;&lt;/textarea&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中<code>props</code>中是参数的名字，接受别的组件传递的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;share v-bind:share-link=<span class="string">"shareLink"</span> v-show=<span class="string">"shareVisible"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">share</span>&gt;</span></span></span><br><span class="line"><span class="comment">//在html的页面中这样写</span></span><br></pre></td></tr></table></figure><p><code>v-bind</code>将参数的名字绑定上，值是通过app.js获得的shareLink</p><h3 id="简单的对应规则"><a href="#简单的对应规则" class="headerlink" title="简单的对应规则"></a>简单的对应规则</h3><table><thead><tr><th>v-bind</th><th>:share-link</th><th>= “shareLink”</th><th></th></tr></thead><tbody><tr><td>对应的</td><td>props: [‘shareLink’]</td><td>app.js中{shareLink: ‘ ‘}</td></tr></tbody></table><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>子组件想改父组件的<code>data</code>。例如登录后的关闭按钮无用的例子。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">login</span> <span class="attr">v-show</span>=<span class="string">"loginVisible"</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span> </span><br><span class="line">//这是父组件的写法，loginVisible是父组件的变量,很明显儿子无法修改爸爸的数据啊</span><br></pre></td></tr></table></figure><ol start="2"><li>但是儿子特别像修改爸爸的数据</li><li>那么唯一的解决方案就是叫爸爸去修改</li></ol><p>解决方案：</p><ol><li>子组件通过事件告诉爸爸，我需要你做一些改变。</li></ol><p><code>@click=&quot;$emit(&#39;close&#39;)&quot;</code></p><ul><li>注意：在<code>methods</code>中需要使用<code>this.$emit(&#39;&#39;)</code>，但是在<code>@click</code>中不需要用<code>this</code></li></ul><ol start="2"><li>那么爸爸根据儿子的需要做出如下改变</li></ol><p><code>&lt;login v-show=&quot;loginVisible&quot; @close=&quot;loginVisible = false&quot;&gt;</code></p><p><code>@close</code>等同于<code>v-on:close</code></p><p>父子组件通信的demo<a href="http://jsbin.com/logoyoqema/edit?html,js,output" target="_blank" rel="noopener">链接</a></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-5-7/17176263.jpg" alt="父子组件通信图示"></p><h2 id="爷孙组件间的通信"><a href="#爷孙组件间的通信" class="headerlink" title="爷孙组件间的通信"></a>爷孙组件间的通信</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>爷爷看不到孙子在哪里</li><li>但是呢，爷爷就是想控制孙子</li><li>所以呢，借助爸爸来间接的去控制孙子就好啦</li></ol><p>本质上Vue只有父子间通信，<strong>爷孙间通信需要使用两次父子间通信</strong>。</p><h3 id="爷爷只控制孙子"><a href="#爷爷只控制孙子" class="headerlink" title="爷爷只控制孙子"></a>爷爷只控制孙子</h3><p>该版本中爷爷只能控制孙子的显示，但是目前孙子无法反向操作爷爷。</p><p>demo的<a href="http://jsbin.com/xiyoyubita/edit?html,js,output" target="_blank" rel="noopener">链接</a></p><h3 id="孙子逐级冒泡通知爷爷"><a href="#孙子逐级冒泡通知爷爷" class="headerlink" title="孙子逐级冒泡通知爷爷"></a>孙子逐级冒泡通知爷爷</h3><p>孙子先冒泡到爸爸那里，使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'visible'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      我是儿子</span></span><br><span class="line"><span class="string">      &lt;grand-child v-show="visible" @close="$emit('close')"&gt;&lt;/grand-child&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'grandChild'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      我是孙子</span></span><br><span class="line"><span class="string">      &lt;button @click="$emit('close')"&gt;关闭&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>爷爷那里就可以监听到孙子的动作了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="xxx = true"&gt;打开&lt;/</span>button&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;child :visible=<span class="string">"xxx"</span> @close=<span class="string">"log"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/xiyoyubita/edit?html,js,output" target="_blank" rel="noopener">demo的链接</a></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-5-7/87537231.jpg" alt="爷孙间的通信图示"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件是插槽式的，例如某个页面有两个组件，其中搜索作为其中一个组件，当它作为组件的时候，它作为子组件的时候需要把参数通过属性的方式传递进来，通知父组件的时候通过触发事件来进行通信。&lt;/p&gt;
&lt;p&gt;以上是组件化的简单描述，与模块化的组要区别在于组件化课深度定制不同的属性，借助父组件的参数值。&lt;/p&gt;
&lt;p&gt;那么问题来了，组件间如何进行通信呢？
    
    </summary>
    
      <category term="Vue的学习" scheme="https://codevvvv9.github.io/categories/Vue%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Vue" scheme="https://codevvvv9.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>初级前端打怪升级之路</title>
    <link href="https://codevvvv9.github.io/2018/03/30/%E5%88%9D%E7%BA%A7%E5%89%8D%E7%AB%AF%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    <id>https://codevvvv9.github.io/2018/03/30/初级前端打怪升级之路/</id>
    <published>2018-03-30T14:14:29.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何自学前端，以及应该学习的顺序……自己想了下，总结一下</p><p><strong>仅代表初级前端能找到一份养家糊口的工作，至少需要一年多的理解，如果有过其他编程基础，可能需要8个月吧。</strong></p><a id="more"></a><h3 id="零基础的学习计划"><a href="#零基础的学习计划" class="headerlink" title="零基础的学习计划"></a>零基础的学习计划</h3><ol><li>安装vscode 先学 html 5，用MDN文档去学，废弃的属性不需要去看，大跨步的前进，xhtml的那些东西不需要去学了，记住MDN文档里面写的那些新属性，这些是以后面试时经常问的问题。学习是着重注意html 5语义化的含义，体会下。</li><li>接着学习 CSS 3，对于新的属性格外注意，各种特殊情况包括各种居中怎们做，花点时间，记住吧，这个css要多敲代码，看的再多也没用。css是区分优秀前端和其他兼职前端的分界线。</li><li>此时模仿你喜欢的网站做点静态页面。</li><li>继续学习ES 5，这是javascript基础知识，此时进入前端的瓶颈了，多花点时间理解吧，例如函数、闭包、this、作用域、原型链重点理解。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-3-30/68367727.jpg" alt="img"></p><h3 id="精进的计划"><a href="#精进的计划" class="headerlink" title="精进的计划"></a>精进的计划</h3><ol><li>学点MVC思想与面向对象的基础知识，方便后面的jq的理解。</li><li>学习ajax，引出跨域的概念，以及破解跨域的另一个解决方案JSONP，学习主流的数据交换格式JSON。</li><li>进军jquery与bootstrap。jq是第一个你需要接触的框架，减少很多代码量，提升自信心。bootstrap的思想值得细细品味。</li><li>此时有了前端基础和框架，做一个一个完整的项目吧。学会前端工程化的目录结构。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-3-30/73671415.jpg" alt="img"></p><hr><p>以上算是前端的小小入门。接下来是升华阶段。</p><h3 id="升华阶段"><a href="#升华阶段" class="headerlink" title="升华阶段"></a>升华阶段</h3><ol><li>补充http的知识，cookie、session、localstorage、sessionstorage。学习缓存机制以及持久化化存储。</li><li>学习从MVC到MVVM的转换，目前主流的都是MVVM。学习axios库替换jq去操作ajax。</li><li>学习ES 6,这是现在主流框架以及工作要用到的js规范。</li><li>学习前端自动打包器-webpack不用学其他的了，其他的都淘汰了！！！！</li><li>安装webstorm，学习Vue，以及它的全家桶系列。不要学angular，初学者千万不要学它，也不用先学typescript。</li><li>做一个基于Vue全家桶的项目。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-3-30/82209459.jpg" alt="img"></p><p>以上是现代化前端必备的知识体系！！！</p><hr><p>注：锦上添花的是学会react以及小程序开发～，这一步不是必备的</p><p>未来一年努力夯实基础知识，争取早日到达中级前端！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何自学前端，以及应该学习的顺序……自己想了下，总结一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仅代表初级前端能找到一份养家糊口的工作，至少需要一年多的理解，如果有过其他编程基础，可能需要8个月吧。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端之外" scheme="https://codevvvv9.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    
    
      <category term="Dev" scheme="https://codevvvv9.github.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>前端必备网站</title>
    <link href="https://codevvvv9.github.io/2018/03/29/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99/"/>
    <id>https://codevvvv9.github.io/2018/03/29/前端必备网站/</id>
    <published>2018-03-29T13:58:16.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>弃一些花里胡哨的没个卵用的网站，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~</p><p>在自学前端的道路上，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~</p><p>配上<strong>英语</strong>，学的更好哦~</p><a id="more"></a><h3 id="必备的文档类的网站"><a href="#必备的文档类的网站" class="headerlink" title="必备的文档类的网站"></a>必备的文档类的网站</h3><ul><li><strong>MDN web文档</strong></li></ul><p>很权威的文档。有各种详细的使用说明，包括前端但不止于前端，http、ajax都有很深的涉及，示例代码都是各界权威们写的demo，代码清晰、易用；新的标准、废弃的标准、推荐你应该学习的特性，各种官方spec的链接，绝对不会歪曲理解概念；你还可以修改中文的翻译，提出贡献，翻译的的好，可能会有人邀请你工作。当然最好是还是看英文原版的。</p><ul><li>国外的w3scools，看清楚了 链接是这个 <a href="https://www.w3schools.com/" target="_blank" rel="noopener">https://www.w3schools.com/</a></li></ul><p>错误很少，文档很简洁，还能学习英语，就像科学、音乐不分国界一样，代码同样不分国界，都能看得懂。</p><ul><li>所有的你要用的库、框架的<strong>官方文档</strong> 比如webpack、less、jquery、node-sass、Vue、react、BootStrap等</li></ul><h3 id="处理常见的报错和学习新技术经常去的网站"><a href="#处理常见的报错和学习新技术经常去的网站" class="headerlink" title="处理常见的报错和学习新技术经常去的网站"></a>处理常见的报错和学习新技术经常去的网站</h3><ul><li>Github 与Stack Overflow</li></ul><p>学习各种流行库、框架的时候，会报很多错，可以去github上看对应的issue，一般都有解决方案；去Stack Overflow上搜索也能搜索出来。</p><ul><li>国内的segmentfault 以及 掘金</li></ul><p>segmentfault是立志成为国内的Stack Overflow的，也可以解决一部分问题，挺好用的，掘金上面以技术为主的文章很多，还有面试分享，程序员必须的网站。</p><hr><h3 id="专业性的技术网站"><a href="#专业性的技术网站" class="headerlink" title="专业性的技术网站"></a>专业性的技术网站</h3><ul><li>阮一峰的JS入门教程 <a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/</a> 以及 他的ES6入门 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li></ul><p>阮一峰大神是经济学博士，现在在支付宝团队，他学习就是很理智的故事，关注他的博客吧，最前沿的知识都能学到，他也做出了相应的demo。</p><ul><li>廖雪峰的个人网站</li></ul><p>廖雪峰的js教程以及<strong>git教程</strong>很好。</p><ul><li><strong>学习CSS 3</strong>的三个好网站</li></ul><p><strong>css-tricks</strong> <a href="https://css-tricks.com/" target="_blank" rel="noopener">https://css-tricks.com/</a> 从CSS3入门到深爱</p><p><strong>codrops </strong><a href="https://tympanus.net/codrops/" target="_blank" rel="noopener">https://tympanus.net/codrops/</a> 颠覆你对CSS3的认识</p><p><strong>codepen</strong> <a href="https://codepen.io/" target="_blank" rel="noopener">https://codepen.io/</a> 各种提升你CSS3内力的demo</p><ul><li>国内CSS第一人<strong>张鑫旭</strong>的博客</li><li><strong>一丝</strong>的博客</li></ul><p>他的关于为什么要清除浮动以及如何清除浮动的文章，完美解释了面试要问的所有问题。</p><ul><li>高逼格的的v2EX</li></ul><hr><h3 id="国内的专业前端团队"><a href="#国内的专业前端团队" class="headerlink" title="国内的专业前端团队"></a>国内的专业前端团队</h3><ul><li><p>淘宝前端 <a href="http://taobaofed.org/" target="_blank" rel="noopener">http://taobaofed.org/</a></p></li><li><p>腾讯前端团队 <a href="http://www.alloyteam.com/" target="_blank" rel="noopener">http://www.alloyteam.com/</a></p></li><li><p>360前端技术团队 <a href="https://www.75team.com/" target="_blank" rel="noopener">https://www.75team.com/</a></p></li><li><p><strong>其他的</strong>前端团队也很猛，可以多去了解</p></li></ul><hr><h3 id="通过前端技术大拿的博客-开拓眼界"><a href="#通过前端技术大拿的博客-开拓眼界" class="headerlink" title="通过前端技术大拿的博客 开拓眼界"></a>通过前端技术大拿的博客 开拓眼界</h3><ul><li>Twitter、weibo上的前端大神啊</li><li>Vue的作者<strong>尤雨溪</strong>、蚂蚁金服<strong>玉伯</strong>、阿里<strong> winte</strong>r、i5ting(<strong>狼叔</strong>，nodejs布道者)、CNode负责人<strong>alsotang</strong>、<strong>寸志</strong>、<strong>大漠</strong>、<strong>死月、小芋头君</strong>等等大神的言论，注意甄别，以上排名不分前后，都是碾压一切的boss,如果大家记得其他的大佬，我忘了的话，欢迎关注我的<a href="https://github.com/codevvvv9" target="_blank" rel="noopener">github</a>，然后怼我……</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;弃一些花里胡哨的没个卵用的网站，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~&lt;/p&gt;
&lt;p&gt;在自学前端的道路上，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~&lt;/p&gt;
&lt;p&gt;配上&lt;strong&gt;英语&lt;/strong&gt;，学的更好哦~&lt;/p&gt;
    
    </summary>
    
      <category term="前端之外" scheme="https://codevvvv9.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    
    
      <category term="Dev" scheme="https://codevvvv9.github.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>云音乐-2</title>
    <link href="https://codevvvv9.github.io/2018/02/25/%E4%BA%91%E9%9F%B3%E4%B9%90-2/"/>
    <id>https://codevvvv9.github.io/2018/02/25/云音乐-2/</id>
    <published>2018-02-25T13:53:39.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取歌曲的外链"><a href="#获取歌曲的外链" class="headerlink" title="获取歌曲的外链"></a>获取歌曲的外链</h2><p>通过七牛的文档说明，先去<a href="https://developer.qiniu.com/kodo/sdk/1283/javascript#1" target="_blank" rel="noopener">js官方文档</a>，然后通过里面的<a href="https://github.com/qiniu/js-sdk" target="_blank" rel="noopener">js源码地址</a>，选择1.0的版本，进入之后，选择<a href="http://jssdk.demo.qiniu.io/" target="_blank" rel="noopener">示例网站</a>，在获得代码里面，可以发现下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">'FileUploaded'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">up, file, info</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 每个文件上传成功后,处理相关的事情</span></span><br><span class="line">   <span class="comment">// 其中 info.response 是文件上传成功后，服务端返回的json，形式如</span></span><br><span class="line">   <span class="comment">// &#123;</span></span><br><span class="line">   <span class="comment">//    "hash": "Fh8xVqod2MQ1mocfI4S4KpRL6D98",</span></span><br><span class="line">   <span class="comment">//    "key": "gogopher.jpg"</span></span><br><span class="line">   <span class="comment">//  &#125;</span></span><br><span class="line">   <span class="comment">// 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// var domain = up.getOption('domain');</span></span><br><span class="line"> <span class="comment">// var res = parseJSON(info.response);</span></span><br><span class="line"> <span class="comment">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><a id="more"></a><p>很明显最后三行与我的目的有关，打开注释，改造成我所需要的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domain = up.getOption(<span class="string">'domain'</span>);</span><br><span class="line"><span class="keyword">var</span> response = <span class="built_in">JSON</span>.parse(info.response);</span><br><span class="line"><span class="keyword">var</span> sourceLink = <span class="string">'http://'</span> + domain + <span class="string">'/'</span> + <span class="built_in">encodeURIComponent</span>(response.key);</span><br></pre></td></tr></table></figure><h3 id="几点要注意的"><a href="#几点要注意的" class="headerlink" title="几点要注意的"></a>几点要注意的</h3><ol><li>response的key就是我拖曳或者上传的歌曲</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/25479977.jpg" alt="response.key是啥"></p><ol start="2"><li>为什么要用<code>encodeURIComponent</code></li></ol><p>因为你上传的时候必然会有中文吧，浏览器和服务器端都不会懂你问的这些中文是什么鬼，我们要用URL编码处理一下这个response.key（也就是歌曲的名字），之所以不用<code>encodeURI</code>，是因为它会把一个东西当做一个整体的，如果含有&amp;，还是会把&amp;传给你，而这个很有可能会有歧义。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/18569683.jpg" alt="使用了encodeURIComponent"></p><p>如果我想把带有&amp;的一串东西放到查询参数里面，需要使用encodeURIComponent。</p><h2 id="CSS布局以及HTML结构划分"><a href="#CSS布局以及HTML结构划分" class="headerlink" title="CSS布局以及HTML结构划分"></a>CSS布局以及HTML结构划分</h2><p>初步规划是左边第一栏是new-song，中间是song-list,底部是upload-song，右面是song-form部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;page&gt;</span><br><span class="line">  &lt;aside <span class="class"><span class="keyword">class</span></span>=<span class="string">"sidebar"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"newSong"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="songList-container"&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"uploadArea"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"uploadContainer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"draggable"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"uploadButton"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"clickable"</span>&gt;</span><br><span class="line">          &lt;p&gt;点击或者拖曳文件&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;文件大小不能超过 40MB&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>aside&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>page&gt;</span><br></pre></td></tr></table></figure><p>page区域使用flex布局，是的aside和main区域左右分布，然后aside在使用flex布局并使用flex-direction=column。使之上下排列。</p><h3 id="CSS的一些小技巧"><a href="#CSS的一些小技巧" class="headerlink" title="CSS的一些小技巧"></a>CSS的一些小技巧</h3><ol><li>border: dashed是把阴影虚线化。</li><li>git commit -v查看更改的内容是什么。</li><li>属性选择器  <code>.form input[type=button]</code></li><li>为了实现选中label激活里面的input可能会选择label包裹input的布局，可是存在风险。比如如果label的文字过多，你加了宽度是没有用的，只是会换行而已（显然不是我想看到的），因为label是inline元素，可是改成inline-block又会有bug（一道空隙）。所以只能选择不用label去包裹input了。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/55783109.jpg" alt="对不齐了"></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/40562762.jpg" alt=""></p><p>优化的代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.form &gt; .row &gt; label&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: flex-end;</span><br><span class="line">  align-items: center;</span><br><span class="line">  width: <span class="number">4</span>em;</span><br><span class="line">  margin-right: <span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.form &gt; .row.actions&#123;</span><br><span class="line">  margin-left: calc(<span class="number">4</span>em + <span class="number">5</span>px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>input的字体应该继承才行，不然字体大小不对。<code>input{font: inherit;}</code></li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/75319998.jpg" alt=""></p><ol start="6"><li>背景色是在border里面的，margin上没有背景色</li></ol><h2 id="模块化和MVC的设计"><a href="#模块化和MVC的设计" class="headerlink" title="模块化和MVC的设计"></a>模块化和MVC的设计</h2><p>如果一个模块变化了，如何通知另外的模块我变了呢，最简单的是使用一个全局的js，告诉其他的js，我变了。</p><p>先写一个全局的app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">window</span>.app = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在要发起通信的js文件上写上下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.app.newSong.active()</span><br><span class="line"><span class="built_in">window</span>.app.songForm.reset()</span><br><span class="line">...</span><br><span class="line"><span class="built_in">window</span>.app.uploadSong = controller</span><br></pre></td></tr></table></figure><p>也就是说其他的js模块只是往外暴露他们对应的js就可以了。但是这种方式的通信耦合度有点高，不利于后期更改。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/98205421.jpg" alt="模块间通信"></p><p>因为假如3变了要去通知1和4的话，1和4还是知道3的存在，所以不应该让1和4知道3的存在。采取中间环节来转换，那就是发布订阅模式。</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-25/88110527.jpg" alt="发布订阅模式"></p><p>使用全局的eventHub模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.eventHub = &#123;</span><br><span class="line">  events: &#123;</span><br><span class="line">    <span class="comment">// '遗憾': [fn],</span></span><br><span class="line">    <span class="comment">// '追光者': [],</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发布</span></span><br><span class="line"><span class="comment">   * @param &#123;*事件名字&#125; eventName </span></span><br><span class="line"><span class="comment">   * @param &#123;*数据&#125; data </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emit(eventName, data) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.events) &#123;</span><br><span class="line">      <span class="keyword">if</span>(key === eventName) &#123;</span><br><span class="line">        <span class="keyword">let</span> fnList = <span class="keyword">this</span>.events[key]</span><br><span class="line">        fnList.map(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">          fn.call(<span class="literal">undefined</span>, data)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param &#123;*订阅的事件名字&#125; eventName </span></span><br><span class="line"><span class="comment">   * @param &#123;*订阅事件之后执行的函数&#125; fn </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  on(eventName, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[eventName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[eventName].push(fn)    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他模块的js使用的时候就可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.eventHub.emit(<span class="string">'upload'</span>, &#123;</span><br><span class="line">  <span class="string">'url'</span>: sourceLink,</span><br><span class="line">  <span class="string">'name'</span>: response.key</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="几个注意要点"><a href="#几个注意要点" class="headerlink" title="几个注意要点"></a>几个注意要点</h3><ol><li>ES6的一个特性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render(data = &#123;&#125;) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你传值的时候，没有传值或者传的值是undefined就给你一个空对象。</p><ol start="2"><li>省略一点代码</li></ol><p>在view里面写上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init()&#123;</span><br><span class="line"><span class="keyword">this</span>.$el = $(<span class="keyword">this</span>.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Vue框架里面V-for出现的必要性</li></ol><p>如果直接用template的话</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"songList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>歌曲233333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲52222222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>歌曲1033<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很显然这种template很难看，所以使用如下的代码改造。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">   el: <span class="string">'#songList-container'</span>,</span><br><span class="line">   template: <span class="string">`</span></span><br><span class="line"><span class="string">   &lt;ul class="songList"&gt;</span></span><br><span class="line"><span class="string">   &lt;/ul&gt;</span></span><br><span class="line"><span class="string">   `</span>,</span><br><span class="line">   render(data) &#123;</span><br><span class="line">     <span class="keyword">let</span> $el = $(<span class="keyword">this</span>.el)</span><br><span class="line">     $el.html(<span class="keyword">this</span>.template)</span><br><span class="line">     <span class="keyword">let</span> &#123;songs&#125; = data</span><br><span class="line">     <span class="keyword">let</span> liList = songs.map(<span class="function">(<span class="params">song</span>) =&gt;</span> $(<span class="string">'&lt;li&gt;&lt;/li&gt;'</span>).text(song.name))</span><br><span class="line">     $el.find(<span class="string">'ul'</span>).empty()</span><br><span class="line">     liList.map(<span class="function">(<span class="params">domLi</span>) =&gt;</span> &#123;</span><br><span class="line">       $el.find(<span class="string">'ul'</span>).append(domLi)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>而以上的仍然麻烦，所以Vue发明了V-for的语法，不过人家是使用了正则表达式去实现的。</p><p>4.深拷贝与浅拷贝的阴影</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.model.data)</span><br><span class="line"><span class="keyword">let</span> object = <span class="built_in">JSON</span>.parse(string)</span><br><span class="line"><span class="comment">// window.eventHub.emit('create', this.model.data) //一开始用的是这句代码，明显this.model.data会被多次篡改</span></span><br><span class="line"><span class="built_in">window</span>.eventHub.emit(<span class="string">'create'</span>, object)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取歌曲的外链&quot;&gt;&lt;a href=&quot;#获取歌曲的外链&quot; class=&quot;headerlink&quot; title=&quot;获取歌曲的外链&quot;&gt;&lt;/a&gt;获取歌曲的外链&lt;/h2&gt;&lt;p&gt;通过七牛的文档说明，先去&lt;a href=&quot;https://developer.qiniu.com/kodo/sdk/1283/javascript#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js官方文档&lt;/a&gt;，然后通过里面的&lt;a href=&quot;https://github.com/qiniu/js-sdk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js源码地址&lt;/a&gt;，选择1.0的版本，进入之后，选择&lt;a href=&quot;http://jssdk.demo.qiniu.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;示例网站&lt;/a&gt;，在获得代码里面，可以发现下面代码&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;FileUploaded&#39;&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;up, file, info&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 每个文件上传成功后,处理相关的事情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 其中 info.response 是文件上传成功后，服务端返回的json，形式如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//    &quot;hash&quot;: &quot;Fh8xVqod2MQ1mocfI4S4KpRL6D98&quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//    &quot;key&quot;: &quot;gogopher.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//  &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// var domain = up.getOption(&#39;domain&#39;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// var res = parseJSON(info.response);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// var sourceLink = domain + res.key; 获取上传成功后的文件的Url&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="云音乐" scheme="https://codevvvv9.github.io/categories/%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="jQuery" scheme="https://codevvvv9.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>云音乐-1</title>
    <link href="https://codevvvv9.github.io/2018/02/21/%E4%BA%91%E9%9F%B3%E4%B9%90-1/"/>
    <id>https://codevvvv9.github.io/2018/02/21/云音乐-1/</id>
    <published>2018-02-21T03:37:49.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是云音乐的需求分析以及基本环境的搭建，主要是LeanCloud和七牛的使用。</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>先根据<a href="https://music.163.com/m/" target="_blank" rel="noopener">网易云音乐</a>移动端去分析需求，看看有哪些能做的</p><h3 id="做啥"><a href="#做啥" class="headerlink" title="做啥"></a>做啥</h3><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-20/82573501.jpg" alt="用例图"></p><p>目前初步分析的需求如上图所示，主要针对两个角色（普通用户和管理员）。</p><a id="more"></a><h3 id="用啥"><a href="#用啥" class="headerlink" title="用啥"></a>用啥</h3><p>在学习阶段主要是学会核心概念、流程、代码，能用原生JS做就用原生JS做，少用库去做事。</p><p>可是到了做项目的时候项目（建立在已经学会了基本的概念与敲了足够的代码量之后），应该采取不同的策略去完成项目，例如选择合适的库、看文档、写demo、copy大神成功的代码。</p><p>所以本项目采用了成熟的jQuery以及LeanCloud、七牛作为后台的数据库。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-20/69890088.jpg" alt="架构图"></p><h2 id="LeanCloud"><a href="#LeanCloud" class="headerlink" title="LeanCloud"></a>LeanCloud</h2><p>一个简单的数据库(比MySQL都简单，主要是更加形象，能与项目迅速的结合并给我很多正反馈)。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接去看<a href="https://leancloud.cn/docs/sdk_setup-js.html#hash1620893804" target="_blank" rel="noopener">文档</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储服务（包括推送和统计）</span></span><br><span class="line">cd 项目目录</span><br><span class="line">npm install leancloud-storage --save</span><br><span class="line"><span class="comment">// 2. 在html里引入av.min.js</span></span><br><span class="line">&lt;script src=<span class="string">"../node_modules/leancloud-storage/dist/av-min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化AV对象"><a href="#初始化AV对象" class="headerlink" title="初始化AV对象"></a>初始化AV对象</h3><p>我们使用LeanCloud主要是用的这个AV对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> APP_ID = <span class="string">'0ISMRGDfPWtQcP8WktXGADsl-gzGzoHsz'</span>; <span class="comment">//与项目相关</span></span><br><span class="line"><span class="keyword">var</span> APP_KEY = <span class="string">'FKV4IYQNPyB6C5jFBv8vJ7LT'</span>; <span class="comment">//与项目相关</span></span><br><span class="line"></span><br><span class="line">AV.init(&#123;</span><br><span class="line">  appId: APP_ID,</span><br><span class="line">  appKey: APP_KEY</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>写完上述代码可以简单的测试一下是否成功，最简单的就是直接打印<code>console.log(window.AV)</code></p><p>官方推荐如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TestObject = AV.Object.extend(<span class="string">'TestObject'</span>);</span><br><span class="line"><span class="keyword">var</span> testObject = <span class="keyword">new</span> TestObject();</span><br><span class="line">testObject.save(&#123;</span><br><span class="line">  words: <span class="string">'Hello World!'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'LeanCloud Rocks!'</span>); <span class="comment">//成功后将在屏幕上弹出这句话</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时会发现LeanCloud的项目应用下多一个表<code>TestObject</code>,表里面有一个字段是<code>words</code>，值是<code>Hello World!</code></p><p>所以可以推测出这个就是LeanCloud提供给我们生成数据库表以及字段的代码，所以我实际中可以如下使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数据库，只是本地而已</span></span><br><span class="line"><span class="keyword">var</span> TestObject = AV.Object.extend(<span class="string">'Playlist'</span>); </span><br><span class="line"><span class="comment">//创建一条记录</span></span><br><span class="line"><span class="keyword">var</span> testObject = <span class="keyword">new</span> TestObject(); </span><br><span class="line"><span class="comment">//保存记录，LeanCloud端</span></span><br><span class="line">testObject.save(&#123; </span><br><span class="line">  name: <span class="string">'test'</span>,</span><br><span class="line">  cover: <span class="string">'test'</span>,</span><br><span class="line">  creatorId: <span class="string">'test'</span>,</span><br><span class="line">  description: <span class="string">'test'</span>,</span><br><span class="line">  songs: [<span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123; </span><br><span class="line">alert(<span class="string">'LeanCloud Rocks!'</span>); </span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">alert(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果如下图所示</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-20/57467194.jpg" alt="LeanCloud的变化"></p><p>通过上图可以简单的看出LeanCloud可以存储字符串以及数组。</p><p><code>ACL</code>: Access Control Layer</p><p>像MP3等文件只能借助下面的七牛去存储了</p><h2 id="七牛"><a href="#七牛" class="headerlink" title="七牛"></a>七牛</h2><p>这是一个使用云存储的信赖度极高的工具。</p><p>毫无疑问的，先要看<a href="https://developer.qiniu.com/kodo/sdk/1283/javascript" target="_blank" rel="noopener">文档</a>安装</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>目前有1.X和2.X版本，可以预料到版本的问题有可能会产生bug.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install qiniu-js</span><br><span class="line">&lt;script src=<span class="string">"../node_modules/qiniu-js/dist/qiniu.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过sctipt标签引入该文件，会在全局生成名为 <code>qiniu</code> 的对象(2.X版本的)，而这个对象会为后面的上传文件埋下致命的bug。</p><p>可以通过简单的<code>console.log(qiniu)</code>，验证是否成功。</p><p>可以看一下，七牛的<a href="http://jssdk.demo.qiniu.io/" target="_blank" rel="noopener">用例</a></p><h3 id="一个小bug"><a href="#一个小bug" class="headerlink" title="一个小bug"></a>一个小bug</h3><p>在后面的plupload的时候会报错，很奇怪。后来看七牛的用例的源码，在人家的<code>qiniu.min.js</code>的里面发现的<code>Qiniu</code>,而我的没有，所以猜测七牛用例使用的是1.x版本，果断通过更改版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"leancloud-storage"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="string">"qiniu-js"</span>: <span class="string">"^1.0.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//修改完package.json</span></span><br><span class="line"> npm i</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>在页面中引入qiniu.min.js后，初始化uploader，在这之前需要安装plupload,而安装这个有需要安装moxie。</p><p>plupload直接通过npm就可以了，而这个moxie需要去github下载源码自己导入。</p><hr><h3 id="服务端准备"><a href="#服务端准备" class="headerlink" title="服务端准备"></a>服务端准备</h3><blockquote><p>本 SDK 依赖服务端颁发的上传凭证，可以通过以下二种方式实现：</p><ul><li>利用七牛服务端 SDK 构建后端服务</li><li>利用七牛底层 API 构建服务，详见七牛<a href="https://developer.qiniu.com/kodo/manual/put-policy" target="_blank" rel="noopener">上传策略</a>和<a href="https://developer.qiniu.com/kodo/manual/upload-token" target="_blank" rel="noopener">上传凭证</a></li></ul><p>后端服务应提供一个 URL 地址，供 SDK 初始化使用，前端通过 Ajax 请求该地址后获得 upToken。 Ajax 请求成功后，服务端应返回json</p></blockquote><p>如上是七牛为了安全性考虑的，必须获得一个token。所以我选择使用node做一个假的服务端，来获取token.</p><h3 id="nodejsServer"><a href="#nodejsServer" class="headerlink" title="nodejsServer"></a>nodejsServer</h3><p>惯例使用七牛的<a href="https://developer.qiniu.com/kodo/sdk/1289/nodejs" target="_blank" rel="noopener">nodejs文档</a></p><p>先安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qiniu</span><br></pre></td></tr></table></figure><p>在<code>server.js</code>里面简单的构建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/uptoken'</span>) &#123;</span><br><span class="line">    response.statusCode = <span class="number">200</span></span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/json;charset=utf-8'</span>)</span><br><span class="line">    response.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义好其中鉴权对象mac：</span></span><br><span class="line">    <span class="keyword">var</span> config = fs.readFileSync(<span class="string">'./qiniu-key.json'</span>) <span class="comment">//真正的accessKey, secretKey在这里</span></span><br><span class="line">    config = <span class="built_in">JSON</span>.parse(config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123;accessKey, secretKey&#125; = config</span><br><span class="line">    <span class="keyword">var</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单上传的凭证</span></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">      scope: <span class="string">"163-music-demo-1"</span>, <span class="comment">//应用的名字</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(options);</span><br><span class="line">    <span class="keyword">var</span> uploadToken=putPolicy.uploadToken(mac);</span><br><span class="line">    response.write(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "uptoken": "<span class="subst">$&#123;uploadToken&#125;</span>"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>做好这个工作之后，uploader可以工作了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class="line">...</span><br><span class="line">uptoken_url: <span class="string">'http://localhost:8888/uptoken'</span>, </span><br><span class="line"><span class="comment">//只需要注意这一句，其他代码抄文档。以后每次先开一个node server.js 8888</span></span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此所有的代码，可以看这个<a href="https://github.com/codevvvv9/163-music-demo-1/tree/d21fefc6ab09f50393df99de210b9a7ed3eddf58" target="_blank" rel="noopener">版本</a></p><p>既然支持拖曳上传和普通上传，需要做一些简单的css样式的修改以及html的改动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  p&#123;margin: 5px; padding: 0;&#125;</span></span><br><span class="line"><span class="undefined">  #container&#123;</span></span><br><span class="line"><span class="undefined">  padding: 50px 80px;</span></span><br><span class="line"><span class="undefined">  border: 2px dashed #ddd;</span></span><br><span class="line"><span class="undefined">  border-radius: 20px;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">  justify-content: center;</span></span><br><span class="line"><span class="undefined">  align-items: center;</span></span><br><span class="line"><span class="undefined">  width: 200px;</span></span><br><span class="line"><span class="undefined">  flex-direction: column;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"pickfiles"</span>&gt;</span>点击或者拖曳文件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>文件大小不能超过 40MB<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"uploadStatus"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class="line">browse_button: <span class="string">'pickfiles'</span>,       <span class="comment">//上传选择的点选按钮，**必需**</span></span><br><span class="line">...</span><br><span class="line">    container: <span class="string">'container'</span>,           <span class="comment">//上传区域DOM ID，默认是browser_button的父元素，</span></span><br><span class="line">    max_file_size: <span class="string">'40mb'</span>,           <span class="comment">//最大文件体积限制</span></span><br><span class="line">    dragdrop: <span class="literal">true</span>,                   <span class="comment">//开启可拖曳上传</span></span><br><span class="line">    drop_element: <span class="string">'container'</span>,        <span class="comment">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class="line">    auto_start: <span class="literal">true</span>,                 <span class="comment">//选择文件后自动上传，若关闭需要自己绑定事件触发上传</span></span><br><span class="line">    init: &#123;</span><br><span class="line">      <span class="string">'FilesAdded'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">up, files</span>) </span>&#123;</span><br><span class="line">      plupload.each(files, <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 文件添加进队列后,处理相关的事情</span></span><br><span class="line">      &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'BeforeUpload'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 每个文件上传前,处理相关的事情</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'UploadProgress'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 每个文件上传时,处理相关的事情</span></span><br><span class="line">        uploadStatus.textContent = <span class="string">'上传中'</span> <span class="comment">//提示用户上传进度的</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'FileUploaded'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">up, file, info</span>) </span>&#123;</span><br><span class="line">        uploadStatus.textContent = <span class="string">'上传完毕'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'Error'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">up, err, errTip</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//上传出错时,处理相关的事情</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'UploadComplete'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//队列文件处理完毕后,处理相关的事情</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>至此，简单的上传文件的效果做完了，全部的<a href="https://github.com/codevvvv9/163-music-demo-1" target="_blank" rel="noopener">代码版本</a></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-20/72923380.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是云音乐的需求分析以及基本环境的搭建，主要是LeanCloud和七牛的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;先根据&lt;a href=&quot;https://music.163.com/m/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网易云音乐&lt;/a&gt;移动端去分析需求，看看有哪些能做的&lt;/p&gt;
&lt;h3 id=&quot;做啥&quot;&gt;&lt;a href=&quot;#做啥&quot; class=&quot;headerlink&quot; title=&quot;做啥&quot;&gt;&lt;/a&gt;做啥&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://p3tha6q4v.bkt.clouddn.com/18-2-20/82573501.jpg&quot; alt=&quot;用例图&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前初步分析的需求如上图所示，主要针对两个角色（普通用户和管理员）。&lt;/p&gt;
    
    </summary>
    
      <category term="云音乐" scheme="https://codevvvv9.github.io/categories/%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="jQuery" scheme="https://codevvvv9.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>爱搞事情的webpack</title>
    <link href="https://codevvvv9.github.io/2018/02/13/%E7%88%B1%E6%90%9E%E4%BA%8B%E6%83%85%E7%9A%84webpack/"/>
    <id>https://codevvvv9.github.io/2018/02/13/爱搞事情的webpack/</id>
    <published>2018-02-13T14:06:29.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/60817621.jpg" alt="webpack"></p><p>当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><ol><li>局部安装,官方也是推荐安装到项目目录下</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo<span class="number">-1</span></span><br><span class="line">cd webpack-demo<span class="number">-1</span></span><br><span class="line">npm init -y <span class="comment">//生成package.json,并且一路同意,如果没啥个性化的内容则省了你一路狂按enter</span></span><br><span class="line">npm install --save-dev webpack <span class="comment">//安装到开发环境里面(devDependicies)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>webpack基本配置文件 <a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch webpack.config.js</span><br><span class="line">vi webpack.config.js</span><br></pre></td></tr></table></figure></li></ol><p>配置文件内容如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 这里应用程序开始执行,webpack 开始打包</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// webpack 如何输出结果的相关选项</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,<span class="comment">//输出资源块的名字(asset chunk)</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>) <span class="comment">// 所有输出文件的目标路径,我的就是./dist/bundle.js</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-11/81006787.jpg" alt="基本使用"></p><p>把当前目录的src下的index.js打包到了dist目录下，并且生成了(emmited)一个改头换面的<code>bundle.js</code>，里面的代码面目全非啊。</p><h3 id="可以有多个入口-entry"><a href="#可以有多个入口-entry" class="headerlink" title="可以有多个入口(entry)"></a>可以有多个入口(entry)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    scss: <span class="string">'./src/css/main.scss'</span>,  <span class="comment">//对象的键名scss 就是输出文件的name</span></span><br><span class="line">    bundle: <span class="string">'./src/js/app.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">   </span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist/js'</span>)</span><br><span class="line">    <span class="comment">// publicPath: "/output/"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>多个入口最好写成对象的形式，官网说如果写成了数组，输出的内容会是数组的第一个。</p><p>上述代码会在<code>dist/js</code>目录下生成<code>scss.js和bundle.js</code></p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>其中，配置文件的第一行代码使用了Node的内置模块<code>path</code>,并且在它前面加上 <code>__dirname</code>这个全局变量(也就是第七行代码)。可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作。<br>即使你的index.js内容为空，bundle.js里面也有一些基本的打包代码。</p><ol start="3"><li>基本的使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法，使用当前目录的node_modules里面的webpack</span></span><br><span class="line">./node_modules/.bin/webpack </span><br><span class="line"><span class="comment">//第二种方法使用npm脚本</span></span><br><span class="line"><span class="comment">//首先在你的package.json里面添加下列代码</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后，使用下列代码即可</span></span><br><span class="line">npm run bulid</span><br><span class="line"><span class="comment">//第三种方法，高版本的npm自带了npx</span></span><br><span class="line">npx webpack <span class="comment">//npx会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！</span></span><br></pre></td></tr></table></figure></li></ol><p>所以说呢，我选择了第三种使用方法。</p><h2 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h2><p>ES6或其他版本js转换成通用js代码，毫无疑问应该使用<code>babel</code>，不过在<code>webpack</code>的世界里面统一使用<code>loader</code>，所以我们<code>google webpack babel-loader</code>。<br>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><h3 id="有个坑，很容易搞错的坑"><a href="#有个坑，很容易搞错的坑" class="headerlink" title="有个坑，很容易搞错的坑"></a>有个坑，很容易搞错的坑</h3><p><code>babel-loader</code>不同版本的安装脚本、配置文件是不同的……<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-11/72818242.jpg" alt="小心点"><br>(<em>@ο@</em>) 哇～你搜出的最新的文档用这么小的文字告诉你，你用<code>webpack 3.x babel-loader 7.x | babel 6.x</code>的去这个<a href="https://github.com/babel/babel-loader/tree/7.x" target="_blank" rel="noopener">链接</a>,<code>webpack 3.x | babel-loader 8.x | babel 7.x</code>的去<a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">当前的这链接链接</a>。<br>好吧，我用上一版本的吧。<br>所以我的安装脚本是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env webpack</span><br></pre></td></tr></table></figure></p><p>配置文件是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依然属于webpack.config.js配置的一部分，</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="comment">//这是关于模块的配置</span></span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">//模块规则（配置 loader、解析器等选项）</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>, <span class="comment">//使用正则判断后缀是js的文件</span></span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>, </span><br><span class="line">      <span class="comment">//除了这两目录下的node_modules|bower_components</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>, <span class="comment">//用这个loader处理.js的文件</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">'env'</span>] <span class="comment">//选项，还记得单独使用babel的时候建立的那个.babelrc嘛，就是那个作用。</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借此可以得到<code>loader</code>的两个作用：</p><ol><li>识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性)</li><li>转换这些文件，从而使其能够被添加到依赖中（并且最终添加到 bundle 中）(use 属性)<br>在<code>./src/js/</code>有<code>module-1.js、module-2.js、app.js</code>三个文件，都是新的语法，用的模块化写法，有的浏览器不支持，所以需要转化。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module-1.js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fn</span><br><span class="line"><span class="comment">//module-2.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fn</span><br><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> <span class="string">'./module-1.js'</span></span><br><span class="line"><span class="keyword">import</span> y <span class="keyword">from</span> <span class="string">'./module-2.js'</span></span><br><span class="line">x()</span><br><span class="line">y()</span><br></pre></td></tr></table></figure><hr><p><em>最终效果，打开的<a href="https://codevvvv9.github.io/webpack-demo-1/dist/index.html">我的预览链接</a></em>,使用<code>ctrl+shift+J</code>，会看到打印出1和2</p><hr><h2 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h2><p>如果使用了预编译的scss语言，要把scss文件变成css并加入到html里面，思路同上，<code>google webpack scss</code><br>得到如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader node-sass webpack --save-dev</span><br></pre></td></tr></table></figure></p><p>模块配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.scss$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个官方的就比较给力了，很清楚地用法</p><ul><li>先用sass-loader把<code>./src/csa/main.scss</code>编译成main.css</li><li>再用css-loader把main.css变成符合CommonJS规范的</li><li>把main.css变成js字符串，并创建style节点，把它放进去，这样html就可以显示啦。</li></ul><p>不过坑爹依旧☺……用的时候报错喽～</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-11/2444698.jpg" alt="缺俩文件"></p><p>第一次就说缺style-loader，好吧……自觉点把另一个一起安装了把。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-11/60086288.jpg" alt="style标签"></p><hr><p>所以，打开<a href="https://codevvvv9.github.io/webpack-demo-1/dist/index.html">我的预览链接</a>，会看到我的预览的背景是灰色的。</p><hr><h3 id="此时的webpack-config-js最终代码"><a href="#此时的webpack-config-js最终代码" class="headerlink" title="此时的webpack.config.js最终代码"></a>此时的webpack.config.js最终代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/js/app.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist/js/&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      exclude: /(node_modules|bower_components)/,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [&apos;env&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    test: /\.scss$/,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">        loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">        loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以借助webpack强大的模块化，通过其构建的依赖关系图(dependency graph)把js、scss都搞到了bundle.js里面，真是牛～</p><h2 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h2><p>本来搞了一个html-loader，优化html，把空格、注释都给压缩掉，提高性能，可是实际使用中也没有报错，也没啥效果，比较尴尬……自己埋个坑后面补一补。</p><h2 id="Copy-Webpack-Plugin"><a href="#Copy-Webpack-Plugin" class="headerlink" title="Copy Webpack Plugin"></a>Copy Webpack Plugin</h2><p>目前呢，前面的loader用的都很爽。在src目录下修改完了代码，一个npx webpack，刷新就可以看到效果了，体验很棒。<br>但是今天坐在电脑前面，回想代码，以前在前端工程话的道路上，scss、js、html都是被监视着(wacth)，开四个命令行窗口，只要src下一有风吹草动，就会把修改后的代码更新过去。</p><ul><li>目前使用的webpack可以完全自动化<code>scss、js</code>了，可我如果修改了src/index.html，dist/也无法获知我的修改啊</li><li>然后我google一一会，发现了这货<code>Copy Webpack Plugin</code> </li></ul><p>哎呀，是个<code>plugin</code>，终于webpack的四大基本概念都到齐了,前面搞了<code>entry output loder</code>，今天用一下<code>plugin</code>。</p><blockquote><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<br>基本安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D copy-webpack-plugin</span><br></pre></td></tr></table></figure></p></blockquote><p>Copy Webpack Plugin配置文件(plugin的和loader的配置文件可不是一个套路。loader是在module.rules数组的每一个对象里面(即rules数组的每一个value)，而plugin是在module的plugins数组里面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//依然在webpack.config.js</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new CopyWebpackPlugin([ ...patterns ], options)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/webpack-contrib/copy-webpack-plugin#to" target="_blank" rel="noopener">Copy Webpack Plugin的github</a>给的代码，一开始把我搞蒙了，和webpack官网的代码不大一样啊。后来才发现原来用了<code>module.exports = config;</code><br>在我的小demo里使用的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new CopyWebpackPlugin([ &#123;</span><br><span class="line">      //原来一个plugin就是一个对象啊，使用的时候实例化对象即可</span><br><span class="line">      from: &apos;src/index.html&apos;, //从src/index.html目录下复制</span><br><span class="line">      to: &apos;../index.html&apos;,  //到dist/index.html</span><br><span class="line">      toType: &apos;file&apos; //复制类型是文件</span><br><span class="line">    &#125;], &#123; copyUnmodified: true &#125;) //把未修改的部分也复制过去</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>这个插件可以实现很多功能，具体的细节看<a href="https://github.com/webpack-contrib/copy-webpack-plugin#to" target="_blank" rel="noopener">这里</a></p><h3 id="关于目录的一个小问题"><a href="#关于目录的一个小问题" class="headerlink" title="关于目录的一个小问题"></a>关于目录的一个小问题</h3><p>上面代码为什么这么写呢<code>to: &#39;../index.html&#39;,</code> ，试了好几遍发现没有报错，就是没有结果，最后搞明白了是路径的问题……<br>还记得 四大基本概念的<code>output</code>里面的path吗，回头看一开始的<a href="#path">path</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist/js/&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>项目的path是<code>dist/js</code>下，所以应该复制到上一级目录下<code>../</code>也就是<code>dist/</code>目录下了。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/89134482.jpg" alt="效果"></p><h3 id="可以看到预览链接里面的文字啦"><a href="#可以看到预览链接里面的文字啦" class="headerlink" title="可以看到预览链接里面的文字啦"></a>可以看到<a href="https://codevvvv9.github.io/webpack-demo-1/dist/index.html">预览链接</a>里面的文字啦</h3><p>动态效果可以看下图<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/50816812.jpg" alt="动态效果"></p><h2 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h2><p>上述代码有个小问题使用了<code>display： flex</code>把<code>ul&gt;li</code>变成了横排，但是这玩意有兼容性。当初我的<a href="https://segmentfault.com/a/1190000013231817" target="_blank" rel="noopener">一篇文章</a>唯一的一个评论就是这么说我的……</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/6879679.jpg" alt="没有考虑兼容性"></p><p>检查兼容性(虽然这是严谨要求，我还是老忘)，可以去<a href="https://caniuse.com/#feat=flexbox" target="_blank" rel="noopener">caniuse</a> 看一下,(<em>@ο@</em>) 哇～IE没有绿的哎，支持太差了。( ⊙ o ⊙ )！万一以后我项目搞大了，IE的用户、老安卓的用户想看我项目咋办呢，只能加一下前缀优化一下啦。<br>有个挺牛的<a href="https://autoprefixer.github.io/" target="_blank" rel="noopener">在线的autoprefixer</a>，也可以去在线转换。<br>既然使用了webpack就<code>Google webpack autoprefixer</code>，遗憾的发现<code>autoprefixer</code>官方推荐使用<code>postcss-loader</code><br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/79391220.jpg" alt="autoprefixer过期了"></p><h3 id="postcss-loader解决兼容性问题"><a href="#postcss-loader解决兼容性问题" class="headerlink" title="postcss-loader解决兼容性问题"></a>postcss-loader解决兼容性问题</h3><p>先吐槽一下，这货的文档也是稀烂……</p><ol><li>官方安装脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D postcss-loader</span><br></pre></td></tr></table></figure><ol start="2"><li>需要单独配置文件postcss.config.js，官方的写法是下面这个（最无语的就是这个……，<strong>下面的必错，写出来就是警告大家，官方的也不一定对</strong>）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  parser: &apos;sugarss&apos;, // 铪？？？？解析器是sugarss???</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;postcss-import&apos;: &#123;&#125;,</span><br><span class="line">    &apos;postcss-cssnext&apos;: &#123;&#125;,</span><br><span class="line">    &apos;cssnano&apos;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webpack.config.js的添加时还要注意下面的几点</p><blockquote><p>After setting up your postcss.config.js, add postcss-loader to your webpack.config.js. You can use it standalone or in conjunction with css-loader (recommended). Use it after css-loader and style-loader, but before other preprocessor loaders like e.g sass|less|stylus-loader, if you use any.</p></blockquote><p>这段文档的要点就是让你注意<code>postcss-loader</code>应该在<code>css-loader style-loader</code>之后，但是一定要在其他的预处理器<code>preprocessor loaders</code>之前，例如<br><code>sass|less|stylus-loader</code>。</p><ol start="3"><li>官方给了一个推荐的配置代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//依然是webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">          &apos;postcss-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本项目用的是<code>.src/css/main.scss</code>,只能尝试着将上述代码加到相应的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    ...</span><br><span class="line">&#123;</span><br><span class="line">test: /\.scss$/,</span><br><span class="line">use: [&#123;</span><br><span class="line">loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;css-loader&quot;, options: &#123; importLoaders: 1 &#125;// translates CSS into CommonJS</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;postcss-loader&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">   ...</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure></p><hr><p>下面的几点可都是官网文档没写的，只能自己踩一踩的坑……</p><hr><ol start="4"><li>运行<code>npx webpack</code>,<em>连续报错</em>，不过是缺必备的module的错误,也就是缺postcss.config.js里面的<code>postcss-import postcss-cssnext cssnano sugarss</code> 。<br>没办法，先<code>npm i -D 上面的四个模块名字</code>，依然报错，这次是语法错误<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/21058876.jpg" alt="语法错误"><br>(⊙v⊙)嗯？？？它说我不必要的大括号？？？我这标准的scss语法啊，又不是sass的语法(它省略了大括号和分号)，先Google一波这个错误。<br>终于在在postcss的<a href="https://github.com/postcss/postcss/issues/1062" target="_blank" rel="noopener">issue</a>里面发现了蛛丝马迹,问题果然出在那个令我疑惑的<code>postcss.config.js</code>里面<h3 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a>错误原因分析</h3></li><li>错误的使用了<a href="https://github.com/postcss/sugarss" target="_blank" rel="noopener">sugarss</a>的解析器(这货和sass类似，没有大括号，所以它说我大括号错了，它的特点是Indent-based CSS syntax for PostCSS.SugarSS MIME-type is text/x-sugarss with .sss file extension.)，而我写的是scss语法。</li><li><code>postcss-loader</code>哪来的勇气确定大家都是用的<code>.sss</code>后缀的sugarss语法呢，还敢直接在文档的醒目位置推荐<code>稀烂的postcss.config.js</code>，O__O “…</li><li>那么多的预编译的css语法，果然需要webpack打包工具啊，找到合适的loader去解析啊。</li></ol><p>注释掉<code>parser: &#39;sugarss&#39;,</code>这句代码，可以使用默认的解析器去解析了，正常运行了。<br>不过查看代码，发现好像转换后的css有点小<strong>丑</strong><br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/6839932.jpg" alt="不好看"></p><h3 id="autoprefixer冗余"><a href="#autoprefixer冗余" class="headerlink" title="autoprefixer冗余"></a>autoprefixer冗余</h3><p>仔细观察命令行，发现有线索，一个警告<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/77557219.jpg" alt="警告"><br>警告信息提示我说：postcss-cssnext发现有个冗余的<code>autoprefixer</code>插件在我的postcss插件里面，这个可能有不良影响，我应该移除它，因为它已经包括在了postcss-cssnext里面。</p><p>webpack的警告说的很明白，postcss-cssnext是无辜的，而且我确定按照官网代码走的，没有安装<code>autoprefixer</code>插件，错误必然在剩下的两个插件里面了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//修改后的postcss.config.js只剩下这些了</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;postcss-import&apos;: &#123;&#125;, //1.它错了？</span><br><span class="line">    &apos;postcss-cssnext&apos;: &#123;&#125;, //webpack告诉我它是清白的</span><br><span class="line">    &apos;cssnano&apos;: &#123;&#125; //2.它错了？</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我选择了排除法：</p><ol><li>先注释<code>&#39;postcss-import&#39;: {},</code>，发现无法转换后的css代码不对，说明它是无辜的。</li><li>那么问题必然是最后一个插件，注释掉<code>&#39;cssnano&#39;: {}</code>，终于完美了，而且代码很优美。<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-12/85971803.jpg" alt="消除警告"></li></ol><p>本着打破砂锅问到底的精神，我搜了一下<code>cssnano</code>,在其<a href="http://cssnano.co/optimisations/autoprefixer/" target="_blank" rel="noopener">官网</a>看到了真实的错误原因，webpack很明智啊，诚不欺我，果然冗余插件了。<br><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/83651219.jpg" alt="警告的原因"></p><p>cssnano里面有<code>autoprefixer</code>导致了冗余。</p><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p>webpack 把所有的资源都当成了一个模块, CSS、JS 文件 都是资源, 都可以打包到一个 bundle.js 文件中.<br>但是有时候需要把样式 单独的打包成一个文件需要抽离出css文件到单独的<code>css/</code>下。</p><p>使用<a href="https://github.com/webpack-contrib/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin插件</a>可以做到。</p><ol><li>安装脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install extract-text-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>配置webpack.config.js，官方推荐的配置如下，但是需要结合自己的项目修改一下……</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>); <span class="comment">//插件的套路。都要require进来</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">"style-loader"</span>, <span class="comment">//失败了就用它解析</span></span><br><span class="line">          use: <span class="string">"css-loader"</span> <span class="comment">//是css文件，就用这个处理</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"styles.css"</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h3><p>我如果使用的是scss，就很尴尬了</p><p>最开始由一个错误引起</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/63857480.jpg" alt="window未定义"></p><p>Google一下，<a href="https://github.com/webpack-contrib/extract-text-webpack-plugin/issues/503" target="_blank" rel="noopener">解决掉error</a>，fallbak里面使用了style-loader，use里面不应该使用了，那么问题又来了</p><ol><li>问题一：无法使用style-loader把我的main.scss转化后的css代码插入到style标签里面。</li></ol><p>详见代码注释部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.scss$/,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: &apos;style-loader&apos;,</span><br><span class="line">          //如果在use里面写上style-loader，就报错window未被定义，可是不写的话，我的bundle.js里面就无法把css放到style标签里面，只能手动把分离的css加到index.html，很无语。</span><br><span class="line">          use: [&#123;</span><br><span class="line">              loader: &quot;css-loader&quot;, options: &#123; importLoaders: 1 &#125;// translates CSS into CommonJS</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              loader: &quot;postcss-loader&quot;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">              loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>问题2：可以提取出单独的css文件，但是没想到如何放到单独的<code>css/</code>下，很尴尬，代码未提交，还在摸索中。</li></ol><p>问题大约知道应该出现在下面这个函数里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">     filename:  <span class="function">(<span class="params">getPath</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getPath(<span class="string">'../main.css'</span>).replace(<span class="string">'../js'</span>, <span class="string">'../css'</span>); <span class="comment">// 本意是生成在dist/css/main.css,结果只是在dist/main.css目录下，没有css/</span></span><br><span class="line">     &#125;,</span><br><span class="line">     allChunks: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所有的代码都在我的<a href="https://github.com/codevvvv9/webpack-demo-1" target="_blank" rel="noopener">demo</a>里面。</p><h2 id="蛋疼的无力吐槽"><a href="#蛋疼的无力吐槽" class="headerlink" title="蛋疼的无力吐槽"></a>蛋疼的无力吐槽</h2><p>算……是……搞定了webpack的基本使用了……吧，最简单的符合我目前技术栈的各种loader,plugin都会安装了。<br>当然，还有无数的webpack的loader、plugin在前方等着我去探索……各种稀奇古怪的配置文件……痛并快乐着☺</p><p>五花八门的配置文件挺让我糟心的……幸亏有了<strong>node爸爸</strong>帮我啊，webpack爸爸虽然也是比较严厉的，但是省了你用四个命令行窗口的啊，还是很感人的啊。</p><p>工具这个东西嘛</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/72186058.jpg" alt="怎么办"></p><ol><li>配置出错了怎么办，默念三句</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/45389737.jpg" alt="配置出错了怎么办"></p><ol start="2"><li>如果真的搞蹦了怎么办。熊得，送你一句名言</li></ol><blockquote><p>没有什么bug不是一遍webpack解决不了额，如果有的话，那就来三遍webpaack。总有一天让webpack叫你爸爸！！！</p></blockquote><h2 id="新的挑战者parcel"><a href="#新的挑战者parcel" class="headerlink" title="新的挑战者parcel"></a>新的挑战者parcel</h2><p>现在的吐槽大概是没有经历过以前更蛋疼的日子吧，幸好有了新的后起之秀—<a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a>，它的官网老厉害了，智能提示我用了中文，真是贴心。</p><p>回顾一下<code>webpack</code>的首页</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/60817621.jpg" alt="webpack"></p><p>在对比一下<code>parcel</code>的首页</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/90577657.jpg" alt="parcel"></p><p>两者的目的是一样的，不过parcel不需要插件，而且速度快。</p><h3 id="快速开始是真的快"><a href="#快速开始是真的快" class="headerlink" title="快速开始是真的快"></a>快速开始是真的快</h3><p><a href="https://parceljs.org/getting_started.html" target="_blank" rel="noopener">快速开始</a></p><p>没有配置，最好以html或者js为入口，直接<code>npm init -y , parcel index.html</code>，可以实现index.js。</p><p>它会自动帮你打包到dist目录下的一个js文件里面，并复制index.html过去，而这一切只需要上面的一行代码。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/25647271.jpg" alt="自动"></p><ol><li>一开始我的项目的目录结构</li><li>执行<code>parcel index.html</code>的目录结构</li></ol><p>而我当时搞webpack的时候的快速开始至少需要安装webpack、webpack.config.js、修改配置内容、安装插件才能实现上述的功能。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/44326202.jpg" alt="快速开始"></p><h3 id="模块化和scss的解析很方便"><a href="#模块化和scss的解析很方便" class="headerlink" title="模块化和scss的解析很方便"></a>模块化和scss的解析很方便</h3><p>当我在<code>parcel-demo</code>目录下使用<code>parcel index.html</code>的时候，它自动发现我引入了<code>index.js。</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/28380182.jpg" alt="模块化"></p><ol><li>里面的内容是模块化的内容，它自动帮我转成了<code>dist/parcel-demo.js</code>，我在webpack的时候需要babel-loader</li><li>我用的是scss,它也会自动发现，并且竟然</li></ol><hr><p><strong>还帮我自动下载了node-sass</strong></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/61347334.jpg" alt="自动下载"></p><p>其他的特点都在官网去发掘吧～希望日后<code>parcel</code>快速崛起吧</p><hr><p>而现在我还是要用<code>webpack</code>的……</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-13/45605477.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3tha6q4v.bkt.clouddn.com/18-2-13/60817621.jpg&quot; alt=&quot;webpack&quot;&gt;&lt;/p&gt;
&lt;p&gt;当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。&lt;/p&gt;
&lt;h2 id=&quot;基本安装&quot;&gt;&lt;a href=&quot;#基本安装&quot; class=&quot;headerlink&quot; title=&quot;基本安装&quot;&gt;&lt;/a&gt;基本安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;局部安装,官方也是推荐安装到项目目录下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir webpack-demo&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd webpack-demo&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm init -y &lt;span class=&quot;comment&quot;&gt;//生成package.json,并且一路同意,如果没啥个性化的内容则省了你一路狂按enter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install --save-dev webpack &lt;span class=&quot;comment&quot;&gt;//安装到开发环境里面(devDependicies)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;webpack基本配置文件
    
    </summary>
    
      <category term="自动打包工具" scheme="https://codevvvv9.github.io/categories/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="https://codevvvv9.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>持久化存储与HTTP缓存</title>
    <link href="https://codevvvv9.github.io/2018/02/11/%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8EHTTP%E7%BC%93%E5%AD%98/"/>
    <id>https://codevvvv9.github.io/2018/02/11/持久化存储与HTTP缓存/</id>
    <published>2018-02-11T15:50:34.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要学习一下一些高级的HTTP知识，例如<code>Session</code> <code>LocalStorage Cache-Control Expires ETag</code></p><p>其实主要就是涉及到了<strong>持久化存储与缓存的技术</strong></p></blockquote><p>在此之前已经学习了<code>Cookie</code>的相关知识，其中<code>Cookie</code>有个缺点可以人为修改，有一定的安全隐患。</p><p>所以，针对这个缺点，诞生了<code>Session</code></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>一般来说<code>Session</code>是基于Cookie实现的，它利用一个<code>sessionId</code>把用户的敏感数据隐藏起来，除非暴力穷举才有可能获得敏感数据。</p><h3 id="sessionId"><a href="#sessionId" class="headerlink" title="sessionId"></a><code>sessionId</code></h3><p>我们使用<code>Cookie</code>的时候，一般是服务器给用户一个响应头，设置<code>Cookie</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">'sign_in_email=...;HTTPOnly'</span>)</span><br></pre></td></tr></table></figure><p>既然Session还是基于<code>Cookie</code>实现的，那么还是应该在<code>Set-Cookie</code>上搞事情。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预先在服务器端预留对象准备存储各种session</span></span><br><span class="line"><span class="keyword">let</span> sessions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> sessionId = <span class="built_in">Math</span>.random() * <span class="number">100000</span></span><br><span class="line">sessions[sessionId] = &#123;<span class="attr">sign_in_email</span>: email&#125;</span><br><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`sessionId=<span class="subst">$&#123;sessionId&#125;</span>;HTTPOnly`</span>)</span><br></pre></td></tr></table></figure><p>使用随机数来做<code>sessionId</code>,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的<code>sessions</code>对象里面。它就像一个密码簿一样，有效的信息与<code>sessionId</code>一一对应，这是服务器的事，保证了安全性。</p><p>当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个<code>sessionId</code>，服务器获得这个<code>sessionId</code>后，然后一转化就知道是正确的用户了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sessions = &#123;</span><br><span class="line">  sessionId: &#123;</span><br><span class="line">    sign_in_email: ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><p>在HTML里面<code>js文件</code>里面的变量或对象，每当网页刷新的时候，就会死掉，又重新生成，虽然还是那个<code>a</code>，但是刷新后已经是另一块内存了。既然它也没变，我们为什么不把它一直保留着呢，即使刷新了<code>a</code>还是那个<code>a</code>，也就是持久化存储的意义。以前使用<code>Cookie</code>做这个功能，不过<code>Cookie</code>每次发请求会把Cookie里面的所有东西都带着去服务器，加重内存的负担，而且请求响应时间长，所以<code>html5</code>给了一个新的API <code>localStorage</code></p><p>关于Cookie如何工作的，我发现<a href="https://segmentfault.com/u/ruoyiqing" target="_blank" rel="noopener">这篇文章</a>写得特别好</p><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a><code>LocalStorage</code></h3><p>它本质上还是个<code>hash</code>，不过是存在于浏览器端的，不同于<code>session</code>存在与服务器端的<code>hash</code>。一般存储的都是没有用的或者不敏感的信息。</p><p><code>localStorage</code>是window的全局属性，常用的有三个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 添加键、值</span></span><br><span class="line">localStorage.setItem(<span class="string">'a'</span>, <span class="string">'...'</span>)</span><br><span class="line"><span class="comment">//2. 获得键、值</span></span><br><span class="line">localStorage。getItem(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//3.清空localStorage</span></span><br><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure><p>注意，它存的值全是字符串，即使你写的像对象也没有卵用。</p><p>如果想存储字符串需要用到<code>JSON.stringify( )</code></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/12510112.jpg" alt="全是字符串"></p><h3 id="一个实际应用"><a href="#一个实际应用" class="headerlink" title="一个实际应用"></a>一个实际应用</h3><p>很简单的一个例子：网站进行更新了，用户登录进来了，想提示用户一下—我有新东西啦，这个提示并不应该在每次刷新的时候反复告诉用户，只是在第一次用户进来的时候告诉他即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> already = localStorage.getItem(<span class="string">'已经提示过了'</span>)</span><br><span class="line"> <span class="keyword">if</span> (!already) &#123;</span><br><span class="line">   alert(<span class="string">'我们的网站新进了一些货物，您看一下有没有您需要的啊O(∩_∩)O～'</span>)</span><br><span class="line">   localStorage.setItem(<span class="string">'已经提示过了'</span>, <span class="literal">true</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次访问的时候，<code>already</code>为null，所以进入<code>if</code>代码片段，提示用户一次，接着把<code>already</code>设为<code>true</code>，不会进入<code>if</code>，也就不再提示了。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/79629274.jpg" alt="实际应用"></p><h3 id="不基于Cookie的session"><a href="#不基于Cookie的session" class="headerlink" title="不基于Cookie的session"></a>不基于<code>Cookie</code>的<code>session</code></h3><p>学习了<code>localStorage</code>，就可以搞一些黑科技了，前面说了，<code>session</code>一般是基于<code>Cookie</code>的，那么有没有例外呢。</p><p>有的。利用查询参数和<code>localStorage</code>可是实现<code>session</code>Id`。</p><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><ol><li>Cookie的特点<ul><li>服务器通过 Set-Cookie 头给客户端一串字符串</li><li>客户端每次访问相同域名的网页时，必须带上这段字符串</li><li>客户端要在一段时间内保存这个Cookie</li><li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间。比如max-age和后面要讲的<code>Expires</code></li><li><a href="https://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key" target="_blank" rel="noopener">大小大概在 4kb 以内</a></li></ul></li><li>Session的特点<ul><li>将 SessionID（随机数）通过 Cookie 发给客户端</li><li>客户端访问服务器时，服务器读取 SessionID</li><li>服务器有一块内存（哈希表）保存了所有 session</li><li>通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email</li><li>这块内存（哈希表）就是服务器上的所有 session</li></ul></li><li>LocalStorage的特点<ul><li>LocalStorage 跟 HTTP 无关</li><li>也就是说发送任何请求都不会带上 LocalStorage 的值</li><li>只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）</li><li>每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）</li><li>常用场景：记录有没有提示过用户（没有用的信息，不能记录密码等敏感信息）</li><li>LocalStorage 永久有效，除非用户清理缓存</li></ul></li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/18117336.jpg" alt="清理缓存"></p><h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><p>会话存储主要特点与<code>localStorage</code>基本相同，最大的不同是<code>SessionStorage</code>在用户关闭页面（会话结束）后就失效。</p><h2 id="HTTP缓存技术三兄弟"><a href="#HTTP缓存技术三兄弟" class="headerlink" title="HTTP缓存技术三兄弟"></a>HTTP缓存技术三兄弟</h2><p>假如说我们要访问的的文件比较大，我们请求完之后，下载需要花很长时间，当我们刷新页面的时候，虽然文件没有任何更新，但是我们又从服务器端下载了一遍大文件，导致每次响应时间依然很长。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/60377714.jpg" alt="加载时间很长"></p><p>通过上图的实验可以看到<code>localhost</code>的请求响应很快，10ms；而<code>default.css</code>、<code>main.js</code>文件较大，响应时间是<code>localhost</code>的25倍，而<code>jq</code>文件使用了<code>cdn</code>加速，是从内存的缓存中获得的，几乎瞬间。如果每次都这样的话，用户体验肯定很差。</p><hr><p>那么我们能不能在第一次响应完毕之后，如果资源没有更新，就不去服务器端下载，而是去某个地方获得呢？</p><p>答案是肯定的，可以实现，通过缓存，正如上图的<code>jq</code>实现的方法一样。</p><p>这部分可以作为web性能优化的一个方法。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a></h3><p>通过<code>max-age</code>设置缓存的有效时间(持续时间)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/css/default.css'</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./css/default.css'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">   response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/css;charset=utf-8'</span>)</span><br><span class="line">   response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">   response.write(string)</span><br><span class="line">   response.end()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在响应头里面加上<code>Cache-Control</code>，表示在100000秒内不要再去向服务器要这个资源了，就从我的内存缓存里面获得。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/81124953.jpg" alt="缓存的技术"></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/20129031.jpg" alt="多次刷新后"></p><p>虽然使用了缓存技术，不过有一点疑惑的就是有时候从硬盘的缓存里面获得，这个速度提升并不大，但是仍然避免了向服务器再次发起请求获得资源的过程；有时候从内存的缓存里面获得，这个就特别快了。大概是因为内存的缓存特别快吧。</p><p>通常我们把<code>Cache-Control</code>的有效时间设的很长。</p><p>以经常逛得知乎为例。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/59253426.jpg" alt=""></p><p>如果一个文件长期不变，把它设为从缓存里面获得，知乎设置了32596169秒的有效时间，超过了1年=31536000秒的时间。</p><h3 id="首页尽量不用缓存技术"><a href="#首页尽量不用缓存技术" class="headerlink" title="首页尽量不用缓存技术"></a>首页尽量不用缓存技术</h3><p>我们刷一些论坛性质的或者新闻性质的网站，注重时效性，一般会把爆炸性的、高质量的内容放到首页去，如果我们看了一会，想刷新看看新的更新的内容，而你设了缓存，看到的还是10分钟之前的首页，那就太尴尬了☺……</p><p>所以首页尽量不用缓存技术，只对那些长期不变的文件、图片等使用缓存技术。</p><p>还是以知乎为例。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/1670868.jpg" alt="以知乎为例"></p><p>对于知乎的<code>Cache-Control</code>的写法我是比较懵逼的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">MDN的语法</a>上</p><blockquote><ol><li><code>public</code></li></ol><p>Indicates that the response may be cached by any cache.</p><ol start="2"><li><code>private</code></li></ol><p>Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.</p><ol start="3"><li><code>no-cache</code></li></ol><p>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</p><ol start="4"><li><code>no-store</code></li></ol><p>The cache should not store anything about the client request or server response.</p><ol start="5"><li><code>must-revalidate</code></li></ol><p>The cache must verify the status of the stale resources before using it and expired ones should not be used.</p></blockquote><p>MDN推荐关闭缓存的写法是<code>Cache-Control: no-cache, no-store, must-revalidate</code>。</p><p>那么如果有的资源确实被更新了，如何去更新缓存呢。</p><h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>通过服务器端代码<code>server.js</code>我们可以发现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/js/main.js'</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (path === <span class="string">'/css/default.css'</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要当<code>URL</code>符合要求的时候，会使用缓存技术，不去发起请求重新下载资源。</p><p>所以当文件确实被更新了之后，我们可以改变<code>URL</code>，那么就会去重新下载新的文件了。</p><p>既然我们的网页入口是<code>html</code>，可以在这里面动手脚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;script src=<span class="string">"./js/main.js?V2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当你更新代码之后，理论上只需要在URL上添加查询参数<code>？V2</code>即可。</p><hr><p>我们还是去知乎看看他们的例子。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68564030.jpg" alt="更新缓存"></p><p>可以看到知乎也是把<code>URL</code>改了，只不过比我那种高级，它在文件名字动了手脚，大概是用了什么框架或者处理工具吧，不过更新缓存的思路上是一样的。文件变了，知乎就把文件缓存的<code>URL</code>填点东西；没变的话，就缓存一年，在你的硬盘某处睡一年^_^。</p><h3 id="小结一下-1"><a href="#小结一下-1" class="headerlink" title="小结一下"></a>小结一下</h3><p>使用缓存就用<code>response.setHeader(&#39;Cache-Control&#39;, &#39;max-age=100000&#39;)</code>，当你想更新的时候就改变文件的<code>URL</code>。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/42636461.jpg" alt="缓存技术"></p><p>当然，缓存存多了，你的硬盘估计就爆了，浏览器会去权衡这些的，应该优先清楚哪些缓存，是浏览器的事。</p><p>俗话说得好啊，吃井不忘挖井人啊，要学会忆苦思甜啊，我们现在用的可爽的<code>Cache-Control</code>也不是凭空冒出来的，是有历史原因的，以前呢，是用<code>Expires</code>实现缓存的技术。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires" target="_blank" rel="noopener">Expires</a></h3><p><code>Expires</code>的英文是到期的意思，很明显是与缓存有关的技术，不过从其英文意思也能看出它是到某个时间点截止的意思，不是<code>Cache-Control</code>的有效时间。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/78046653.jpg" alt="MDN的语法"></p><p>从语法和示例可以看出它是基于格林威治时间的。</p><p>我们还要处理一下时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//Sat Feb 10 2018 11:18:54 GMT+0800 (CST)</span></span><br><span class="line">d.toGMTString() <span class="comment">//"Sat, 10 Feb 2018 03:18:54 GMT"</span></span><br></pre></td></tr></table></figure><p>能看出来，这个响应头的最大的弊端在于，<strong>时间戳是与你的本地时间关联的</strong></p><p>如果本地电脑的时间系统错乱了，而且这种毛病还真的时常发生，那你的缓存就毫无作用了。maybe这就是HTTP要升级这个响应头的原因吧O(∩_∩)O～</p><p>当<code>Cache-Control</code>和<code>Expires</code>共同存在的时候</p><blockquote><p>如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener"><code>Cache-Control</code></a>响应头，那么  <code>Expires</code> 头就会被忽略。</p></blockquote><p>关于缓存的技术，还有最后一个兄弟<code>ETag</code>，在搞定它之前，先来学习一下它的小跟班<code>MD5</code></p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a><a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5</a></h3><p><code>MD5</code>是一个摘要算法。经常用于比较两个文件是否完全一样，如果有一点不一样，误差会放大。例如我们经常重装系统的话，有良心的系统提供者会给你一个对应的<code>MD5</code>值，当你下载完毕后，查看你下载的系统的MD5值是否与官方提供给你的一样，确保是否会因为网络原因导致你下载的东西不完整。</p><p>在<code>Linux</code>系统里面使用<code>md5sum</code>指令进行MD5校验</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/74542817.jpg" alt="MD5校验"></p><p>第一个红框里面就是<code>1.txt</code>文件(内容设定为123456)的MD5值，第二个红框里面就是<code>1-copy</code>文件(内容被我改为了123460)的MD5值。</p><p>在<code>nodejs</code>里面如何使用呢，Google后发现有<code>npm</code>的<a href="https://www.npmjs.com/package/md5" target="_blank" rel="noopener">MD5</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install md5</span><br><span class="line">...</span><br><span class="line"><span class="comment">//在server.js引入</span></span><br><span class="line"><span class="keyword">var</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>);</span><br></pre></td></tr></table></figure><p>准备工作做完，可以搞<code>ETag</code>了。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">ETag</a></h3><blockquote><p>The <strong>ETag</strong> HTTP response header is an identifier for a specific version of a resource.It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (“mid-air collisions”).</p><p>If the resource at a given URL changes, a new <code>Etag</code> value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</p></blockquote><ul><li>这个响应头是特定资源版本的标识符。     </li><li>如果给定URL中的资源更改，则一定要生成新的Etag值。因此Etags类似于指纹，也可能被某些服务器用于跟踪。 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。</li></ul><p>可以看出<code>ETag</code>应该是一串值，此时上一节的<code>MD5</code>就派上用场了，我们使用MD5来比较前后两次请求文件的内容。</p><p>当某个URL来访问服务器的资源的时候，如果服务器设置了响应头<code>ETag:一串md5值</code>，那么</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/18997396.jpg" alt="设置响应头"></p><p>现在没有什么其他变化，如果第二次刷新的话，你会发现</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/82913073.jpg" alt="请求头变了"></p><p>请求头多了一个<code>If-None-Match:一串MD5值</code>。</p><p>比较上述两图，我的<code>main.js</code>没有改变过，发现<code>ETag:一串md5值</code>和<code>If-None-Match:一串MD5值</code>的一样，稍微一思考的话，就能明白，第二次刷新的时候如果我的<code>main.js</code>变了的话，那么</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/23771996.jpg" alt="MD5变了"></p><p>第二次向服务器发起请求，下载的<code>main.js</code>的<code>ETag</code>的MD5值必然不同了。</p><p>根据这个现象，然后结合MDN文档</p><blockquote><p>ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None%20-Match" target="_blank" rel="noopener"><code>If-None -Match</code></a> header字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a>未修改状态，告诉客户端缓存版本可用（新鲜）。</p></blockquote><p>可以推理出如下的代码了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/js/main.js'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./js/main.js'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/javascript;charset=utf-8'</span>)</span><br><span class="line">    <span class="keyword">let</span> fileMd5 = md5(string)</span><br><span class="line">    response.setHeader(<span class="string">'ETag'</span>, fileMd5)</span><br><span class="line">    <span class="keyword">if</span> (request.headers[<span class="string">'if-none-match'</span>] === fileMd5) &#123;</span><br><span class="line">      response.statusCode = <span class="number">304</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.write(string) </span><br><span class="line">    &#125;</span><br><span class="line">    response.end()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="304状态码的含义"><a href="#304状态码的含义" class="headerlink" title="304状态码的含义"></a>304状态码的含义</h3><blockquote><p> HTTP <strong>304</strong> 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="noopener">safe</a>），例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> 或在请求中附带了头部信息： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match" target="_blank" rel="noopener"><code>If-None-Match</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" target="_blank" rel="noopener"><code>If-Modified-Since</code></a>。</p></blockquote><p>304和缓存的区别：</p><ol><li>缓存不会发起请求了，直接从内存或者硬盘中获得</li><li>304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68663233.jpg" alt="304与缓存的区别"></p><h2 id="几个常见的考题"><a href="#几个常见的考题" class="headerlink" title="几个常见的考题"></a>几个常见的考题</h2><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><ol><li>Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的<code>cookie</code>。</li><li>而Session是存放在服务器端的内存中，其 Session ID 是通过 Cookie 发送给客户端的，这个Session ID每次都随请求发送给 Server。</li></ol><h3 id="Cookie-和-LocalStorage-的区别"><a href="#Cookie-和-LocalStorage-的区别" class="headerlink" title="Cookie 和 LocalStorage 的区别"></a>Cookie 和 LocalStorage 的区别</h3><ol><li><code>Set-Cookie</code>之后，用户的每次访问服务器，请求里面都会带着<code>Cookie</code>到服务器上，与HTTP有关，而<code>LocalStorage</code>不用发到服务器端，它是存储在浏览器里面的，与HTTP无关，是浏览器的属性，<code>window.localStorage</code>。</li><li><code>Cookie</code>一般比较小，大约4k左右，而<code>LocalStorage</code>大约能用5M</li><li><code>Cookie</code>默认会在用户关闭页面后失效，不过后端可以设置保存时间，而<code>LocalStorage</code>永久有效，除非用户手动清理。</li></ol><h3 id="LocalStorage-和-SessionStorage-的区别"><a href="#LocalStorage-和-SessionStorage-的区别" class="headerlink" title="LocalStorage 和 SessionStorage 的区别"></a>LocalStorage 和 SessionStorage 的区别</h3><ol><li><code>LocalStorage</code>永久有效，除非用户手动清理<code>localStorage.clear()</code>。不会自动过期</li><li>但是SessionStorage在会话结束后就会失效，也就是用户关闭了页面，就失效了。会自动过期</li></ol><h3 id="Cookie-如何设置过期时间？如何删除-Cookie？"><a href="#Cookie-如何设置过期时间？如何删除-Cookie？" class="headerlink" title="Cookie 如何设置过期时间？如何删除 Cookie？"></a>Cookie 如何设置过期时间？如何删除 Cookie？</h3><ol><li><p>设置过期时间：<code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</code></p><p>data`是格林威治时间，响应头里里面应该这么写代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Expires'</span>, <span class="string">'Fri, 09 Feb 2018 11:29:48 GMT'</span>)</span><br></pre></td></tr></table></figure><p>也就是说Cookie在格林威治时间的2018年2月9号的11点29分48秒失效。</p></li><li><p>设置cookie过期时间小于当前时间，那么就会删除该cookie。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.cookie = name + <span class="string">'=;  expires=Thu, 01 Jan 1970 00:00:01 GMT;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？"><a href="#Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？" class="headerlink" title="Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？"></a>Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？</h3><ol><li><code>Cache-Control: max-age=1000</code>的缓存 是直接不发请求的，1000秒内相同URL的用户请求资源的时候，不会再去发请求访问服务器了，直接从本地内存的缓存里面获取</li><li><code>ETag</code>的缓存是不管怎么样都要发起请求，第二次访问的是时候会多一个请求头<code>If-None-Match : md5值</code>，如果两次请求之间的MD5值相同就不会去下载新的文件，响应体是第一次下载的；如果MD5值变了，就要去下载新的文件。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要学习一下一些高级的HTTP知识，例如&lt;code&gt;Session&lt;/code&gt; &lt;code&gt;LocalStorage Cache-Control Expires ETag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实主要就是涉及到了&lt;strong&gt;持久化存储与缓存的技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此之前已经学习了&lt;code&gt;Cookie&lt;/code&gt;的相关知识，其中&lt;code&gt;Cookie&lt;/code&gt;有个缺点可以人为修改，有一定的安全隐患。&lt;/p&gt;
&lt;p&gt;所以，针对这个缺点，诞生了&lt;code&gt;Session&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h2&gt;&lt;p&gt;一般来说&lt;code&gt;Session&lt;/code&gt;是基于Cookie实现的，它利用一个&lt;code&gt;sessionId&lt;/code&gt;把用户的敏感数据隐藏起来，除非暴力穷举才有可能获得敏感数据。&lt;/p&gt;
&lt;h3 id=&quot;sessionId&quot;&gt;&lt;a href=&quot;#sessionId&quot; class=&quot;headerlink&quot; title=&quot;sessionId&quot;&gt;&lt;/a&gt;&lt;code&gt;sessionId&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;我们使用&lt;code&gt;Cookie&lt;/code&gt;的时候，一般是服务器给用户一个响应头，设置&lt;code&gt;Cookie&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;response.setHeader(&lt;span class=&quot;string&quot;&gt;&#39;Set-Cookie&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;sign_in_email=...;HTTPOnly&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然Session还是基于&lt;code&gt;Cookie&lt;/code&gt;实现的，那么还是应该在&lt;code&gt;Set-Cookie&lt;/code&gt;上搞事情。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP高级知识" scheme="https://codevvvv9.github.io/categories/HTTP%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="https://codevvvv9.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>一块小饼干的故事-Cookie-的故事-下篇</title>
    <link href="https://codevvvv9.github.io/2018/02/09/%E4%B8%80%E5%9D%97%E5%B0%8F%E9%A5%BC%E5%B9%B2%E7%9A%84%E6%95%85%E4%BA%8B-Cookie-%E7%9A%84%E6%95%85%E4%BA%8B-%E4%B8%8B%E7%AF%87/"/>
    <id>https://codevvvv9.github.io/2018/02/09/一块小饼干的故事-Cookie-的故事-下篇/</id>
    <published>2018-02-09T15:33:53.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇介绍了注册的基本流程，下篇简单的讲讲登录的流程以及Cookie的出现</p></blockquote><h2 id="实现登录的小功能"><a href="#实现登录的小功能" class="headerlink" title="实现登录的小功能"></a>实现登录的小功能</h2><p>当你在浏览器的输入框里输入<code>localhost:8080/sign_in</code>的时候，会发起<code>GET</code>请求，去访问<code>sign_in.html</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/sign_up'</span> &amp;&amp; method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./sign_up.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  response.statusCode = <span class="number">200</span></span><br><span class="line">  response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">  response.write(string)</span><br><span class="line">  response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS布局与上篇的布局基本一样，略去不表～</p><a id="more"></a><h3 id="比对用户的信息与数据库里面的信息是否匹配"><a href="#比对用户的信息与数据库里面的信息是否匹配" class="headerlink" title="比对用户的信息与数据库里面的信息是否匹配"></a>比对用户的信息与数据库里面的信息是否匹配</h3><p>依然是上篇的套路，获得用户formdata后，分析数据，和数据库里面的比对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = fs.readFileSync(<span class="string">'./db/users'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">users = <span class="built_in">JSON</span>.parse(users) <span class="comment">//[] JSON也支持数组</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">users = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (users[i].email === email &amp;&amp; users[i].password === password) &#123;</span><br><span class="line">  found = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (found) &#123;</span><br><span class="line">  response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`sign_in_email=<span class="subst">$&#123;email&#125;</span>;HTTPOnly`</span>)</span><br><span class="line">  response.statusCode = <span class="number">200</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response.statusCode = <span class="number">401</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的是引入了一个<code>header</code>，也就是今天的主角–<strong>Cookie</strong></p><p>其实这和平常上网的情形类似的，有时候我们访问一些购物网站，并没有登录，但是你在购物车里面添加东西了，当你逛了以后再回来的时候，发现购物车里面有你的记录，帮你做这个事的也是cookie。</p><blockquote><p>因为<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP协议</a>是无状态的，即<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>不知道用户上一次做了什么，这严重阻碍了<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">会话</a>)中的状态。</p></blockquote><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/21324547.jpg" alt="设置头"></p><p>可以看出，当你在sign_in发起<code>GET</code>请求并设置了<code>Set-Cookie</code>之后，其他的同源的页面，又都会带上<code>Cookie</code>，也就能保证同源的网页向服务器发起请求的时候，服务器能够明白，你己经是登录的用户了，与那些没有拿到cookie的页面区别开来。</p><h2 id="Cookie的入门"><a href="#Cookie的入门" class="headerlink" title="Cookie的入门"></a>Cookie的入门</h2><p>为什么要在cookie里面写上<code>HttpOnly</code>呢，因为这个可以防止有些牛人使用<code>JS</code>修改Cookie的内容。</p><ul><li>如果不写这个的话，可以使用<code>js</code>修改的</li></ul><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/39633071.jpg" alt="js修改cookie"></p><p>写了<code>HttpOnly</code>之后将无法修改</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/34957386.jpg" alt="无法修改"></p><h3 id="ga是啥"><a href="#ga是啥" class="headerlink" title="_ga是啥"></a>_ga是啥</h3><p>这个是Chrome的功能，用于分析cookie的</p><p>每一部分的作用详见<a href="https://stackoverflow.com/questions/16102436/what-are-the-values-in-ga-cookie" target="_blank" rel="noopener">这里</a></p><h3 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h3><p>通过上述的例子，可以总结几点重要的特点</p><ol><li>服务器通过 Set-Cookie 响应头设置 Cookie</li><li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li><li>服务器读取 Cookie 就知道登录用户的信息（email）</li></ol><p>当然了，还有几个问题需要解答一下。</p><ol><li>Cookie 存在哪<br>存在硬盘的一个文件里面</li><li>Cookie会被用户篡改吗？<br>可以，也就是说它并不安全的。</li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/61442859.jpg" alt="不安全"></p><ol start="3"><li>Cookie 有效期吗？</li></ol><p>默认有效期20分钟左右，不同浏览器策略不同<br>后端可以强制设置有效期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;</span><br></pre></td></tr></table></figure><p>具体语法看 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">Set-Cookie</a></p><h3 id="用户登录后，首页显示不同"><a href="#用户登录后，首页显示不同" class="headerlink" title="用户登录后，首页显示不同"></a>用户登录后，首页显示不同</h3><p>既然你成功登录，理应跳转到首页，并显示相应的界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'/sign_in'</span>, hash)</span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.location.href = <span class="string">'/'</span></span><br><span class="line">&#125;, </span><br><span class="line">(request) =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'邮箱与密码不匹配'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后首页的信息应该根据用户信息做出相应的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cookies = request.headers.cookie.split(<span class="string">'; '</span>) <span class="comment">//['email=..@..', 'a=1']</span></span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">cookies.forEach(<span class="function">(<span class="params">cookie</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> parts = cookie.split(<span class="string">'='</span>)</span><br><span class="line">  <span class="keyword">let</span> key = parts[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> value = parts[<span class="number">1</span>]</span><br><span class="line">  hash[key] = value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> email = hash.sign_in_email</span><br><span class="line"><span class="keyword">let</span> users = fs.readFileSync(<span class="string">'./db/users'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">users = <span class="built_in">JSON</span>.parse(users)</span><br><span class="line"><span class="keyword">let</span> foundUser</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].email === email) &#123;</span><br><span class="line">    foundUser = users[i]</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (foundUser) &#123;</span><br><span class="line">  string = string.replace(<span class="string">'email'</span>, foundUser.email)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  string = string.replace(<span class="string">'恭喜，email你已成功登录'</span>, <span class="string">'没有该用户'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑与上篇的基本一致，唯一的不同在于第一行代码</p><p><code>let cookies = request.headers.cookie.split(&#39;; &#39;) //[&#39;email=..@..&#39;, &#39;a=1&#39;]</code></p><p>为什么用<code>；</code>字符来分割呢，这是因为可以有多个cookie</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/85533637.jpg" alt="多个cookie"></p><h3 id="Cookie的两个作用"><a href="#Cookie的两个作用" class="headerlink" title="Cookie的两个作用"></a>Cookie的两个作用</h3><p>一般来说常见的作用有如下两个：</p><ol><li>识别用户的身份。当用户A去访问<code>localhost:8080</code>的时候，服务器会给A一个独一无二的<code>id=00A</code>(这就是cookie)，当用户A访问<code>localhost:8080</code>的其他网页的时候，都会带着那个独一无二的id。当B用户来访问<code>localhost:8080</code>的时候，服务器发现他没有任何标识，也会给他一个独一无二的<code>id=00B</code>，所以借助cookie服务器端就能够分清楚谁是谁了。</li><li>记录你的浏览历史。最常见的需求就是你去逛购物网站，你添加到购物车里面的东西过几天一定会在，而不会凭空消失了。例如A用户去<code>taobao.com</code>去买点东西，添加了一个热水壶、一部小米手机到购物车里面，那么服务器端可以改写你上面的cookie使之具体化「id=00A; cart=A1,A2」，表示你购物车里面买了俩东西。你过几天想起来了，去购物车里面看，热水壶、小米手机还在里面。浏览器并不会删除你存到硬盘上的cookie。</li></ol><h3 id="一张图总结注册登录的过程"><a href="#一张图总结注册登录的过程" class="headerlink" title="一张图总结注册登录的过程"></a>一张图总结注册登录的过程</h3><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/88982109.jpg" alt="登录注册的过程"></p><p>接下来可以去搞一搞其他的，像什么<code>session</code> <code>LocalStorage</code>……(<em>@ο@</em>) 哇～</p><p>代码链接<a href="https://github.com/codevvvv9/AJAXDemo_nodeJsServer/blob/master/sign_in.html" target="_blank" rel="noopener">sign_in.html</a></p><p><a href="https://github.com/codevvvv9/AJAXDemo_nodeJsServer/blob/master/server.js" target="_blank" rel="noopener">server.js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上篇介绍了注册的基本流程，下篇简单的讲讲登录的流程以及Cookie的出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实现登录的小功能&quot;&gt;&lt;a href=&quot;#实现登录的小功能&quot; class=&quot;headerlink&quot; title=&quot;实现登录的小功能&quot;&gt;&lt;/a&gt;实现登录的小功能&lt;/h2&gt;&lt;p&gt;当你在浏览器的输入框里输入&lt;code&gt;localhost:8080/sign_in&lt;/code&gt;的时候，会发起&lt;code&gt;GET&lt;/code&gt;请求，去访问&lt;code&gt;sign_in.html&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (path === &lt;span class=&quot;string&quot;&gt;&#39;/sign_up&#39;&lt;/span&gt; &amp;amp;&amp;amp; method === &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; string = fs.readFileSync(&lt;span class=&quot;string&quot;&gt;&#39;./sign_up.html&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.statusCode = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.setHeader(&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=utf-8&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.write(string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.end()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CSS布局与上篇的布局基本一样，略去不表～&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP高级知识" scheme="https://codevvvv9.github.io/categories/HTTP%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="https://codevvvv9.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>一块小饼干-Cookie-的故事-上篇</title>
    <link href="https://codevvvv9.github.io/2018/02/09/%E4%B8%80%E5%9D%97%E5%B0%8F%E9%A5%BC%E5%B9%B2-Cookie-%E7%9A%84%E6%95%85%E4%BA%8B-%E4%B8%8A%E7%AF%87/"/>
    <id>https://codevvvv9.github.io/2018/02/09/一块小饼干-Cookie-的故事-上篇/</id>
    <published>2018-02-09T15:28:24.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>cookie 如果非要用汉语理解的话应该是 一段小型文本文件，由网景的创始人之一的<a href="https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9" target="_blank" rel="noopener">卢 蒙特利</a>在93年发明。</p><p>上篇是熟悉一下注册的大致流程，下篇熟悉登录流程以及真正的Cookie</p></blockquote><h2 id="实现基本的注册功能"><a href="#实现基本的注册功能" class="headerlink" title="实现基本的注册功能"></a>实现基本的注册功能</h2><p>我们打开网站，浏览网站，最常见的两个操作就是注册以及登录，所以有必要探索一下这两个功能如何实现的。</p><p>本地模拟，当输入<code>localhost:8080/sign_up</code>的时候，浏览器发起<code>get</code>请求，服务器给你响应<code>sign_up.html</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端代码</span></span><br><span class="line"><span class="keyword">if</span> (path === <span class="string">'/sign_up'</span> &amp;&amp; method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./sign_up.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">    response.statusCode = <span class="number">200</span></span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="CSS布局的几个小坑"><a href="#CSS布局的几个小坑" class="headerlink" title="CSS布局的几个小坑"></a>CSS布局的几个小坑</h3><p>在写<code>sign_up.html</code>的时候，注意几点css知识：</p><ol><li>如果想让你的登录页面的body占满整个屏幕，随着窗口的大小变化而变化的话，可以写</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">html</span>&#123;<span class="attribute">height</span>: <span class="number">100%</span>&#125;</span><br><span class="line">//或者</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">min-height</span>: <span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">html</span>&#123;<span class="attribute">height</span>: <span class="number">100%</span>&#125;</span><br><span class="line">//不能这么写</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">html</span>&#123;<span class="attribute">min-height</span>: <span class="number">100%</span>&#125;</span><br></pre></td></tr></table></figure><p>当然了，实际上这么写就可以了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">min-height</span>: <span class="number">100vh</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>label</code>标签是<code>display: inline</code>，不能设置宽度，<strong>行内元素则会根据行内内容自适应宽度</strong>，所以行内元素设置width是没有效果的。改成<code>inline-block就可以了</code></li></ol><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/78722664.jpg" alt="很丑的界面的"></p><h3 id="获得用户的数据"><a href="#获得用户的数据" class="headerlink" title="获得用户的数据"></a>获得用户的数据</h3><p>既然是注册的需求，那么我们首要关注的点就是–用户的注册信息我们如何获得呢</p><p>选择合理的数据结构存储数据是很重要的。</p><ol><li>每个<code>input</code>的<code>name</code>可以使用数组存储</li><li><code>input</code>的<code>value</code>应该使用<code>hash</code>,也就是对象来存储。</li><li>上述的套路会一直用下去，<strong><code>hash+[]</code></strong>的组合。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用jq来写</span></span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> $form = $(<span class="string">'#signUpForm'</span>)</span><br><span class="line">$form.on(<span class="string">'submit'</span>, (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault() <span class="comment">//不用form表单的默认提交，而是使用我们的的ajax提交</span></span><br><span class="line">  <span class="keyword">let</span> need = [<span class="string">'email'</span>, <span class="string">'password'</span>, <span class="string">'password_confirmation'</span>]</span><br><span class="line">  need.forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = $form.find(<span class="string">`[name=<span class="subst">$&#123;name&#125;</span>]`</span>).val()</span><br><span class="line">  hash[name] = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最终<code>hash</code>里面存储的就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'email'</span>: <span class="string">'...'</span>,</span><br><span class="line">  <span class="string">'password'</span>: <span class="string">'...'</span>,</span><br><span class="line">  <span class="string">'password_confirmation'</span>: <span class="string">'...'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止我们把用户的数据封装到了一个对象里面了。</p><p>不过在把hash用ajax发出去之前要先进行一些必要的非空验证</p><h3 id="非空验证"><a href="#非空验证" class="headerlink" title="非空验证"></a>非空验证</h3><p>主要是检测邮箱是否为空、密码是否为空、两次输入的密码是否一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发起请求之前验证是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hash[<span class="string">'email'</span>] === <span class="string">''</span>) &#123;</span><br><span class="line">  $form.find(<span class="string">'[name="email"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'请您输入邮箱'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//精髓啊，不然没用了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hash[<span class="string">'password'</span>] === <span class="string">''</span>) &#123;</span><br><span class="line">  $form.find(<span class="string">'[name="password"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'请您输入密码'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//精髓啊，不然没用了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hash[<span class="string">'password_confirmation'</span>] === <span class="string">''</span>) &#123;</span><br><span class="line">    $form.find(<span class="string">'[name="password_confirmation"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'请您再次输入确认密码'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//精髓啊，不然没用了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hash[<span class="string">'password'</span>] !== hash[<span class="string">'password_confirmation'</span>]) &#123;</span><br><span class="line">  $form.find(<span class="string">'[name="password_confirmation"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'两次输入密码不匹配'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//精髓啊，不然没用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果忘记写return的话，即使你为空了还是会直接越过这一步检测，去发起ajax请求的，所以一定不要忘了写上return false.</li><li>如果仅仅这么写的话会有一个bug。当出现错误提示后，你把信息填对了，错误信息依然显示，这显然是不合理的。应该填入信息后，错误信息就消失的。</li></ul><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/78635036.jpg" alt="bug"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$form.find(<span class="string">'.errors'</span>).each(<span class="function">(<span class="params">index, span</span>) =&gt;</span> &#123;</span><br><span class="line">$(span).text(<span class="string">''</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用上述的jq代码来解决这个bug即可。</p><p>非空验证完了之后，意味着浏览器收集用户数据的工作完成了，可以把hash发到服务器端了，接下来就是ajax请求了。</p><h3 id="使用ajax提交数据"><a href="#使用ajax提交数据" class="headerlink" title="使用ajax提交数据"></a>使用ajax提交数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'/sign_up'</span>, hash)</span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//成功了就打印这个  </span></span><br><span class="line">  <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;,</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">  <span class="comment">//错误了打印这个</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="服务器端解析formData"><a href="#服务器端解析formData" class="headerlink" title="服务器端解析formData"></a>服务器端解析formData</h3><p>因为formData是一段一段上传的(具体原因略复杂，可以取极限法，如果formdata很多，不可能一下子上传过来)，自己不会写，就去搜索代码片段解析formdata</p><p><code>google: node get post data</code></p><p>把获得的代码封装成了一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readBody</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> body = []</span><br><span class="line">      request.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">        body.push(chunk)</span><br><span class="line">      &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        body = Buffer.concat(body).toString();</span><br><span class="line">          resolve(body)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用上述代码片段呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (path === <span class="string">'/sign_up'</span> &amp;&amp; method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    readBody(request).then(<span class="function">(<span class="params">body</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> strings = body.split(<span class="string">'&amp;'</span>) <span class="comment">//['email=1', 'password=2', 'password_confirmmation=3']</span></span><br><span class="line">      <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">      strings.forEach(<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//想得到类似这种的 string == 'email=1'</span></span><br><span class="line">        <span class="keyword">let</span> parts = string.split(<span class="string">'='</span>) <span class="comment">//再用=分割,得到['email', '1']</span></span><br><span class="line">        <span class="keyword">let</span> key = parts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> value = parts[<span class="number">1</span>]</span><br><span class="line">        hash[key] = <span class="built_in">decodeURIComponent</span>(value)<span class="comment">//hash['email'] = '1'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">let</span> &#123;email, password, password_confirmation&#125; = hash <span class="comment">//ES6的解构赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>当服务器端接收到了所有的formdata数据后，其实是一串形如<code>email=1&amp;password=2&amp;password_confirmation=3</code></p><p>的字符串，所以我们考虑使用<code>&amp;</code>字符分割成数组。</p><ul><li>得到一个形如<code>[&#39;email=1&#39;, &#39;password=2&#39;, &#39;confirmation=3&#39;]</code>的数组之后，我们为了得到<code>string = &#39;email=1&#39;</code>这种形式的，开始遍历数组，把数组的每个元素按照<code>=</code>分割，得到 <code>[email, 1]</code></li><li>用第二小节提供的<code>hash+[]</code>方法，处理成hash</li></ul><h2 id="服务器端简单的校验"><a href="#服务器端简单的校验" class="headerlink" title="服务器端简单的校验"></a>服务器端简单的校验</h2><p>既然服务器端已经获得了<code>formdata</code>了，那么应该进行一下简单的校验，比如邮箱的格式，没有问题了就把数据存到数据库里面。(目前校验水平很入门，没有涉及到完备的注册校验功能)</p><h3 id="校验前的准备工作"><a href="#校验前的准备工作" class="headerlink" title="校验前的准备工作"></a>校验前的准备工作</h3><p>上一节我们把formdata完美的封装到了hash里面，为了校验我们要把hash再拆开一个一个的看</p><p>或许这么做是最直接的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = hash[<span class="string">'emai'</span>]</span><br><span class="line"><span class="keyword">let</span> password = hash[<span class="string">'password'</span>]</span><br><span class="line"><span class="keyword">let</span> password_confirmation = hash[<span class="string">'password_confirmation'</span>]</span><br></pre></td></tr></table></figure><p>不过ES6提供了一种解构赋值的语法糖，很甜很贴心……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;email, password, password_confirmation&#125; = hash</span><br></pre></td></tr></table></figure><h3 id="由-编码引发的bug"><a href="#由-编码引发的bug" class="headerlink" title="由@编码引发的bug"></a>由@编码引发的bug</h3><p>好了，我们这一步就先看看邮箱格式是否正确。</p><p>我是菜鸟级校验邮箱，看到了邮箱的独特标志---<code>@</code>，最起码有这个标志才叫邮箱吧，也就是说没有这个标志，我就可以认为邮箱格式不对啊，翻译成代码就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email.indexOf(<span class="string">'@'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  response.statusCode = <span class="number">400</span></span><br><span class="line">  response.write(<span class="string">'email is bad'</span>) <span class="comment">//单引号只是为了标记这是一个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好，目前来说，事情的发展都很正常，直到一个bug的到来。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/63886564.jpg" alt="正常的也报错了"></p><p>一个合法的邮箱，却进入了非法邮箱处理的代码片段里面……</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/3076171.jpg" alt="很疑惑"></p><p>毫无疑问，邮箱是合法的，代码也是合理的，那么出问题的必然是我，某个地方的理解有问题。</p><ul><li>找bug,把可能出错的代码片段分成几个区间，打log.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(email.indexOf(<span class="string">'@'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(email)</span><br></pre></td></tr></table></figure><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/74625962.jpg" alt="真的是-1"></p><p>没错，<code>email</code>这个字符串的<code>@</code>索引真的是-1，可是我的邮箱写的明明有<code>@</code>啊。</p><p>为啥呢，接着又打印出了<code>email</code>的内容，终于真相大白了，<code>email</code>字符串里面真的没有<code>@</code>，</p><p>却发现了一串你没想到的<code>%40</code>，(⊙v⊙)嗯，没错了，这就是我认为的那个<code>@</code>的另一个形态。</p><ul><li>我在浏览器看到的只是浏览器想让我看到的东西而已，既然已经被浏览器处理了，那到了服务器端自然无法处理。</li><li>那这个<code>%40</code>哪来的呢</li></ul><p>Google走起，在<a href="https://www.w3schools.com/tags/ref_urlencode.asp" target="_blank" rel="noopener">w3schools的HTML URL Encoding Reference</a>找到了解释(不是国内的w3school……)</p><blockquote><p>URL encoding converts characters into a format that can be transmitted over the Internet.</p></blockquote><p>URL编码把字符转化成了一种可以在互联网上传播的格式，也就是说，我在网页上看到的字符是被URL编码处理的结果。</p><ul><li>那接下来就去搞定什么是URL编码</li></ul><p>搞定这个之前，文档先要让你明白啥是<code>URL</code></p><blockquote><p>Web browsers request pages from web servers by using a URL.</p><p>The URL is the address of a web page, like: <strong><a href="https://www.w3schools.com" target="_blank" rel="noopener">https://www.w3schools.com</a>.</strong></p></blockquote><p>Web浏览器通过使用URL从Web服务器请求页面。 该网址是网页的地址，例如：https：//<a href="http://www.w3schools.com。" target="_blank" rel="noopener">www.w3schools.com。</a></p><hr><p>复习一下URL的组成6部分：</p><p><a href="https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5</a> 通过这个你就可以访问到一个 “唯一的” 网址</p><table><thead><tr><th>名字</th><th>作用</th></tr></thead><tbody><tr><td>https:</td><td>协议</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>域名</td></tr><tr><td>/s</td><td>路径</td></tr><tr><td>wd=hello&amp;rsv_spt=1</td><td>查询参数</td></tr><tr><td>#5</td><td>锚点</td></tr><tr><td>端口</td><td>默认80</td></tr></tbody></table><hr><p>复习完了<code>URL</code>，继续搞<code>URL编码</code></p><blockquote><p>URLs can only be sent over the Internet using the <a href="https://www.w3schools.com/charsets/ref_html_ascii.asp" target="_blank" rel="noopener">ASCII character-set</a>.</p><p>Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format.</p><p>URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits.</p><p>URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.</p></blockquote><ul><li>URL只能用ASCII编码在互联网之间发送。</li><li>既然URL通常包括ASCII字符编码集之外的字符(很明显嘛，ASCII码表太少)，所以URL必须转化成有效的ASCII格式。</li><li><strong>这是重点</strong>，URL编码使用<code>%</code>后面紧跟着两个16进制数字的编码格式来代替不安全的ASCII码表</li><li>URL不能包括空格。所以URL编码通常使用+号或者<code>20%</code>来代替空格。</li></ul><p>继续往下翻，找到了<code>%40</code>。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/97404637.jpg" alt="@符号的解释"></p><p>所以要把<code>value</code>的值解码回去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash[key] = <span class="built_in">decodeURIComponent</span>(value)</span><br></pre></td></tr></table></figure><p><code>decodeURIComponent()</code> 方法用于解码由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="noopener"><code>encodeURIComponent</code></a> 方法或者其它类似方法编码的部分统一资源标识符（URI）。毕竟<code>URL</code>属于<code>URI</code>。</p><h3 id="错误信息的提示方法"><a href="#错误信息的提示方法" class="headerlink" title="错误信息的提示方法"></a>错误信息的提示方法</h3><p>如果有了错，需要提示用户错了，后端写的代码，用户不一定看的懂，需要前端润色一下使用户看懂，或者前端和后端沟通一下，maybe后端脾气不好，前端也是暴脾气，所以应该选择一个前后端都要用的东西做桥梁，很明显<code>JSON</code>是完美的候选人。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email.indexOf(<span class="string">'@'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  response.statusCode = <span class="number">400</span></span><br><span class="line">  response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>) <span class="comment">//直接告诉浏览器我是json</span></span><br><span class="line">  response.write(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "errors": &#123;</span></span><br><span class="line"><span class="string">      "email": "invalid"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就合理多了，后台只管写个json给前台看，其他不管了，前台翻译一下给用户看喽～</p><p>那么前台如何获得这个<code>json</code>呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'/sign_up'</span>, hash)</span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//成功了就打印这个  </span></span><br><span class="line">  <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;,</span><br><span class="line">(request, b, c) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(request)</span><br><span class="line">   <span class="built_in">console</span>.log(b)</span><br><span class="line">   <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>忘记了错误函数里面的参数是啥了，那就都打印出来看看。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/48577590.jpg" alt="如果没用JSON的话"></p><p>可以看到，如果没用JSON的话，request对象里面有一个后端写的responseText属性可以利用。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/53044190.jpg" alt=""></p><p>设置了<code>Content-Type:application/json;charset=utf-8</code>之后，可以利用多出来的<code>responseJSON</code>属性，获得json的内容啊。</p><p>最终失败函数里面写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(request) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;errors&#125; = request.responseJSON</span><br><span class="line">  <span class="keyword">if</span> (errors.email &amp;&amp; errors.email === <span class="string">'invalid'</span>) &#123;</span><br><span class="line">    $form.find(<span class="string">'[name="email"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'您输入的邮箱错啦'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="校验邮箱是否已经存在了"><a href="#校验邮箱是否已经存在了" class="headerlink" title="校验邮箱是否已经存在了"></a>校验邮箱是否已经存在了</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = fs.readFileSync(<span class="string">'./db/users'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  users = <span class="built_in">JSON</span>.parse(users) <span class="comment">//[] JSON也支持数组</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">  users = []</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inUse = <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> user = users[i]</span><br><span class="line">  <span class="keyword">if</span> (user.email === email) &#123;</span><br><span class="line">    inUse = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inUse) &#123;</span><br><span class="line">  response.statusCode = <span class="number">400</span></span><br><span class="line">  response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>)</span><br><span class="line">  response.write(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "errors": &#123;</span></span><br><span class="line"><span class="string">      "email": "inUse"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文并没有使用真正意义上的数据库，只是使用了简单的db文件做数据库，其实就是存的数组，也就是users其实就是数组<code>[]</code>。</p><ul><li>之所以使用了<code>try{}catch(){}</code>，是因为一旦除了错，可以将其初始化为空数组，后续代码可以继续执行，可能并不严谨，不过本文是侧重了解注册的思路的。</li></ul><p>同样的，如果邮箱已经存在了，就提示用户</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (errors.email &amp;&amp; errors.email === <span class="string">'inUse'</span>) &#123;</span><br><span class="line">$form.find(<span class="string">'[name="email"]'</span>).siblings(<span class="string">'.errors'</span>).text(<span class="string">'这个邮箱已被注册啦'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>后端校验必须很严格，因为可以通过<code>curl</code>越过前端的校验。</p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/55736025.jpg" alt="curl"></p><p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-8/7637310.jpg" alt="使用curl发起请求"></p><hr><h3 id="把信息写入数据库"><a href="#把信息写入数据库" class="headerlink" title="把信息写入数据库"></a>把信息写入数据库</h3><p>没有错误之后，就可以把信息写到数据库里面啦</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users.push(&#123;<span class="attr">email</span>: email, <span class="attr">password</span>: password&#125;)<span class="comment">//是个对象啊</span></span><br><span class="line"><span class="keyword">var</span> usersString = <span class="built_in">JSON</span>.stringify(users)</span><br><span class="line">fs.writeFileSync(<span class="string">'./db/users'</span>, usersString)</span><br><span class="line">response.statusCode = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>users实现是个对象，而对象是内存里面的东西，数据库里面应该存储的是字符串，所以用了<code>JSON.stringify(users)</code></p><p>好啦，上篇注册篇结束啦，下篇讲一讲如何登录以及<code>Cookie</code>登场</p><p>相关代码见<a href="https://github.com/codevvvv9/AJAXDemo_nodeJsServer/blob/master/sign_up.html" target="_blank" rel="noopener">sign_up.html</a></p><p><a href="https://github.com/codevvvv9/AJAXDemo_nodeJsServer/blob/master/server.js" target="_blank" rel="noopener">server.js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;cookie 如果非要用汉语理解的话应该是 一段小型文本文件，由网景的创始人之一的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;卢 蒙特利&lt;/a&gt;在93年发明。&lt;/p&gt;
&lt;p&gt;上篇是熟悉一下注册的大致流程，下篇熟悉登录流程以及真正的Cookie&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实现基本的注册功能&quot;&gt;&lt;a href=&quot;#实现基本的注册功能&quot; class=&quot;headerlink&quot; title=&quot;实现基本的注册功能&quot;&gt;&lt;/a&gt;实现基本的注册功能&lt;/h2&gt;&lt;p&gt;我们打开网站，浏览网站，最常见的两个操作就是注册以及登录，所以有必要探索一下这两个功能如何实现的。&lt;/p&gt;
&lt;p&gt;本地模拟，当输入&lt;code&gt;localhost:8080/sign_up&lt;/code&gt;的时候，浏览器发起&lt;code&gt;get&lt;/code&gt;请求，服务器给你响应&lt;code&gt;sign_up.html&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//服务器端代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (path === &lt;span class=&quot;string&quot;&gt;&#39;/sign_up&#39;&lt;/span&gt; &amp;amp;&amp;amp; method === &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; string = fs.readFileSync(&lt;span class=&quot;string&quot;&gt;&#39;./sign_up.html&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response.statusCode = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response.setHeader(&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=utf-8&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response.write(string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response.end()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="HTTP高级知识" scheme="https://codevvvv9.github.io/categories/HTTP%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTP" scheme="https://codevvvv9.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://codevvvv9.github.io/2018/02/03/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://codevvvv9.github.io/2018/02/03/科学上网/</id>
    <published>2018-02-03T13:02:02.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>如何科学上网是个很严肃的问题(⊙o⊙)哦</p><h3 id="以Linux为例"><a href="#以Linux为例" class="headerlink" title="以Linux为例"></a>以Linux为例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip; </span><br><span class="line">sudo pip install shadowsocks;</span><br></pre></td></tr></table></figure><ul><li>如果你遇到 _cleanup 不存在的提示，可能是遇到 bug 了，你要将 openssl.py 中的 _cleanup 全部改为 _reset 才行。</li></ul><p><img src="https://i.loli.net/2018/02/03/5a75b42695d7c.png" alt="如图的bug"></p><ul><li>如果你不会改，使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/_cleanup/_reset/g'</span> xxxxxxxxxxxxxxxxxxxxxx/openssl.py  </span><br><span class="line"><span class="comment">// 注意把 xxxxxxxxxxxxxxxxxxxxxx/openssl.py 改成图中的 openssl.py 文件的路径</span></span><br></pre></td></tr></table></figure><h3 id="创建sslocal-配置文件"><a href="#创建sslocal-配置文件" class="headerlink" title="创建sslocal 配置文件"></a>创建sslocal 配置文件</h3><p>创建 sslocal 配置文件（如果你不知道在哪创建就创建在 ~/.ssconf.json），配置文件的内容可使用我的服务器，你也可以自己买服务器（显然自己买服务器更靠谱）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"45.76.180.233", //自己买</span><br><span class="line">    "server_port":27148, //自己买</span><br><span class="line">    "local_address": "127.0.0.1",</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"A7#x8Jyzme)jkFfc", //自己买</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以使用了"><a href="#可以使用了" class="headerlink" title="可以使用了"></a>可以使用了</h3><ol><li>使用 <code>ss-local -c ~/.ssconf.json</code> 或 <code>sslocal -c ~/.ssconf.json</code> 开启代理，其中 ~/.ssconf.json 是配置文件的路径-</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;科学上网&quot;&gt;&lt;a href=&quot;#科学上网&quot; class=&quot;headerlink&quot; title=&quot;科学上网&quot;&gt;&lt;/a&gt;科学上网&lt;/h3&gt;&lt;p&gt;如何科学上网是个很严肃的问题(⊙o⊙)哦&lt;/p&gt;
&lt;h3 id=&quot;以Linux为例&quot;&gt;&lt;a href=&quot;#以Linux为例&quot;
      
    
    </summary>
    
      <category term="Linux入门" scheme="https://codevvvv9.github.io/categories/Linux%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Linux" scheme="https://codevvvv9.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AJAX的出现与跨域</title>
    <link href="https://codevvvv9.github.io/2018/01/31/AJAX%E7%9A%84%E5%87%BA%E7%8E%B0%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>https://codevvvv9.github.io/2018/01/31/AJAX的出现与跨域/</id>
    <published>2018-01-31T12:21:24.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>XMLHttpRequest</code> <code>JSON</code> <code>AJAX</code> <code>CORS</code>  四个名词来开会</p></blockquote><h3 id="如何发请求"><a href="#如何发请求" class="headerlink" title="如何发请求"></a>如何发请求</h3><p>在前端的世界里也逛荡了不少日子了，目前已经get到大约5种发起请求的方式，主流的、非主流的。</p><table><thead><tr><th style="text-align:left">何种方式</th><th>请求方法</th><th></th></tr></thead><tbody><tr><td style="text-align:left">最常见的<code>form</code>表单</td><td>默认<code>GET</code>，多用<code>POST</code>,只此两种</td><td>会刷新页面或者新开页面</td></tr><tr><td style="text-align:left"><code>a</code> 标签</td><td><code>GET</code>请求</td><td>也会刷新页面或者新开页面</td></tr><tr><td style="text-align:left"><code>img</code>的<code>src</code>属性</td><td><code>GET</code></td><td>只能以图片的形式展现</td></tr><tr><td style="text-align:left"><code>link</code>标签</td><td><code>GET</code></td><td>只能以<code>CSS</code>、<code>favicon</code>的形式展现</td></tr><tr><td style="text-align:left"><code>script</code>标签</td><td><code>GET</code></td><td>只能以脚本的形式运行</td></tr></tbody></table><p>可是</p><ul><li>我们可能想用<code>GET</code> <code>POST</code> <code>PUT</code> <code>DELETE</code> 方法</li><li>不想刷新整个页面，想用一种更易于理解的方式来响应</li></ul><a id="more"></a><h3 id="AJAX出现"><a href="#AJAX出现" class="headerlink" title="AJAX出现"></a>AJAX出现</h3><h4 id="浏览器和服务器交互模式-V1-0"><a href="#浏览器和服务器交互模式-V1-0" class="headerlink" title="浏览器和服务器交互模式 V1.0"></a>浏览器和服务器交互模式 V1.0</h4><p>在<code>AJAX</code>未出现之前，浏览器想从服务器获得资源，注意是获取资源，会经过如下一个过程</p><ul><li>浏览器发起请求-&gt;服务器接到请求响应给你HTML文档-&gt;浏览器收到资源，刷新页面，加载获得的的HTML。简略的过程</li></ul><p>我称这种交互方式是 V1.0，此时还是以获取资源为导向。后来随着时代的发展，人们日益增长的文化需求成为了社会的主要矛盾……有一天，小明看了一篇报道，他只是想在下面评论一下，发表对实事的<strong><em>亲切问候</em></strong>，问候完了，唉，你给我刷新页面干啥，我只是想评论一下啊。</p><p><img src="http://upload-images.jianshu.io/upload_images/5422064-ba8990e4137695cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="什么鬼"></p><p>大概那是网民们第一次对 <strong>良好的用户体验</strong> 提出了要求。后来的苹果爸爸，把大家惯坏了，天天嚷着 “你这产品用户体验太差了”……</p><p>彼时，微软还是对web做出了很大的贡献的。</p><h4 id="交互模式2-0"><a href="#交互模式2-0" class="headerlink" title="交互模式2.0"></a>交互模式2.0</h4><p>大约1999年，微软发布<code>IE 5.0</code>版本，它允许JavaScript脚本向服务器发起HTTP请求。不过很遗憾，当时也没有火起来，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。2005年，一个叫Jesse James Garrett的人提出了一个新术语—-<code>AJAX</code>，它是一系列技术的组合体，全称是 <code>Asynchronous JavaScript + XML</code>(异步的JS和XML)可以阻止页面整体刷新，只是动态响应用户的操作，快速显示到局部，用户就可以很愉快的继续上网了。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX" target="_blank" rel="noopener">AJAX</a></p><p>可以看出IE当时还是很猛的，随着IE 6.0 市场份额进一步扩大，IE已经把火狐整的半死不活，放眼整个浏览器市场，微软是当之无愧的王者，后来微软就把浏览器团队解散了……不得不说这是一波神操作，能与之媲美的操作大概只有<code>残血我能反杀</code> <code>塔下我能秀他</code>了。微软强行为后续各家浏览器的发展提供了优秀的工程师，尤其是08、09年出生的谷歌浏览器，再看如今的IE……</p><p>既然<code>AJAX</code>是一系列的技术的组合体，接下来认识一下其中的几位主角</p><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p><code>XMLHttpRequest</code>对象是用来在浏览器和服务器之间传输数据的。</p><p>古代的操作的是：</p><ol><li>浏览器构造<code>XMLHttpRequest</code>实例化对象</li><li>用这个对象发起请求</li><li>服务器响应一个<code>XML</code>格式的字符串，是字符串，是字符串，是字符串，也就是说响应的第四部分是字符串。</li><li>JS解析符合XML格式的字符串，更新局部页面。</li></ol><p>什么是<a href="https://developer.mozilla.org/zh-CN/docs/XML_%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">XML</a>，<strong>可扩展</strong>标记语言。</p><p>以上是最初的用法，用的是<code>XML</code>，前端代码片段如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest() <span class="comment">//实例化XMLHttpRequest对象</span></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求和响应都完毕了'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'说明请求成功了'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(request.responseText)</span><br><span class="line">      <span class="keyword">let</span> parser = <span class="keyword">new</span> DOMParser()</span><br><span class="line">      <span class="keyword">let</span> xmlDoc = parser.parseFromString(request.responseText, <span class="string">"text/xml"</span>) </span><br><span class="line">      <span class="comment">//用parser解析request.responseText</span></span><br><span class="line">      <span class="keyword">let</span> c = xmlDoc.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].textContent</span><br><span class="line">      <span class="built_in">console</span>.log(c)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>)  &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'说明请求失败了'</span>)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/xxx'</span>) <span class="comment">//配置request</span></span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure><p>服务器端的对应代码片段如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">response.statusCode = <span class="number">200</span></span><br><span class="line">response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/xml;charset=utf-8'</span>)</span><br><span class="line">response.write(<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;note&gt;</span></span><br><span class="line"><span class="string">  &lt;to&gt;木木&lt;/to&gt;</span></span><br><span class="line"><span class="string">  &lt;from&gt;少少&lt;/from&gt;</span></span><br><span class="line"><span class="string">  &lt;heading&gt;你好哇&lt;/heading&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;好久不见啊&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/note&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">response.end()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><p>本地模拟的话,一定要记得开俩不同的端口<br>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node server.js 8001</span><br><span class="line">node server.js 8002</span><br></pre></td></tr></table></figure><hr><h4 id="XMLHttpRequest实例的详解"><a href="#XMLHttpRequest实例的详解" class="headerlink" title="XMLHttpRequest实例的详解"></a>XMLHttpRequest实例的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">详解</a></h4><p>正如上面的前端代码片段写的一样，主要用到了<code>open()</code> <code>send()</code>方法， <code>onreadystatechange</code> <code>readyState</code> 属性。</p><ol><li>request.open(method, URL, async)方法。<ul><li>一般用三个参数，第一个参数是请求的方法，可以用<code>GET POST DELETE PUT</code>等等，URL是用访问的路径，async是是否使用同步，默认true,开启异步，不需要做修改即可，所以实际中只写前两个参数</li></ul></li></ol><ul><li>如果非要写false，开启同步，<a href="http://javascript.ruanyifeng.com/bom/ajax.html" target="_blank" rel="noopener">会对浏览器有阻塞效应</a>，而且如果值为false,则send()方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">不会返回任何东西</a>，直到接受到了服务器的返回数据</li></ul><ol><li>request.send()方法。<ul><li>发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回</li></ul></li><li><code>readyState</code>属性。<ul><li>描述请求的五个状态。<ul><li>0 === 常量 <code>UNSENT</code>(未打开)  open()方法未调用</li><li>1 ===  <code>OPENED</code>  (未发送)   只是open()方法调用了</li><li>2 === <code>HEADERS_RECEIVED (已获取响应头)</code> send()方法调用了，响应头和响应状态已经返回了</li><li>3 === <code>LOADING (正在下载响应体)</code>  响应体下载中，<code>responseText</code>已经获取了部分数据</li><li>4 === <code>DONE (请求完成)</code>  整个响应过程完毕了。 <strong><em>这个值是实际中用到的。</em></strong></li><li>只要不等于4，就表示请求还在进行中。</li></ul></li></ul></li><li><code>responseText</code>属性是此次响应的文本内容。</li><li><code>onreadystatechange</code>属性。<ul><li><code>readyState</code>属性的值发生改变，就会触发<code>readyStateChange</code>事件。</li><li>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的回调函数，对不同状态进行不同处理。尤其是当状态变为4的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。即前面的代码片段的处理方式。</li></ul></li><li>其他的方法、属性、事件详见<a href="http://javascript.ruanyifeng.com/bom/ajax.html#toc22" target="_blank" rel="noopener">阮一峰博客</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">MDN文档</a></li></ol><hr><p>习惯用<code>javaScript</code>的前端是不想和<code>XML</code>打交道的，应该用一种符合<code>js</code>风格的数据格式语言。</p><hr><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>后来一个美国程序员<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9" target="_blank" rel="noopener">道格拉斯·克罗克福特</a>发明了<code>JSON</code>，解决了上面的问题，这货还写了一本蝴蝶书<a href="https://book.douban.com/subject/3590768/" target="_blank" rel="noopener">JavaScript语言精粹</a>，还发明了一个<a href="http://zhenhua-lee.github.io/tools/linter.html" target="_blank" rel="noopener">JS校验器</a> —-JSLint。</p><blockquote><p><strong>JSON</strong>(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于<a href="http://www.crockford.com/javascript" target="_blank" rel="noopener">JavaScript Programming Language</a>, <a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf" target="_blank" rel="noopener">Standard ECMA-262 3rd Edition - December 1999</a>的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p></blockquote><p>以上是<a href="http://json.org/" target="_blank" rel="noopener">JSON官网</a>的简介，可以看出它是一门全新的语言，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">不是JavaScript的子集</a>。</p><ol><li><code>JSON</code>很简单，数据类型和JS有点不同的地方。</li></ol><table><thead><tr><th>JavaScript</th><th>JSON</th></tr></thead><tbody><tr><td>string</td><td>“string” 必须写双引号</td></tr><tr><td>number</td><td>number</td></tr><tr><td>object</td><td>{“object”: “name”} 必须双引号</td></tr><tr><td>undefined</td><td>没有</td></tr><tr><td>null</td><td>null</td></tr><tr><td>boolean</td><td>直接写true false</td></tr><tr><td>array</td><td>array</td></tr><tr><td>function</td><td>没有</td></tr><tr><td>variable</td></tr></tbody></table><ol><li>浏览器的全局对象<code>window</code>上有<code>JSON</code>对象，直接使用<code>window.JSON.parse(string)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = request.responseText</span><br><span class="line"><span class="keyword">let</span> json = <span class="built_in">window</span>.JSON.parse(string) <span class="comment">//string 要符合JSON的格式</span></span><br></pre></td></tr></table></figure><p>以上是JSON解析部分的代码。</p><p>此时服务器端代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">response.statusCode = <span class="number">200</span></span><br><span class="line">response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/json;charset=utf-8'</span>)</span><br><span class="line">response.write(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "note" : &#123;</span></span><br><span class="line"><span class="string">        "to" : "木木",</span></span><br><span class="line"><span class="string">        "from" : "少少",</span></span><br><span class="line"><span class="string">        "heading" : "你好哇",</span></span><br><span class="line"><span class="string">        "content" : "好久不见啊"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><ol><li>我们浏览器有同源政策，不是<strong>同协议 同域名 同端口</strong> 的网页无法相互访问。</li></ol><p>4.<code>AJAX</code>恰好是同源政策的拥趸</p><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ol><li>如果<code>AJAX</code>向非同源的地址发起请求，会报错。<ul><li>这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200，也就是说即使你看到了200的正确码，也没有用</li></ul></li><li>但是form表单无视同源政策，可以发起跨域请求。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>上述请求响应都没有问题<br>然而对于<code>AJAX</code>就不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">request.open(&apos;GET&apos;, &apos;http://www.baidu.com&apos;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5422064-060a110b41a721c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同源的保护"></p><ul><li>这是为什么呢,因为</li></ul><blockquote><p>原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容,所以浏览器认为这是安全的。<br>而 AJAX 是可以读取响应内容的，因此浏览器不能允许你这样做。如果你细心的话你会发现，其实请求已经发送出去了，你只是拿不到响应而已。<br>所以浏览器这个策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。</p><p>作者：方应杭<br>链接：<a href="https://www.zhihu.com/question/31592553/answer/190789780" target="_blank" rel="noopener">https://www.zhihu.com/question/31592553/answer/190789780</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><hr><p>那么如何让<code>AJAX</code>跨域发起请求呢。<br>答案是<code>CORS</code></p><ol><li><code>CORS</code>目前是W3C的标准，它允许浏览器跨域发起<code>XMLHttpRequest</code>请求，而且可以发起多种请求，不像<code>JSONP</code>只能发起<code>GET</code>请求，全称是”跨域/源资源共享”（Cross-origin resource sharing）。<ul><li>如果想要发起跨域请求 例如: <a href="http://wushao.com:8001" target="_blank" rel="noopener">http://wushao.com:8001</a> 要想访问 <a href="http://shaolin.com:8002,可以做如下处理" target="_blank" rel="noopener">http://shaolin.com:8002,可以做如下处理</a></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.open(&apos;GET&apos;, &apos;http://wushao.com:8001/xxx&apos;) //配置request</span><br></pre></td></tr></table></figure><ul><li>服务器端的代码需要做如下处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://shaolin.com:8002&apos;)</span><br></pre></td></tr></table></figure><p>一定要注意是谁去访问谁,8001去访问8002,那么8001的前端代码要告诉8002的后端代码,咱们是一家人,你和浏览器说说别让它禁我了。</p><h4 id="AJAX一些其他知识"><a href="#AJAX一些其他知识" class="headerlink" title="AJAX一些其他知识"></a>AJAX一些其他知识</h4><p>既然可以发请求,那么请求头的四部分如何获得的,响应的四部分又是如何获得呢</p><h5 id="获得请求和响应头"><a href="#获得请求和响应头" class="headerlink" title="获得请求和响应头"></a>获得请求和响应头</h5><ol><li>获得请求头的方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.open(&apos;GET&apos;, &apos;http://shaolin.com:8002/xxx&apos;)// 请求的第一部分</span><br><span class="line">request.setRequestHeader(&apos;Content-Type&apos;, &apos;x-www-form-urlencoded&apos;)//请求的第二部分</span><br><span class="line">request.setRequestHeader(&apos;wushao&apos;, &apos;18&apos;) //请求的第二部分</span><br><span class="line">request.send(&apos;我要设置请求的第四部分&apos;) //请求的第四部分</span><br><span class="line">request.send(&apos;name=wushao&amp;password=wushao&apos;) //请求的第四部分</span><br></pre></td></tr></table></figure><p>对应的典型的http请求四部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /xxx HTTP/1.1</span><br><span class="line">HOST: http://shaolin.com:8002</span><br><span class="line">Content-Type: x-www-form-urlencoded</span><br><span class="line">wushao: 18</span><br><span class="line"></span><br><span class="line">name=wushao&amp;password=wushao</span><br></pre></td></tr></table></figure><ol><li>获得响应的方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.status //响应的第一部分 200</span><br><span class="line">request.statusText //响应的第一部分 OK</span><br><span class="line">request.getAllResponseHeaders //响应的第二部分,这个方法好啊,全部的响应头</span><br><span class="line">request.getResponseHeader(&apos;Content-Type&apos;) //响应的第二部分具体的</span><br><span class="line">request.responseText //响应的第四部分</span><br></pre></td></tr></table></figure><p>对应的典型的http响应的四部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/json;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      &quot;note&quot; : &#123;</span><br><span class="line">        &quot;to&quot; : &quot;木木&quot;,</span><br><span class="line">        &quot;from&quot; : &quot;少少&quot;,</span><br><span class="line">        &quot;heading&quot; : &quot;你好哇&quot;,</span><br><span class="line">        &quot;content&quot; : &quot;好久不见啊&quot;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>回顾一下各个status对应的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200 === OK，请求成功</span><br><span class="line">301 === 被请求的资源已永久移动到新位置</span><br><span class="line">302 === 请求临时重定向，要求客户端执行临时重定向</span><br><span class="line">304 === 和上次请求一样，未改变</span><br><span class="line">403 === 服务器已经理解请求，但是拒绝访问</span><br><span class="line">404 === 请求失败，服务器上没有这个资源</span><br><span class="line">502 === 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br><span class="line">503 === Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。</span><br></pre></td></tr></table></figure><h5 id="练习一下JQuery封装AJAX"><a href="#练习一下JQuery封装AJAX" class="headerlink" title="练习一下JQuery封装AJAX"></a>练习一下JQuery封装AJAX</h5><ol><li>初级的jq封装<br>这是一个很简陋的效果，首先我还是把jq假设的很简单，就是一个window的属性，请轻喷……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function (nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  nodes.addClass = function () &#123;&#125;</span><br><span class="line">  nodes.html = function () &#123;&#125;</span><br><span class="line">  return nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.jQuery.ajax = function (options) &#123;</span><br><span class="line">  let url = options.url</span><br><span class="line">  let method = options.method</span><br><span class="line">  let headers = options.headers</span><br><span class="line">  let body = options.body</span><br><span class="line">  let successFn = options.successFn</span><br><span class="line">  let failFn = options.failFn</span><br><span class="line"></span><br><span class="line">  let request = new XMLHttpRequest() //实例化XMLHttpRequest对象</span><br><span class="line">  request.open(method, url) </span><br><span class="line">  for (let key in headers) &#123;</span><br><span class="line">    let value = headers[key]</span><br><span class="line">    request.setRequestHeader(key, value)</span><br><span class="line">  &#125;</span><br><span class="line">  request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">    if (request.readyState === 4) &#123;</span><br><span class="line">      if (request.status &gt;= 200 &amp;&amp; request.status &lt;= 300) &#123;</span><br><span class="line">        successFn.call(undefined, request.responseText)</span><br><span class="line">      &#125; else if (request.status &gt;= 400)  &#123;</span><br><span class="line">        failFn.call(undefined, request)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是jq对ajax的简陋的封装，ajax()方法接受一个对象作为参数，这个对象有很多键。这些键就是http请求的头的各个部分，以及一个成功函数和一个失败函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">  window.jQuery.ajax (&#123;</span><br><span class="line">    url: &apos;/xxx&apos;,</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">      &apos;wushao&apos;: &apos;18&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: &apos;a=1&amp;b=6&apos;, </span><br><span class="line">    successFn: (x) =&gt; &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;, </span><br><span class="line">    failFn: (x) =&gt; &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上就是简化后的使用方法，给button绑定事件的时候，函数体直接就是ajax()</p><ol><li>目前你会发现options这个对象傻傻的，因为总有一些用户不希望只传一个参数。所以我们稍微改造一下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let url</span><br><span class="line">  if (arguments.length === 1) &#123;</span><br><span class="line">    url = options.url</span><br><span class="line">  &#125; else if (arguments.length === 2) &#123;</span><br><span class="line">     url = arguments[0]</span><br><span class="line">     options = arguments[1]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let method = options.method</span><br><span class="line">  let headers = options.headers</span><br><span class="line">  let body = options.body</span><br><span class="line">  let successFn = options.successFn</span><br><span class="line">  let failFn = options.failFn</span><br></pre></td></tr></table></figure><p>加了一点，判断ajax()的参数个数。</p><ol><li>一千个人有一千零一个成功或失败函数的写法，所以为了维护世界和平，大家约定俗成了一套理论 <strong>Promise</strong> <strong>then( )</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Promise这个对象呢，大概长这个样子，真实面目我是没见过</span><br><span class="line">//简单的写一下promise</span><br><span class="line">window.Promise = function (fn) &#123;</span><br><span class="line">//...一些其他代码</span><br><span class="line">return &#123;</span><br><span class="line">  then: function () &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise这个构造函数呢，又会返回一个函数，这个返回的函数一个then属性，value又是一个函数。处处都体现着函数是第一公民的地位！！！<br>那我们可以利用这个强大的Promise对象搞一些事情了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//第一步的代码改造成这样，第一步用到了ES6的解构赋值法</span><br><span class="line">window.jQuery.ajax = function (&#123;url, method, body, headers&#125;) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line"></span><br><span class="line">    for(let key in headers) &#123;</span><br><span class="line">      let value = headers[key]</span><br><span class="line">      request.setRequestHeader(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">      if (request.readyState === 4) &#123;</span><br><span class="line">        if (request.status &gt;= 200 &amp;&amp; request.status &lt;= 300) &#123;</span><br><span class="line">          resolve.call(undefined, request.responseText)</span><br><span class="line">        &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">          reject.call(undefined, request)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）<br>详见<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ES6解构赋值</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//经过上面这么一折腾，可以很简单的使用了</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">   let promise = window.jQuery.ajax(&#123;</span><br><span class="line">     url: &apos;/xxx&apos;,</span><br><span class="line">     method: &apos;get&apos;,</span><br><span class="line">     headers: &#123;</span><br><span class="line">      &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">      &apos;wushao&apos;: &apos;18&apos;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   </span><br><span class="line">   promise.then(</span><br><span class="line">     (responseText) =&gt; &#123;</span><br><span class="line">       console.log(responseText)</span><br><span class="line">     &#125;,</span><br><span class="line">     (request) =&gt; &#123;</span><br><span class="line">       console.log(request)</span><br><span class="line">     &#125;</span><br><span class="line">   ) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意then可以传入两个函数，第一个函数表示成功了执行这个，第二个函数表示失败了执行这个，而且可以进行链式调用，一直点下去。</p><ol><li>所以实际上jq的写法大多是这么写的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;/xxx&apos;,</span><br><span class="line">      type: &apos;GET&apos;,</span><br><span class="line">    &#125;).then(</span><br><span class="line">      (responseText) =&gt; &#123;</span><br><span class="line">        console.log(responseText)</span><br><span class="line">        return responseText</span><br><span class="line">      &#125;,</span><br><span class="line">      (request) =&gt; &#123;</span><br><span class="line">        console.log(&apos;error&apos;)</span><br><span class="line">        return &apos;已经处理&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ).then(</span><br><span class="line">      (responseText) =&gt; &#123;</span><br><span class="line">        console.log(responseText)</span><br><span class="line">      &#125;,</span><br><span class="line">      (request) =&gt; &#123;</span><br><span class="line">        console.log(error2)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>链式调用的意思就是：成功函数成功了，就执行第二个then的第一个函数；成功函数失败了，就执行第二个then的第二个函数。</p><p>完整代码详见<a href="https://github.com/codevvvv9/AJAXDemo_nodeJsServer" target="_blank" rel="noopener">我的gitHub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;code&gt;JSON&lt;/code&gt; &lt;code&gt;AJAX&lt;/code&gt; &lt;code&gt;CORS&lt;/code&gt;  四个名词来开会&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何发请求&quot;&gt;&lt;a href=&quot;#如何发请求&quot; class=&quot;headerlink&quot; title=&quot;如何发请求&quot;&gt;&lt;/a&gt;如何发请求&lt;/h3&gt;&lt;p&gt;在前端的世界里也逛荡了不少日子了，目前已经get到大约5种发起请求的方式，主流的、非主流的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;何种方式&lt;/th&gt;
&lt;th&gt;请求方法&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;最常见的&lt;code&gt;form&lt;/code&gt;表单&lt;/td&gt;
&lt;td&gt;默认&lt;code&gt;GET&lt;/code&gt;，多用&lt;code&gt;POST&lt;/code&gt;,只此两种&lt;/td&gt;
&lt;td&gt;会刷新页面或者新开页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;a&lt;/code&gt; 标签&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;请求&lt;/td&gt;
&lt;td&gt;也会刷新页面或者新开页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;img&lt;/code&gt;的&lt;code&gt;src&lt;/code&gt;属性&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只能以图片的形式展现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;link&lt;/code&gt;标签&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只能以&lt;code&gt;CSS&lt;/code&gt;、&lt;code&gt;favicon&lt;/code&gt;的形式展现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;script&lt;/code&gt;标签&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只能以脚本的形式运行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可能想用&lt;code&gt;GET&lt;/code&gt; &lt;code&gt;POST&lt;/code&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;code&gt;DELETE&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;不想刷新整个页面，想用一种更易于理解的方式来响应&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="同源的问题及解决思路" scheme="https://codevvvv9.github.io/categories/%E5%90%8C%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    
    
      <category term="AJAX" scheme="https://codevvvv9.github.io/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>破解浏览器同源政策利器之JSONP</title>
    <link href="https://codevvvv9.github.io/2018/01/23/%E7%A0%B4%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E5%88%A9%E5%99%A8%E4%B9%8BJSONP/"/>
    <id>https://codevvvv9.github.io/2018/01/23/破解浏览器同源政策利器之JSONP/</id>
    <published>2018-01-23T14:35:46.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在了解了浏览器的同源规则之后，学习了破解这个规则的一个简单有效的方法-&gt;JSONP。主要通过阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">博客</a>学习</p></blockquote><h3 id="浏览器的同源规则"><a href="#浏览器的同源规则" class="headerlink" title="浏览器的同源规则"></a>浏览器的同源规则</h3><ul><li><p>有这样一个背景，如果你通过银行的网站进行的取钱的交易，而其他用户可以通过某个渠道获得你在银行网站的信息，那将是很可怕的。</p><a id="more"></a></li><li><p>所以，1995年NetScape公司(火狐的前身),提出了浏览器的同源政策，目的是保护使用网站的用户的信息安全。那么何谓同源呢</p><ul><li>协议相同</li><li>域名相同</li><li>端口号相同</li></ul></li></ul><p>不过，随着互联网的发展，有些时候我们需要破解同源，所以要先学习一下，古老而有效的JSONP方法。</p><h3 id="浏览器如何向服务器提交数据"><a href="#浏览器如何向服务器提交数据" class="headerlink" title="浏览器如何向服务器提交数据"></a>浏览器如何向服务器提交数据</h3><ul><li>有一天，程序员小白在自学，看到JSONP很牛，就向大神程序员小黑请教。小黑，小黑，这个JSONP是啥啊，感觉很牛( ⊙ o ⊙ )！。</li><li>小黑扶了扶500度的眼镜，摸了一下头顶的几根头发，若有所思的问小白。</li><li>小白啊，你说，浏览器怎么向服务器提交数据啊，比如说，你要付款这个情形。</li><li>form表单啊，我规定<code>&lt;form method=&quot;POST&quot; action=&quot;/...&quot;&gt;&lt;/form&gt;</code>，我不用get请求。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>您的账户余额是<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"amount"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>付款1块钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/pay"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"付款"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>恩，还是不错的啊，知道用<code>POST</code>发起请求。那你这提交完了之后，是不是还要在当前页面刷新一下，才能看到余额啊。</li><li>……哎，是啊，不过我可以给你加一个<code>iframe</code>，就在当前页面刷新</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/pay"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">target</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"付款"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"result"</span> <span class="attr">src</span>=<span class="string">"about:blank"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有什么反馈信息都在iframe显示。</p><ul><li>恩，也还行，不过你为啥要把总额200写死在页面呢，不应该动态从数据库中获得吗</li><li>╮(╯▽╰)╭，稍等我改一哈</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>您的账户余额是<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"amount"</span>&gt;</span>&amp;&amp;&amp;amount&amp;&amp;&amp;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>付款1块钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">button.addEventListener('click', (e) =&gt; &#123;</span><br><span class="line">    let n = amount.innerText</span><br><span class="line">    let number = parseInt(n, 10)</span><br><span class="line">    let newNumber = number - 1</span><br><span class="line">    amount.innerText = newNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我用<code>&amp;&amp;&amp;amount&amp;&amp;&amp;</code>占位符表示总额，服务器端可以如下处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amount = fs.readFileSync(<span class="string">'./db'</span>, <span class="string">'utf-8'</span>) <span class="comment">//从db中读取</span></span><br><span class="line">string = string.replace(<span class="string">'&amp;&amp;&amp;amount&amp;&amp;&amp;'</span>, amount) <span class="comment">//把占位的数据换成真的数据</span></span><br><span class="line">...</span><br><span class="line">response.write(string)</span><br></pre></td></tr></table></figure><ul><li>恩，不错，你再想想有没有其他的方式也可以发送数据到服务器端啊，不用刷新页面的那种</li><li>……还有其他的( ⊙ o ⊙ )啊！</li><li>那我老黑我给你讲讲前辈程序员们试过的方法吧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用图片发起get请求</span></span><br><span class="line"><span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">image.src = <span class="string">'/pay'</span></span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'打钱成功'</span>)</span><br><span class="line">  amount.innerText = amount.innerText - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'打钱失败'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种也是可以的，而且也会用提示给用户，交互性还可以，不过只能发起<code>GET</code>请求，哈哈，我就是秀一下黑科技，很少用啦……</p><ul><li>(<em>@ο@</em>) 哇～这也可以，小黑，你好棒，又长见识啦,不过还是没给我讲JSONP啊,你是不是忘了……</li></ul><ul><li>没忘啦，不要着急，接下来，就给你好好讲讲这个JSONP</li></ul><h3 id="动态创建JS脚本发数据"><a href="#动态创建JS脚本发数据" class="headerlink" title="动态创建JS脚本发数据"></a>动态创建JS脚本发数据</h3><ul><li>小白啊，你平常用的最多的是哪门语言啊</li><li>中文啊，英语不大好。</li><li>……我说编程的时候</li><li>呃呃，那个用的JavaScript多啊</li><li>好，那咱们就用js脚本发数据呗</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用js脚本发起请求  </span></span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = <span class="string">'/pay'</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'failed'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">//服务器端一般这么干</span></span><br><span class="line"> <span class="keyword">if</span>(path === <span class="string">'/pay'</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> amount = fs.readFileSync(<span class="string">'./db'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="keyword">var</span> newAmount = amount - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  fs.writeFileSync(<span class="string">'./db'</span>, newAmount)</span><br><span class="line">  response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/javascript'</span>)</span><br><span class="line">  response.statusCode = <span class="number">200</span></span><br><span class="line">  response.write(<span class="string">`</span></span><br><span class="line"><span class="string">    amount.innerText = amount.innerText - 1</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line"></span><br><span class="line">  response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上是js脚本的大致意思，细节不要深究，明白就行。注意一下，添加<code>script</code>后，要记得<code>document.body.appendChild(script)</code></p><ul><li>不过，小黑啊，你这动态加上了<code>script</code>没错，可是你每次都往我的html底部加js，这破坏我的html啊</li><li>恩，小白啊，你思考能力还是可以的，目前确实有这个弊端，我给你处理一下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用js脚本发起请求  </span></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'/pay'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.currentTarget.remove() <span class="comment">//加载完了，就移除</span></span><br><span class="line">&#125;</span><br><span class="line">script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'failed'</span>)</span><br><span class="line">  e.currentTarget.remove() <span class="comment">//加载完了，就移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以可以，小黑你这波操作可以的。快让我见识见识JSONP吧</p></li><li><p>好，这就给你变出来</p><p>​</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">   <span class="comment">//用js脚本发起请求  </span></span><br><span class="line">   <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">   <span class="keyword">let</span> functionName = <span class="string">'wushao'</span> + <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random()*<span class="number">100000</span>), <span class="number">10</span>)</span><br><span class="line">   <span class="built_in">window</span>[functionName] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (result === <span class="string">'success'</span>) &#123;</span><br><span class="line">       amount.innerText = amount.innerText - <span class="number">1</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   script.src = <span class="string">'http://想访问的另一个网站:端口号/pay?callback='</span> + functionName</span><br><span class="line">   <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">   script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     e.currentTarget.remove()</span><br><span class="line">   &#125;</span><br><span class="line">   script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     alert(<span class="string">'failed'</span>)</span><br><span class="line">     e.currentTarget.remove()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ul><li>ヾ(｡｀Д´｡)黑神，你这跨度有点大，咋变了个大魔术。</li><li>O(∩_∩)O哈哈~，你让我给你快点讲的……，我给你讲讲细节吧<ol><li>let functionName = ‘wushao’ + parseInt((Math.random()*100000), 10) 使用一个随机函数构建自己的函数名字，可以与服务器端代码完美解耦，服务器端只需要，获得查询参数<code>?callback=functionName</code> 里面的functionName就可以了。</li><li><code>window[functionName] = function (result) { }</code> 在window全局对象上添加<code>functionName</code>属性，它的值是一个函数，当服务器端响应回来后，浏览器端的写的函数的参数就是服务器端的<code>success</code>，我们就知道我的数据成功了。</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端只需要这样就可以了，不关心你写的是什么函数名字</span></span><br><span class="line">response.write(<span class="string">`</span></span><br><span class="line"><span class="string">   <span class="subst">$&#123;query.callback&#125;</span>.call(undefined, 'success')</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><ul><li>哇，厉害啊，不过你又犯了一个相同的错误啦，哈哈，每次要把添加的全局对象的属性去掉哦～</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.currentTarget.remove()</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">window</span>[functionName]</span><br><span class="line">&#125;</span><br><span class="line">script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'failed'</span>)</span><br><span class="line">  e.currentTarget.remove()</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">window</span>[functionName]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>O(∩_∩)O哈！，这样子就对了，小白啊，既然你学过jQuery，你试一试jQuery的写法吧</li><li>(^o^)/~行，小黑，我也给你变一个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"http://想访问的另一个网站:端口号/pay"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The name of the callback parameter, as specified by the YQL service</span></span><br><span class="line">  jsonp: <span class="string">"callback"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell jQuery we're expecting JSONP</span></span><br><span class="line">  dataType: <span class="string">"jsonp"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Work with the response</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(response === <span class="string">'success'</span>) &#123;</span><br><span class="line">    amount.innerText = amount.innerText - <span class="number">1</span> </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>哎呦，不错呦，小白～</li><li>O(∩_∩)O哈哈~，我就是Google的 <code>jquery jsonp</code></li><li>不过，这个可和ajax，没啥关系啊，不明白为啥jquery为啥这么写。</li></ul><p><strong>具体的代码链接</strong>在============&gt;<a href="https://github.com/codevvvv9/nodejsServer/blob/master/index.html" target="_blank" rel="noopener">传送门</a></p><h3 id="什么是JSONP呢"><a href="#什么是JSONP呢" class="headerlink" title="什么是JSONP呢"></a>什么是JSONP呢</h3><p>请求方是一个网站(浏览器端)，响应方是另一个网站（服务器端）</p><ol><li><p>请求方动态的创建一个script脚本，src属性是响应方的地址，同时传递一个查询查参数<code>？callback=functionName</code>，一般functionName使用随机函数构造。</p></li><li><p>响应方根据收到的查询参数callback=functionName,去构造形如</p><p>2.1 <code>functionName.call(undefined, &#39;success&#39;)</code></p><p>2.2 或者直接<code>functionName.(&#39;success&#39;)</code></p><p>这样的响应。</p></li><li><p>浏览器收到响应之后，就会执行<code>functionName.call(undefined, &#39;success&#39;)</code>或者<code>functionName.(&#39;success&#39;)</code></p></li><li><p>然后，请求方就知道了他想要获得的数据如何了。</p></li></ol><p>这就是JSONP的原理</p><h3 id="为什么JSONP不支持POST请求呢"><a href="#为什么JSONP不支持POST请求呢" class="headerlink" title="为什么JSONP不支持POST请求呢"></a>为什么JSONP不支持POST请求呢</h3><p>答曰：JSONP是动态创建的js脚本，这个方法只能发起GET请求，不能发起POST请求。</p><blockquote><p>接下来学习ajax啦～加油↖(^ω^)↗</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是在了解了浏览器的同源规则之后，学习了破解这个规则的一个简单有效的方法-&amp;gt;JSONP。主要通过阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;浏览器的同源规则&quot;&gt;&lt;a href=&quot;#浏览器的同源规则&quot; class=&quot;headerlink&quot; title=&quot;浏览器的同源规则&quot;&gt;&lt;/a&gt;浏览器的同源规则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有这样一个背景，如果你通过银行的网站进行的取钱的交易，而其他用户可以通过某个渠道获得你在银行网站的信息，那将是很可怕的。&lt;/p&gt;
    
    </summary>
    
      <category term="同源的问题以及解决思路" scheme="https://codevvvv9.github.io/categories/%E5%90%8C%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    
    
      <category term="JSONP" scheme="https://codevvvv9.github.io/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>node-sass安装失败的究极解决方法.md</title>
    <link href="https://codevvvv9.github.io/2018/01/19/node-sass%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E7%A9%B6%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://codevvvv9.github.io/2018/01/19/node-sass安装失败的究极解决方法/</id>
    <published>2018-01-19T15:24:07.000Z</published>
    <updated>2018-12-01T10:53:56.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下安装node-sass的过程.关于CSS是不是一门编程语言,这里不讨论,但是它没有变量 语句 函数(反正我觉得他不是编程语言).于是程序员们发明了CSS预处理器(css preprocessor),它是一种专门的编程语言,可以使用你会的基本的编程知识进行编程,然后再转化成css文件.</p></blockquote><h3 id="12月更新"><a href="#12月更新" class="headerlink" title="12月更新"></a>12月更新</h3><p>本次重新安装<code>node-sass</code>是因为电脑换了固态重装系统了，在新系统下很长时间内没有用过<code>sass</code>，一切都是那个风平浪静，直到11月的最后一晚，想折腾一下博客，看到一个好看的主题，这个主题需要安装两个插件，其中有一个需要<code>node-sass</code>的加持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-pug --save</span><br><span class="line"><span class="meta">$</span> npm install hexo-renderer-sass --save  #就是这货</span><br></pre></td></tr></table></figure><p>不出意外的，国内不采取特殊途径，<code>hexo-renderer-sass</code>安装报错，根据<code>log日志</code>，很容易的发现，他需<a href="mailto:`node-sass@4.10.0" target="_blank" rel="noopener">`node-sass@4.10.0</a>`支持，但是下载失败。</p><ol><li><p>解决方案1：先在<code>global</code>下安装<code>node-sass</code></p><ul><li>重装后我全是采用的<code>nvm</code>管理的<code>node</code>版本，所有的包都在<code>.nvm</code>目录下，避免权限不够的错误(或者采取分割线以下的阮一峰老师的方法避免包权限的问题)。</li><li>配置<code>.npmrc</code>，先<code>touch ~/.npmrc</code>。这次直接采取<code>node-sass</code>的<a href="https://github.com/sass/node-sass" target="_blank" rel="noopener">官方推荐的方式</a>，<code>npm install -g mirror-config-china --registry=http://registry.npm.taobao.org</code>，所有的国内有问题的包全都避免了。</li><li>结果竟然无法下载，<code>log日志</code>提醒我可能是代理的问题，可能是我的<code>FQ</code>的系统代理有问题，去控制台一看，果然<code>SOCKETS 有个错误</code>，尝试使用<code>npm</code>添加代理的方式，均告失败，毕竟以后也不能总靠代理过日子，这个方式不可取。这次想找个一劳永逸的方式彻底解决这个垃圾问题。</li><li>终于发现了，直接使用下载好的<code>Realease</code>包去安装，先去<a href="https://github.com/sass/node-sass/releases" target="_blank" rel="noopener">node-sass主页</a>下载系统需要的类型，这个完全可以解决系统不同的问题，很具用普适性。</li><li>到底你的系统需要那个具体的包呢，这个就是最关键的了，我的方式是：先安装，失败后会提示你<code>哪个版本的node包</code>无法下载，这个时候再去下载这个包。通过如下代码去安装：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g node-sass@4.9.3 --sass_binary_path=/home/wsl/Downloads/chromeDownloads/linux-x64-64_binding.node</span><br><span class="line"><span class="meta">#</span> path需要替换成你系统的那个包名字</span><br></pre></td></tr></table></figure><p><code>But</code>我以为下载成功了，就万事大吉了呢，发现我真是太天真了。安装完后第一件事就是检验安装的包能不能用，<code>node-sass -v</code>一下，最不济出现个<code>node-sass not found</code>这种类似的初级错误啊，结果报了个无语的错误。</p><p><img src="https://i.loli.net/2018/12/01/5c02610b47259.png" alt="找不到vendor目录"></p><p>这个目录是<code>node-sass</code>规定的</p><p><img src="https://i.loli.net/2018/12/01/5c0263e5ad309.png" alt="node-sass-package.json"></p><p>为啥没有这个目录呢，因为通过 我采用的是设置本地下载路径，没有通过网上的下载。所以需要手动建立一个<code>vendor</code>目录（<code>issues里面通过npm rebulid node-sass可以解决，但是我没生效</code>），接着会报第二个新错误，这就很合理了，报错一点不可怕，能看懂并解决掉就很是进步。</p></li></ol><p><img src="https://i.loli.net/2018/12/01/5c02637aed955.png" alt="找不到binding文件"></p><p>新的错误是需要<code>binding.node</code>文件，刚才建立的<code>vendor</code>是个空目录所以找不到，在其内部建立二级目录，并把刚才下载的包改名为<code>binding.node</code>，即<code>vendor/linux-X64-64/binding.node</code></p><p><strong>至此，本地安装<code>node-sass</code></strong>完毕，以后可以随便玩<code>node-sass</code>了，管你能不能翻墙，能不能设置镜像。</p><ol start="2"><li>本来以为全局安装完毕就可以在博客目录下直接安装<code>hexo-renderer-sass</code>，竟然还是报错。没办法，在<code>newBlog</code>目录下又<strong>按照上述的方法</strong>安装了一个<a href="mailto:`node-sass@4.10.0" target="_blank" rel="noopener">`node-sass@4.10.0</a><code>，因为</code>hexo-render-sass`需要4.10.0版本。最后终于成功了。</li></ol><p><img src="https://i.loli.net/2018/12/01/5c0266bae321d.png" alt="安装成功"></p><p><strong>分割线以下为传统解决方法，尤其针对Linux用户</strong></p><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>主流的CSS预处理器有<a href="https://www.catswhocode.com/blog/8-css-preprocessors-to-speed-up-development-time" target="_blank" rel="noopener">8种</a>,我们今天介绍<code>sass</code>.它的<a href="http://sass-lang.com/" target="_blank" rel="noopener">官网</a>,不过需要安装ruby.</p><a id="more"></a><ul><li>不想安ruby,那就借助node安装<code>node-sass</code>吧.github<a href="https://github.com/sass/node-sass" target="_blank" rel="noopener">主页</a></li><li>本人是<code>deepin Linux 15.5</code>版本<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li><li><p>由于node-sass会去github主页下载binding-node,然后又去亚马逊去下载,所以国内因为一些不可抗力无法下载.简单的进行如下的设置,都是初学者,我就不用命令的形式写了,下面直接写上内容.基本的命令用多了也就会了.</p><ul><li><p>在主目录下建立一个.npmrc的文件,在里面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/</span><br><span class="line">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br><span class="line">//顺序好像会有影响,我一开始不是这个顺序,后来改成这个,能安装成功</span><br></pre></td></tr></table></figure></li><li><p>还必须在主目录的.bashrc下添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>好了,按理说可以用如下命令正常安装了,但是出问题了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm i -g node-sass</span><br></pre></td></tr></table></figure></li></ul><h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><h4 id="第一个错误"><a href="#第一个错误" class="headerlink" title="第一个错误"></a>第一个错误</h4><ol><li>用了上述的命令,我第一次就报错,Error显示说<em>权限不够</em>,我果断用了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i  -g node-sass</span><br></pre></td></tr></table></figure><ul><li>恩,然后就是无休止的错误,ctrl+c终止后,发现node_modules里面有node-sass,但是明显不能用.去github的issue上搜,大神都是用了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm rebulid node-sass</span><br></pre></td></tr></table></figure></li></ul><p>然而成功是属于其他人的.</p><ul><li>我试了一下,又是报错, 还是权限不够,我又加了<code>sudo</code>.</li><li>恩,又是报错.此时我很烦,你说没权限,我加了权限你又报错,这个死循环…….</li><li>没办法,生活还要继续,又去stackoverflow和github上搜,在node-sass的项目的<code>Troubleshooting</code>上发现了问题所在,如下是<a href="https://github.com/sass/node-sass/blob/master/TROUBLESHOOTING.md#cannot-find-module-rootinstalljs" target="_blank" rel="noopener">Linux部分的官方文档</a></li></ul><blockquote><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>This can happen if you are install node-sass as <code>root</code>, or globally with <code>sudo</code>. This is a security feature of <code>npm</code>. You should always avoid running <code>npm</code> as <code>sudo</code> because install scripts can be unintentionally malicious. Please check <a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="noopener">npm documentation on fixing permissions</a>.<br>If you must however, you can work around this error by using the <code>--unsafe-perm</code> flag with npm install i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo npm install --unsafe-perm -g node-sass</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>If this didn’t solve your problem please open an issue with the output from <a href="https://github.com/sass/node-sass/blob/master/TROUBLESHOOTING.md#debugging-installation-issues" target="_blank" rel="noopener">our debugging script</a>.</p></blockquote><ul><li>文档说: 当你用root角色或者全局使用sudo命令安装的时候,就会发生这个错误.(-妈个鸡,我就是全局安装node-sass啊),不过人家说了,这是npm的安全特性.(-你牛你说啥都行),你应该总是避免使用sudo去执行npm,因为安装脚本会发生意想不到的致命错误(-确实意想不到,以前我都是sudo安装模块,就这次栽了,不过你倒是说咋解决啊),请左转去npm的官方文档(- 这是重点,解决方法就在这里),如果你非要用sudo,用下面的命令吧…………..<strong>如果这些仍没有解决你的问题,请看了我们的debugging脚本里面的解决方法在开启一个新的issue吧(如果大家还有和我不一样的错误,这里有很多解决方法)<a href="https://github.com/sass/node-sass/blob/master/TROUBLESHOOTING.md#debugging-installation-issues" target="_blank" rel="noopener">our debugging script</a></strong>.</li><li>好了,翻译完了,咱们去npm的第三章去看看咋解决.</li><li><a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="noopener">第三章</a>写的写的很明白.</li></ul><ol start="2"><li>如何避免权限错误<br> 下面是文档原文<blockquote><p>If you see an EACCES error when you try to install a package globally, read this chapter. This error can be avoided if you change the directory where npm is installed. To do this, either:<br>Reinstall npm with a version manager (recommended),<br>or<br>Change npm’s default directory manually.</p></blockquote></li></ol><p>它说:如果你尝试安装一个全局的包,遇到了权限的错误,应该读读这一章.如果npm被安装的时候你改变了npm的目录,这个错误就会被避免(- 言下之意,就是让你改目录,就可以避免不能操作/usr/local/底下的内容了,你或者可以改变目录的权限 <code>chmod [mode] dir</code>,效果应该一样的,我没试过,而且官方也没说),要想做到这个,要么用版本管理工具重装npm(- 官方推荐的),要么就手动改变npm的默认目录(我用的这个).</p><ul><li>好了,翻译完了,如果你想用官方推荐的方法就用版本管理工具重装npm,就去看文档的<a href="https://docs.npmjs.com/getting-started/installing-nodehttps://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="noopener">第二章</a><h4 id="版本管理工具"><a href="#版本管理工具" class="headerlink" title="版本管理工具"></a>版本管理工具</h4></li><li>官方推荐用<a href="https://github.com/creationix/nvm/blob/master/README.md#installation" target="_blank" rel="noopener">nvm</a>,我以前误打误撞安了一个TJ大神(尤雨溪的偶像)的n模块( 不会用,就会升级,好尴尬啊)</li><li>还有一个<blockquote><p>If you are using npm version 5.2 or greater, explore tools such as <a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a> to circumvent permissions issues.</p></blockquote></li></ul><p>如果你的npm版本是5.2以上,可以用npx(又是好尴尬,我有npx,也不会用…..)</p><ul><li><p>还有特别火的小猫<a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener">yarn</a>,快30000的star了(不过我没用……)</p></li><li><p>恩,前端的世界很精彩啊.</p><h4 id="手动更改npm目录"><a href="#手动更改npm目录" class="headerlink" title="手动更改npm目录"></a>手动更改npm目录</h4></li></ul><blockquote><p>Back-up your computer before moving forward.<br>Make a directory for global installations:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir ~/.npm-global</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Configure npm to use the new directory path:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm config set prefix &apos;~/.npm-global&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Open or create a ~/.profile file and add this line:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; export PATH=~/.npm-global/bin:$PATH</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Back on the command line, update your system variables:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; source ~/.profile</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Instead of steps 2-4, you can use the corresponding ENV variable (e.g. if you don’t want to modify ~/.profile):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; NPM_CONFIG_PREFIX=~/.npm-global</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>官方确实够详细,也能用,你不想麻烦,就在环境变量里面<code>NPM_CONFIG_PREFIX=~/.npm-global</code></li><li>我试过这个方法,不过建立的<code>.npm-global</code>隐藏得太深了,<code>ctrl+H</code>都看不到它,我就采用了阮一峰大神的<a href="http://javascript.ruanyifeng.com/nodejs/npm.html#toc10" target="_blank" rel="noopener">方法</a>,方法还是要用大神的博客的方法或者官方的啊.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。</span><br><span class="line"></span><br><span class="line">prefix = /home/yourUsername/npm</span><br><span class="line"></span><br><span class="line">然后在主目录下新建npm子目录。</span><br><span class="line"></span><br><span class="line">mkdir ~/npm</span><br><span class="line"></span><br><span class="line">此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。</span><br><span class="line">最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。</span><br><span class="line"></span><br><span class="line">export PATH=~/npm/bin:$PATH</span><br></pre></td></tr></table></figure><ul><li><p>做完这个之后,全局卸载不能用的node-sass,再<code>npm i -g node-sass</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 卸载全局模块</span><br><span class="line">$ npm uninstall [package name] -global</span><br></pre></td></tr></table></figure></li><li><p>很遗憾,旧目录的没删成功,不过新目录的能用就行……………………</p><h3 id="安装小总结"><a href="#安装小总结" class="headerlink" title="安装小总结"></a>安装小总结</h3></li></ul><hr><p><strong>1. 一定不要用sudo安装,先手动改npm的目录</strong><br><strong>2. 更改.npmrc 和 .bashrc</strong><br><strong>3. <code>npm i -g node-sass</code></strong><br><strong><em>4. 英语多学点,文档多看点,命令行多用点.</em></strong></p><hr><h3 id="node-sass的简单使用"><a href="#node-sass的简单使用" class="headerlink" title="node-sass的简单使用"></a>node-sass的简单使用</h3><ul><li><p>它的使用方法和ruby的sass有一点小区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node-sass -wr scss -o css</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/sass/node-sass" target="_blank" rel="noopener">官方使用手册</a></p></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">阮一峰教程</a></li></ul><h4 id="加油啊-sass"><a href="#加油啊-sass" class="headerlink" title="加油啊,sass"></a>加油啊,sass</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录一下安装node-sass的过程.关于CSS是不是一门编程语言,这里不讨论,但是它没有变量 语句 函数(反正我觉得他不是编程语言).于是程序员们发明了CSS预处理器(css preprocessor),它是一种专门的编程语言,可以使用你会的基本的编程知识进行编程,然后再转化成css文件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;12月更新&quot;&gt;&lt;a href=&quot;#12月更新&quot; class=&quot;headerlink&quot; title=&quot;12月更新&quot;&gt;&lt;/a&gt;12月更新&lt;/h3&gt;&lt;p&gt;本次重新安装&lt;code&gt;node-sass&lt;/code&gt;是因为电脑换了固态重装系统了，在新系统下很长时间内没有用过&lt;code&gt;sass&lt;/code&gt;，一切都是那个风平浪静，直到11月的最后一晚，想折腾一下博客，看到一个好看的主题，这个主题需要安装两个插件，其中有一个需要&lt;code&gt;node-sass&lt;/code&gt;的加持。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; npm install hexo-renderer-pug --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; npm install hexo-renderer-sass --save  #就是这货&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不出意外的，国内不采取特殊途径，&lt;code&gt;hexo-renderer-sass&lt;/code&gt;安装报错，根据&lt;code&gt;log日志&lt;/code&gt;，很容易的发现，他需&lt;a href=&quot;mailto:`node-sass@4.10.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;`node-sass@4.10.0&lt;/a&gt;`支持，但是下载失败。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解决方案1：先在&lt;code&gt;global&lt;/code&gt;下安装&lt;code&gt;node-sass&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重装后我全是采用的&lt;code&gt;nvm&lt;/code&gt;管理的&lt;code&gt;node&lt;/code&gt;版本，所有的包都在&lt;code&gt;.nvm&lt;/code&gt;目录下，避免权限不够的错误(或者采取分割线以下的阮一峰老师的方法避免包权限的问题)。&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;.npmrc&lt;/code&gt;，先&lt;code&gt;touch ~/.npmrc&lt;/code&gt;。这次直接采取&lt;code&gt;node-sass&lt;/code&gt;的&lt;a href=&quot;https://github.com/sass/node-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方推荐的方式&lt;/a&gt;，&lt;code&gt;npm install -g mirror-config-china --registry=http://registry.npm.taobao.org&lt;/code&gt;，所有的国内有问题的包全都避免了。&lt;/li&gt;
&lt;li&gt;结果竟然无法下载，&lt;code&gt;log日志&lt;/code&gt;提醒我可能是代理的问题，可能是我的&lt;code&gt;FQ&lt;/code&gt;的系统代理有问题，去控制台一看，果然&lt;code&gt;SOCKETS 有个错误&lt;/code&gt;，尝试使用&lt;code&gt;npm&lt;/code&gt;添加代理的方式，均告失败，毕竟以后也不能总靠代理过日子，这个方式不可取。这次想找个一劳永逸的方式彻底解决这个垃圾问题。&lt;/li&gt;
&lt;li&gt;终于发现了，直接使用下载好的&lt;code&gt;Realease&lt;/code&gt;包去安装，先去&lt;a href=&quot;https://github.com/sass/node-sass/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-sass主页&lt;/a&gt;下载系统需要的类型，这个完全可以解决系统不同的问题，很具用普适性。&lt;/li&gt;
&lt;li&gt;到底你的系统需要那个具体的包呢，这个就是最关键的了，我的方式是：先安装，失败后会提示你&lt;code&gt;哪个版本的node包&lt;/code&gt;无法下载，这个时候再去下载这个包。通过如下代码去安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm i -g node-sass@4.9.3 --sass_binary_path=/home/wsl/Downloads/chromeDownloads/linux-x64-64_binding.node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; path需要替换成你系统的那个包名字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;But&lt;/code&gt;我以为下载成功了，就万事大吉了呢，发现我真是太天真了。安装完后第一件事就是检验安装的包能不能用，&lt;code&gt;node-sass -v&lt;/code&gt;一下，最不济出现个&lt;code&gt;node-sass not found&lt;/code&gt;这种类似的初级错误啊，结果报了个无语的错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/01/5c02610b47259.png&quot; alt=&quot;找不到vendor目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个目录是&lt;code&gt;node-sass&lt;/code&gt;规定的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/01/5c0263e5ad309.png&quot; alt=&quot;node-sass-package.json&quot;&gt;&lt;/p&gt;
&lt;p&gt;为啥没有这个目录呢，因为通过 我采用的是设置本地下载路径，没有通过网上的下载。所以需要手动建立一个&lt;code&gt;vendor&lt;/code&gt;目录（&lt;code&gt;issues里面通过npm rebulid node-sass可以解决，但是我没生效&lt;/code&gt;），接着会报第二个新错误，这就很合理了，报错一点不可怕，能看懂并解决掉就很是进步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/01/5c02637aed955.png&quot; alt=&quot;找不到binding文件&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的错误是需要&lt;code&gt;binding.node&lt;/code&gt;文件，刚才建立的&lt;code&gt;vendor&lt;/code&gt;是个空目录所以找不到，在其内部建立二级目录，并把刚才下载的包改名为&lt;code&gt;binding.node&lt;/code&gt;，即&lt;code&gt;vendor/linux-X64-64/binding.node&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，本地安装&lt;code&gt;node-sass&lt;/code&gt;&lt;/strong&gt;完毕，以后可以随便玩&lt;code&gt;node-sass&lt;/code&gt;了，管你能不能翻墙，能不能设置镜像。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;本来以为全局安装完毕就可以在博客目录下直接安装&lt;code&gt;hexo-renderer-sass&lt;/code&gt;，竟然还是报错。没办法，在&lt;code&gt;newBlog&lt;/code&gt;目录下又&lt;strong&gt;按照上述的方法&lt;/strong&gt;安装了一个&lt;a href=&quot;mailto:`node-sass@4.10.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;`node-sass@4.10.0&lt;/a&gt;&lt;code&gt;，因为&lt;/code&gt;hexo-render-sass`需要4.10.0版本。最后终于成功了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/01/5c0266bae321d.png&quot; alt=&quot;安装成功&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分割线以下为传统解决方法，尤其针对Linux用户&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;主流的CSS预处理器有&lt;a href=&quot;https://www.catswhocode.com/blog/8-css-preprocessors-to-speed-up-development-time&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;8种&lt;/a&gt;,我们今天介绍&lt;code&gt;sass&lt;/code&gt;.它的&lt;a href=&quot;http://sass-lang.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;,不过需要安装ruby.&lt;/p&gt;
    
    </summary>
    
      <category term="Sass使用" scheme="https://codevvvv9.github.io/categories/Sass%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Sass" scheme="https://codevvvv9.github.io/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>理解Event的冒泡模型</title>
    <link href="https://codevvvv9.github.io/2018/01/17/%E7%90%86%E8%A7%A3Event%E7%9A%84%E5%86%92%E6%B3%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://codevvvv9.github.io/2018/01/17/理解Event的冒泡模型/</id>
    <published>2018-01-17T13:22:38.000Z</published>
    <updated>2018-11-18T09:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文探索一下Event的冒泡过程和初学遇到的几个小bug</p></blockquote><h3 id="DOM-Event概述"><a href="#DOM-Event概述" class="headerlink" title="DOM Event概述"></a>DOM Event概述</h3><p>Event接口是检测在DOM中的发生的所有事件，我们一直在用，而且从DOM的很早的版本就一直在用着。早期的网景(后来的火狐)和IE是各自为战，直到W3C一统江湖，DOM<a href="https://www.w3.org/DOM/DOMTRhttps://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">版本</a>一路发展而来，经历了DOM-0(洪荒时代)、DOM-1(只有两章核心内容)、DOM-2(划时代的一个版本，我们学的Event就在这个版本，而且目前的用的也是这个版本)、DOM-3、DOM-4(草案阶段)。</p><a id="more"></a><ul><li>通过一个例子唤醒对Event的认识</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、有一个js函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、在html的button里面点击触发上面的函数</span></span><br><span class="line">&lt;button id=button onclick=<span class="string">"?"</span>&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/问号处填可以填什么 A. print() B.print C.print.call()</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在js里面的onclick里面触发</span></span><br><span class="line"><span class="regexp">button.onclick = ?</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/问号处可以填什么 A. print() B.print C.print.call()</span></span><br></pre></td></tr></table></figure><ul><li>很明显第一个问号应该选<code>A</code> <code>C</code>，第二个问号应该选<code>B</code></li><li>第一处在HTM中，点击事件要立刻执行代码，肯定选择带<code>()</code>的，而第二处在JS中，onclick是一个属性，不需要立刻执行，等用户点击了，浏览器再反应，不需要<code>()</code>。</li></ul><p>既然<code>onclick</code>等on事件在JS中是一个属性，那么后面的就会覆盖前面的，所以DOM2里面引入了一个重要的<code>EventListener</code>，是一个队列。</p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>这是一个队列，<a href="http://js.jirengu.com/rixodijifu/1/edit?html,js,output" target="_blank" rel="noopener">例子1</a>，先进先出的特点，为后面的冒泡模型做准备。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"eventListener不会覆盖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button2.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"eventListener不会覆盖1"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">button2.addEventListener(<span class="string">'click'</span>, f)</span><br><span class="line">button2.removeEventListener(<span class="string">'click'</span>, f)</span><br><span class="line">button2.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"eventListener不会覆盖3"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>会打印出什么呢，答案是<code>eventListener不会覆盖1</code> <code>eventListener不会覆盖3</code></li><li>所以说既然on可以一个打印出结果，就可以借助<code>remove</code>来实现<code>one</code>执行一次的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"eventListener不会覆盖2"</span>)</span><br><span class="line">  button2.removeEventListener(<span class="string">'click'</span>, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button2.addEventListener(<span class="string">'click'</span>, f)</span><br></pre></td></tr></table></figure><p>只会<a href="http://js.jirengu.com/yunidupexu/2/edit?html,js,output" target="_blank" rel="noopener">打印一次</a>，不会一直打印了，也就是<code>one</code>的原理。</p><ul><li>具体的模型可以看<a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="noopener">W3C</a></li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b57c2a5381.png" alt="W3C的模型"></p><h3 id="冒泡模型"><a href="#冒泡模型" class="headerlink" title="冒泡模型"></a>冒泡模型</h3><p>上面的官方文档中，我只研究一下捕获阶段(capture phase)和冒泡阶段(bubbling phase)。</p><ul><li>什么是冒泡呢？我们先看一段代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grand.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爷爷'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">dad.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爸爸'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你儿子'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>这是三个<code>div</code>的事件，当你点击的时候，控制台打印必然会有顺序。那么应该是什么顺序呢，正常人的思维不外乎两种结果<ul><li>第一种：我是你的儿子 我是你爸爸 我是你爷爷</li><li>第二种： 我是你爷爷 我是你爸爸 我是你儿子</li><li>到底是那种呢，W3C说都行，看你代码咋写的了，上面的代码打印顺序是第一个中，也就是冒泡。</li></ul></li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b6ce41226c.png" alt="冒泡排序"></p><ul><li>如果你想实现第二种打印方式，也就是捕获阶段，应该修改代码如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grand.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爷爷'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">dad.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爸爸'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你儿子'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li>也就是说<code>addEventListener</code>后面的参数决定了顺序，当你不写的时候是<code>undefined</code>，也就是<code>false</code>的意思。</li><li>复习一下五个<code>falsey</code>值<ul><li><code>0</code> <code>NaN</code> <code>&#39;&#39;</code> <code>null</code> <code>undefined</code> 除此之外都是<code>true</code></li></ul></li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b6ffaaaedf.png" alt="简单的图解"></p><p>上图是简单的图解，注意优先运行为<code>true</code>的部分，再运行<code>false</code>的部分。</p><p>简单的实例====================&gt;<a href="http://js.jirengu.com/yunidupexu/5/edit" target="_blank" rel="noopener">demo</a></p><ul><li>一个变式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grand.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爷爷'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">dad.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你爸爸'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你儿子'</span>)</span><br></pre></td></tr></table></figure><ul><li>上述代码应该是什么顺序呢</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b715a63d20.png" alt="变式"></p><ul><li>谁是<code>true</code>，先打印谁，都是<code>false</code>，继续按照冒泡顺序打印。</li></ul><h4 id="一个奇葩的问题"><a href="#一个奇葩的问题" class="headerlink" title="一个奇葩的问题"></a>一个奇葩的问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">son.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你儿子true'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是你儿子false'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>给同一个元素 <code>false</code> <code>true</code>，应该打印什么呢</li><li>答案是： 按照书写的顺序，谁在前面先打印谁。</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b72e180874.png" alt="奇葩"></p><h4 id="意想不到的Bug"><a href="#意想不到的Bug" class="headerlink" title="意想不到的Bug"></a>意想不到的Bug</h4><p><code>parent</code>是关键字不能使用，一不小心使用的话会出问题。</p><p><img src="https://i.loli.net/2018/01/14/5a5b738b07586.png" alt="意外bug"></p><ul><li>你用了关键字做变量，把鼠标点烂也看不到效果。</li></ul><h3 id="点击空白，对话框消失的案例"><a href="#点击空白，对话框消失的案例" class="headerlink" title="点击空白，对话框消失的案例"></a>点击空白，对话框消失的案例</h3><ul><li>领导说有一个需求，点击某个按钮，弹出对话框，点击空白会消失。</li><li>你的第一个思路：先把div设为none，点击按钮的时候，再让这个<code>div</code>的display是block，点击其他地方变为none。</li><li>很好，你去实现一下吧。</li></ul><h4 id="第一个bug"><a href="#第一个bug" class="headerlink" title="第一个bug"></a>第一个bug</h4><ul><li><p>很快你会碰到了第一个bug</p><ul><li>第一个错误：监听错了对象</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b7729186ef.png" alt="监听错了对象"></p></li></ul><p>正常来说，应该点击body控制台打印数字1，你点烂了你的罗技鼠标也没出来。为什么呢？</p><ul><li>我们使用<strong>border大法</strong>，看看它到底在哪</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b78f5de70a.png" alt="body的位置"></p><p>使用了红色border之后，发现body的高度太矮了，点击不到啊。</p><ul><li>你明白监听错对象了，那你就换了一个对象，监听文档呗，肯定没问题了。</li></ul><h4 id="第二个bug"><a href="#第二个bug" class="headerlink" title="第二个bug"></a>第二个bug</h4><ul><li><p>很好，你进入了第二个bug了</p><ul><li>第二个bug：你都能点击到，但是弹不出对话框了</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b78f8228e6.png" alt="第二个bug"></p></li></ul><p>根据图片 中的控制台可以发现，确实都点击到了，监听没问题，而且点击后，也是按照冒泡的顺序打印的结果。</p><ul><li>那为什么没有对话框了呢</li></ul><p><img src="https://i.loli.net/2018/01/14/5a5b7a6cac126.png" alt="正常的现象"></p><p>注释掉出问题的代码后，上图是正常的点击出现对话框啊，说明问题就出在注释的代码上。</p><ul><li>bug出现的原因就在于：默认冒泡的影响，当你点击的浮层那个<code>div</code>，之后，往 <code>body</code> <code>document</code>上冒泡，在<code>document</code>上立刻被杀死，display变为none，你做梦能看到 弹出框啊。</li></ul><p><img src="https://i.loli.net/2018/01/15/5a5c0e825be51.png" alt="阻止冒泡"></p><h4 id="修复第二个bug"><a href="#修复第二个bug" class="headerlink" title="修复第二个bug"></a>修复第二个bug</h4><p>我们既然知道了第二个bug产生的原因，那么我们阻止冒泡顺序</p><ul><li>解决的方案，不让其往上冒泡，自己管理。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clickMe.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  popover.style.display = <span class="string">'block'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'点击浮层了'</span>) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  popover.style.display = <span class="string">'none'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'点击文档了'</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>但是随之而来的是一个关于内存占用的问题，现在你是只有一个popover，只有一个函数，等你有了很多个popover，如果按照这个写法会有很多个函数，所以不能这么写，采用下面的写法，节省内存。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(clickMe).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(popover).show()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'show'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'one click'</span>)</span><br><span class="line">    $(<span class="built_in">document</span>).one(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'我觉的他不会执行'</span>)</span><br><span class="line">     $(popover).hide()            </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// $(wrapper).on('click', function(e)&#123;</span></span><br><span class="line"><span class="comment">//   e.stopPropagation()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'走到document啦'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>只有点击的时候才用，设置settimeout是为了让他异步，不至于立刻隐藏，产生第一个bug。</li><li>注意一下，jQuery的 <code>show()</code> <code>hide()</code></li></ul><p><img src="https://i.loli.net/2018/01/15/5a5cb3e12cfb0.png" alt="jQuery节省内存"></p><ul><li>当你点击按钮，只会打印图中这两句话，另外两句只有再次点击才会打印。</li></ul><p><img src="https://i.loli.net/2018/01/15/5a5cb4fa846d8.png" alt="具体的分析"></p><p>JS版本的节省内存的版本==================&gt;<a href="http://js.jirengu.com/pepetixevo/1/edit?html,js,output" target="_blank" rel="noopener">节省内存</a></p><p>jQuery版本的节省内存版本=================&gt;<a href="http://js.jirengu.com/zufemacina/1/edit?html,js,output" target="_blank" rel="noopener">jQuery节省内存</a></p><h4 id="对话框小三角的制作"><a href="#对话框小三角的制作" class="headerlink" title="对话框小三角的制作"></a>对话框小三角的制作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.popover&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  border: <span class="number">1</span>px solid red;</span><br><span class="line">  position: relative;</span><br><span class="line">  padding: <span class="number">10</span>px;</span><br><span class="line">  margin:<span class="number">10</span>px;</span><br><span class="line">&#125;</span><br><span class="line">.popover::before&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  content: <span class="string">''</span>;</span><br><span class="line">  top: <span class="number">5</span>px;</span><br><span class="line">  right: <span class="number">100</span>%;</span><br><span class="line">  border: <span class="number">10</span>px solid transparent;</span><br><span class="line">  border-right-color:red;</span><br><span class="line">&#125;</span><br><span class="line">.popover::after&#123;</span><br><span class="line">  content: <span class="string">''</span>;</span><br><span class="line">  border: <span class="number">10</span>px solid transparent;</span><br><span class="line">  position: absolute;</span><br><span class="line">  right: <span class="number">100</span>%;</span><br><span class="line">  top: <span class="number">5</span>px;</span><br><span class="line">  border-right-color: white;</span><br><span class="line">  margin-right: <span class="number">-1</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要利用<code>boder-right-color</code>以及两个伪元素。</p><p>浮层三角的实例=============================&gt;<a href="http://js.jirengu.com/zugepaneyu/3/edit?html,css,output" target="_blank" rel="noopener">demo</a></p><h3 id="冒泡的直观体现"><a href="#冒泡的直观体现" class="headerlink" title="冒泡的直观体现"></a>冒泡的直观体现</h3><p>点击一下会有惊喜的<a href="https://github.com/codevvvv9/bubble/blob/master/bubble.gif" target="_blank" rel="noopener">https://github.com/codevvvv9/bubble/blob/master/bubble.gif</a></p><p><a href="http://js.jirengu.com/geqihuboqe/1/edit?html,css,js,output" target="_blank" rel="noopener">冒个泡</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文探索一下Event的冒泡过程和初学遇到的几个小bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;DOM-Event概述&quot;&gt;&lt;a href=&quot;#DOM-Event概述&quot; class=&quot;headerlink&quot; title=&quot;DOM Event概述&quot;&gt;&lt;/a&gt;DOM Event概述&lt;/h3&gt;&lt;p&gt;Event接口是检测在DOM中的发生的所有事件，我们一直在用，而且从DOM的很早的版本就一直在用着。早期的网景(后来的火狐)和IE是各自为战，直到W3C一统江湖，DOM&lt;a href=&quot;https://www.w3.org/DOM/DOMTRhttps://www.w3.org/DOM/DOMTR&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;版本&lt;/a&gt;一路发展而来，经历了DOM-0(洪荒时代)、DOM-1(只有两章核心内容)、DOM-2(划时代的一个版本，我们学的Event就在这个版本，而且目前的用的也是这个版本)、DOM-3、DOM-4(草案阶段)。&lt;/p&gt;
    
    </summary>
    
      <category term="JS语法详解" scheme="https://codevvvv9.github.io/categories/JS%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="JavaScript" scheme="https://codevvvv9.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
