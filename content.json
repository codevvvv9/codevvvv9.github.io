{"meta":{"title":"WuShaoLin's Blog","subtitle":"悟已往之不谏，知来者之可追","description":null,"author":"shaolin-wu","url":"https://codevvvv9.github.io"},"pages":[{"title":"一只野生猿的故事","date":"2019-07-21T05:53:52.721Z","updated":"2018-11-30T11:08:04.000Z","comments":true,"path":"about/index.html","permalink":"https://codevvvv9.github.io/about/index.html","excerpt":"","text":"我是谁11年本科 进入交通工程专业 懵懂未知 15年读了研究僧 主攻智能交通方向 始知智能交通与计算机结合如此紧密 16年4月决定此生coding 彼时C Java javascript大杂烩 杂而不精 17年12月立志要在前端领域有所成就 18年6月底毕业正式进入前端开发领域 目前状态在五道口 同方威视 搬砖中 要到哪里去相信自己会成为最强的前端 之一 当蜘蛛网无情地查封了我的炉台 当灰烬的余烟叹息着贫困的悲哀 我依然固执地铺平失望的灰烬 用美丽的雪花写下：相信未来 当我的紫葡萄化为深秋的露水 当我的鲜花依偎在别人的情怀 我依然固执地用凝霜的枯藤 在凄凉的大地上写下：相信未来 我要用手指那涌向天边的排浪 我要用手掌那托住太阳的大海 摇曳着曙光那枝温暖漂亮的笔杆 用孩子的笔体写下：相信未来 我之所以坚定地相信未来 是我相信未来人们的眼睛 她有拨开历史风尘的睫毛 她有看透岁月篇章的瞳孔 不管人们对于我们腐烂的皮肉 那些迷途的惆怅、失败的苦痛 是寄予感动的热泪、深切的同情 还是给以轻蔑的微笑、辛辣的嘲讽 我坚信人们对于我们的脊骨 那无数次的探索、迷途、失败和成功 一定会给予热情、客观、公正的评定 是的，我焦急地等待着他们的评定 朋友，坚定地相信未来吧 相信不屈不挠的努力 相信战胜死亡的年轻 相信未来、热爱生命"},{"title":"category","date":"2019-07-21T05:53:52.726Z","updated":"2018-11-30T11:06:29.000Z","comments":false,"path":"categories/index.html","permalink":"https://codevvvv9.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-21T05:53:52.579Z","updated":"2018-12-04T13:21:25.000Z","comments":true,"path":"css/personal-style.css","permalink":"https://codevvvv9.github.io/css/personal-style.css","excerpt":"","text":"html.page-home { position: absolute; top: 0; left: 0; right: 0; bottom: 0; /*background-image: url('/images/bg.png');*/ background: linear-gradient(to left bottom, hsl(58, 100%, 85%) 0%,hsl(245, 100%, 85%) 100%); background-color: transparent; background-size: cover; background-position: center center; background-repeat: no-repeat; /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);*/ /*background-blend-mode: screen;*/ /*background: linear-gradient(to left, #5f2c82, #49a09d);*/ }"},{"title":"","date":"2019-07-21T05:53:52.721Z","updated":"2017-08-27T22:45:50.000Z","comments":true,"path":"js/md5.min.js","permalink":"https://codevvvv9.github.io/js/md5.min.js","excerpt":"","text":"!function(n){\"use strict\";function t(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)>5]|=128>95]>>>t%32&255);return r}function d(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t>5]|=(255&n.charCodeAt(t/8))>4&15)+\"0123456789abcdef\".charAt(15&t);return e}function v(n){return unescape(encodeURIComponent(n))}function m(n){return h(v(n))}function p(n){return g(m(n))}function s(n,t){return l(v(n),v(t))}function C(n,t){return g(s(n,t))}function A(n,t,r){return t?r?s(t,n):C(t,n):r?m(n):p(n)}\"function\"==typeof define&&define.amd?define(function(){return A}):\"object\"==typeof module&&module.exports?module.exports=A:n.md5=A}(this); //# sourceMappingURL=md5.min.js.map"},{"title":"project","date":"2019-07-21T05:53:52.723Z","updated":"2018-11-30T14:20:11.000Z","comments":false,"path":"project/index.html","permalink":"https://codevvvv9.github.io/project/index.html","excerpt":"","text":""},{"title":"search","date":"2019-07-21T05:53:52.723Z","updated":"2018-11-30T14:55:15.000Z","comments":false,"path":"search/index.html","permalink":"https://codevvvv9.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-21T05:53:52.722Z","updated":"2018-12-15T06:01:14.000Z","comments":false,"path":"tags/index.html","permalink":"https://codevvvv9.github.io/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2017-12-23T15:55:16.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"timeline/index-old.html","permalink":"https://codevvvv9.github.io/timeline/index-old.html","excerpt":"","text":""},{"title":"timeline","date":"2019-07-21T05:53:52.724Z","updated":"2018-12-15T06:55:58.000Z","comments":true,"path":"timeline/index.html","permalink":"https://codevvvv9.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"工作小结-2","slug":"工作小结-2","date":"2019-07-22T13:35:00.000Z","updated":"2019-07-22T15:31:28.822Z","comments":true,"path":"2019/07/22/工作小结-2/","link":"","permalink":"https://codevvvv9.github.io/2019/07/22/工作小结-2/","excerpt":"promise兼容IE11最近我开发的公司的竞赛网站被发现在IE11下排行榜无数据，但是在其他浏览器没问题，我然后打开控制台一看，发现了如下错误： 真是醉了，然后发现有三个可行的方案：","text":"promise兼容IE11最近我开发的公司的竞赛网站被发现在IE11下排行榜无数据，但是在其他浏览器没问题，我然后打开控制台一看，发现了如下错误： 真是醉了，然后发现有三个可行的方案： 直接采用polyfill 123在index.html中&lt;script src = \"https://cdn.polyfill.io/v2/polyfill.min.js\"&gt;&lt;/script&gt; 或 &lt;script type=\"text/javascript\" src =\"https://cdn.polyfill.io/v2/polyfill.min.js?features=es6\"&gt;&lt;/script&gt; 手写js脚本判断一下 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; function isIE() &#123; if (!!window.ActiveXObject || &quot;ActiveXObject&quot; in window) &#123; return true; &#125; else &#123; return false; &#125; &#125;if (isIE()) &#123; var script = document.createElement(&apos;script&apos;); script.type = &apos;text/javaScript&apos;; script.src = &apos;js/bluebird.min.js&apos;; // bluebird 文件地址 // http://cdn.jsdelivr.net/bluebird/3.5.0/bluebird.min.js document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);&#125;&lt;/script&gt; 安装新的依赖 123456781、npm install --save babel-polyfill2、在main.js文件的顶部引入 import \"babel-polyfill\"3、在build目录下webpack.config.js文件设置入口改为如下（如果你的项目用的是脚手架，在在build目录下webpack.base.config.js文件更改入口）model.exports=&#123;entry:&#123; app： [\"babel-polyfill\",'./src/main.js'] &#125; Vue提倡的单项数据流在写vue组件的过程中，经常会遇到这样的情形：子组件需要的参数以props属性里面的prop来获得，父组件通过具名的prop来把子组件需要的内容传递给子组件，而且Vue提倡数据流的方向只能由父组件流向子组件。当父组件的数据发生变化时去通知子组件更改相应的属性，而不能反过来，子组件的变化影响到父组件，这种行为是被禁止的，因为这样会导致数据混乱不易于定位错误。 虽然经常写着写着子组件就想图省事，子组件直接去改变父组件的状态了，但是会报错如下： 那么，子组件为了更改父组件的状态，Vue提供了两种常见的解决办法： 通过data中的变量将需要的prop初始化 123456props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 使用需要处理的prop来定义一个计算属性computed 123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 当然子组件要想和父组件去进行通信，也可以简单的采用如下方式 $emit触发事件，父组件接受子组件发布的事件，然后就顺理成章的在父组件里面修改自身的变量了。 关于node中的module.exports、exports和ES6中的 export、export defaultnode中，每个文件都被视为一个独立的模块，对外只暴露一个接口(其实就是一个对象)：module.exports module代表当前模块，它的exports属性负责与外界进行交流，加载一个外来的模块就是加载该模块的module.exports属性的内容。 123456789101112// add.jsvar temp = 1;var addNumber = function (value) &#123; return value + 1;&#125;;module.exports.temp = temp;module.exports.addNumber = addNumber;// 另一个js文件引用了add.jsvar add = require('./add.js') console.log('add is', add) // add is &#123; temp: 1, addNumber: [Function: addNumber] &#125;console.log(add.temp) // 1console.log(add.addNumber(1)) // 2 通常为了方便，每个node模块头部有默认的一句话：var exports = module.exports 为了方便可以直接在exports对象上加方法，也可以实现对外的改变，但是不可以将exports变量指向其它变量，一旦这样做了会切断exports和module.exports之间的联系。 但是，node采用了CommonJs规范，ES6采用新规范import和export (对应于require和exports) 123456789//ES6 example.jsvar temp = 'temp'export &#123;temp&#125; //同样的，export出来的只是一个接口，必须有大括号，除非使用下面介绍的export default//export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。通俗来讲，不能使固定的值，应该是一个变量或者一个函数// use exampleimport &#123;example&#125; from './example.js'console.log(example.temp) // 'temp'// 同样的，ES6也有默认的export写法export default var temp = 'new'","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"think","slug":"think","permalink":"https://codevvvv9.github.io/tags/think/"}]},{"title":"移动端-响应式布局初涉","slug":"移动端-响应式布局初涉","date":"2019-06-08T07:39:12.000Z","updated":"2019-06-08T07:45:36.307Z","comments":true,"path":"2019/06/08/移动端-响应式布局初涉/","link":"","permalink":"https://codevvvv9.github.io/2019/06/08/移动端-响应式布局初涉/","excerpt":"响应式布局五个基本点 媒体查询 移动端对应的设计图 隐藏某些在PC端需要的元素 添加meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; 交互方式与PC端不同，没有hover、滑动效果、滚动条、resize。替代的是touch和使用两点坐标来模拟滑动效果。","text":"响应式布局五个基本点 媒体查询 移动端对应的设计图 隐藏某些在PC端需要的元素 添加meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; 交互方式与PC端不同，没有hover、滑动效果、滚动条、resize。替代的是touch和使用两点坐标来模拟滑动效果。 媒体查询通常响应式布局有几个尺寸，320px（small）、375px（medium）、425px(large)、768px、1024px、1440px、2560px 使用style标签进行查询1234567891011121314151617181920212223242526@media (max-width: 320px) &#123; body &#123; background: red; &#125; &#125; @media (min-width: 321px) and (max-width: 375px) &#123; body &#123; background: green; &#125; &#125; @media (min-width: 376px) and (max-width: 425px) &#123; body &#123; background: blue; &#125; &#125; @media (min-width: 426px) and (max-width: 768px) &#123; body &#123; background: purple; &#125; &#125; @media (min-width: 769px) &#123; body &#123; background: orange; &#125; &#125; 使用link标签加载所需的尺寸的css1&lt;link rel=\"stylesheet\" href=\"./medium.css\" media=\"(min-width: 321px) and (max-width: 375px)\"&gt; 上述标签的意思就是：只有在屏幕尺寸在321px-375px之间的时候medium.css才会生效 移动端单独的设计图要想做移动端的适配，设计图必须单独给一份。 隐藏某些元素手机的屏幕较PC端小，所以容纳的可视区域必然小，例如导航栏在PC端时可以完全显示，但是移动端只能显示一个按钮，不能完整的显示。 手机端不同于PC端的操作手机端明显没有hover效果，采用click来模拟 12345678910111213141516// html部分&lt;button id=\"menu\"&gt;菜单&lt;/button&gt; &lt;ul id=\"nav\" class=\"nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;// css部分.nav &#123;display: none&#125;.nav.active &#123;display: block&#125;//js部分menu.onclick = function() &#123; nav.classList.toggle('active')&#125; 上述代码中classList具有toggle方法，如果有某个类名就去掉，没有这个类名就加上。 js代码不应该去控制样式，应该只改变状态而已，样式改变交给css去控制。 viewport的作用传统的移动端开发时会进行缩放，以国内主流的尺寸980px来进行缩放，如果不加viewport标签，可以通过以下方式来查看屏幕的宽度。 1document.documentElement.clientWidth() // 980px 一些经常忘的小知识清除浮动12345.clearfix::after &#123; content: \"\"; clear: both; display: block;&#125; 绝对定位1234position: absolute;top: 10px;left: 20px;// 某个元素绝对定位了，位置是相对于它的某个position: relative的父元素","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"https://codevvvv9.github.io/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://codevvvv9.github.io/tags/CSS/"}]},{"title":"编程思想杂谈","slug":"编程思想杂谈","date":"2019-01-09T15:53:35.000Z","updated":"2019-04-04T15:50:05.881Z","comments":true,"path":"2019/01/09/编程思想杂谈/","link":"","permalink":"https://codevvvv9.github.io/2019/01/09/编程思想杂谈/","excerpt":"","text":"面向对象 面向对象是老生常谈的一个话题了。 可以自定义数据类型，工具类、实体类、将代码细节进行封装，易于编程。 用函数来编程 首先参数一定要验证 把逻辑实现，并拆分代码 设计模式 单例 适配器 IOC 工程模式","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"前端之外","slug":"前端之外","permalink":"https://codevvvv9.github.io/tags/前端之外/"}]},{"title":"一个理想主义者的独白","slug":"一个理想主义者的独白","date":"2018-12-31T12:28:44.000Z","updated":"2019-01-01T04:08:57.000Z","comments":true,"path":"2018/12/31/一个理想主义者的独白/","link":"","permalink":"https://codevvvv9.github.io/2018/12/31/一个理想主义者的独白/","excerpt":"","text":"这是最好的时代，也是最差的时代。 为什么是2018从来没写过年终总结，好像还挺遗憾的，活的不明不白的，一年就没了。 正如鸡汤文化宣扬的那样，这可是8120年了啊，10年前已经不是1998，而是2008年了。人们总是过分的相信自己的记忆，忽略了时间的力量，事如春梦了无痕，苟不记之笔墨，未免有辜彼苍之厚。 那么，这种仪式感的东西就从2018年12月31日开始吧。 暂且从以下几个方面给2018一个交代吧： 毕业 就业 健身 不安分的思想 2019年展望 终于毕业了读研后，发现论文真难写，读了一些交通论文后，彷徨过很多个夜晚，有些事情适合闭上眼睛慢慢咀嚼，那是不可与别人言说的经历。 慢慢的我开始明白确实不是写论文的料，条条框框的有束缚性的文章真是看着就痛苦，早早断了写论文这条道路。开始摸索自己到底该干啥，适合做什么这些都是小插曲了，每个人都应该有过这种类似的迷惘的经历，只不过大家都选择了同一个方式去面对——默默承受，表面看起来都是平静如水，内心早已汹涌澎湃，每天仍然看似没心没肺的玩乐，转变的阵痛就这么一点点过去了。 2018年关乎毕业论文，好担心过不了盲审，论文进展特别慢。开年的那几个月可以用一句话来总结——做尽此生荒唐事。 那几个月就是憋了一篇毕业论文，担惊受怕中也算是蓝袍加身了。 这一部分经历最值得我回忆的是有几个好舍友，做的饭很好吃，可以发发牢骚，而他又很会安慰人的那种；自诩智能交通实验室的师弟师妹们，晚上集体翘了老张去看头号玩家，回来恶补闪灵，看昆池岩，一起吹牛、吐槽…… 我所焦虑的事本身没有任何价值，反而会阻碍迈向未来的脚步，能够让我走向未来的，是坚定的信心、直面现实的勇气和直面未来的行动。 工作 我是谁 我从哪里来 我要到哪去 经典的哲学三问，我倒是能回答相近的问题——我到底该干啥，3-5年内，不谈时间期限的人都是耍流氓。 关于我为什么选了现在这条路，那就是另一个故事了。故事很曲折，不过结果是好的。 找工作通用的模板是： 我喜欢，不需要理由。 我不喜欢，但是钱给的多。 我不喜欢，钱也给的不多，但是真的轻松。 通常情况会走第二条，但是我推荐第四条路，曲径通幽——行业外试错，去尝试，去尝试，还是去尝试。 没有一条通往远方的路，不充满误解与委屈。 ​ —— 致敬拉钩招聘 知道什么是自己想要的，知道该用什么方式实现梦想，我曾经焦虑的问题也有了答案。我不知道命运会把我带到何方，但是我一直会用坚持去呵护好不容易找到的东西。 这个时代一直在贩卖焦虑，幸好我是个理想主义者。 找到了珍贵的东西，宁愿像个傻逼一样去守护。 进京确定要做程序员之后，从北京、上海、杭州、南京四个城市中我选择了帝都作为职业生涯的第一站，是一炮而红还是折戟沉沙，都已经没有退路，因为我豪赌了7年光阴，愿赌不服输。 如果你有梦想，就要去捍卫它。那些一事无成的人想告诉你你也成不了大器。 人生啊，它有时像一个孩子，我慢慢学会哄他，让他开心，让他知道世界不是只有黑白，也有赤橙黄绿青蓝紫，也有由我定义的乱七八糟的颜色，经历过一些事情才会成长，那些经历一定会包括好的坏的，遇到坏的时候，或许会收获更多，很多事情在一帆风顺的时候，永远发觉不了。 这半年，ofo黄了，锤子被打回锤子的原型。吸了比以前多的雾霾、挤了比以前人多的地铁。认识了几个工作、生活中的朋友，让北漂这个词变得有点温暖。 学到了很多以前没见到的知识，知道有些工作是要那么做的，代码是要那么写的。 每天总有新的收获，工作里没有遇到五彩斑斓的黑、也没有遇到根据手机壳改变主题颜色的需求，团队氛围极好，提升了很多东西，我知道这些气质会潜移默化的影响我，现在更多的是退居到幕后。 原来现在前后台的交互是只通过接口来交流，原来还有叫restful的思想支配着web开发。 编程的思想很重要。框架会过时、语言会被时代淘汰，但是思想永存，不断的敲代码是要慢慢体会背后的思想，要做平凡的思考者，停下来思考。 不再执着于系统化学习的思维方式。我一直接受的教育是从0-1，系统的掌握来龙去脉，入门的、基础的、进阶的、高级的，但是对于高度抽象的计算机科学来说，这种思维方式有时会耽误很长时间，这个抽象的概念没搞明白，却又引入了另一个抽象概念来解释，最后都忘记了自己想研究哪个知识了。先把工作快速完成，有时间再去研究，但是该补的基础一点不能省，选择了这个未知的领域，探索的痛苦必须自己去承受。 正在使用的技术必须精通，要做目前承担工作的专家，也要发现缺陷和不足！ 抽时间去学习那些未来主流、逐渐被市场认可的技术。 不要停止学习新知识。保持视野的开阔，不能闭门造车，了解之后多思考，哪怕有一点点的感悟。 事情不是二元的，不是非对即错的。我以前虽然知道，但不承认，经历过一些事情之后，体会越发的强烈。包容比固执已见更合适而已。 身体上了岁数，熬夜多了越发的体会到了身体的重要性，作为家庭的支撑，不好好对自己的身体负责，有再多的价值也体现不出来，此处应该有鸡汤 世界上最大的不公平是每个的起点不同，但是最大的公平是每个人的终点也不同。 很喜欢keep的广告词，如果没有信仰，就将运动当做信仰。 对于运动来说，坚持显得尤为重要。以前我也觉得要抽时间锻炼身体好难啊，终于有一天腰酸背痛、屁股疼，我开始郑重的对待这个话题，让运动融进生活。 每天哪怕再晚，只要抽出10分钟做一组keep就好，时间不用太多，免得让我产生花太多时间给健身的负罪感。 一周不用每天都练。不要强度太大，让自己产生压力，反而成了一种负担。一周4-7练即可，找个本子记下来最好了。 找到一种运动，它可以给你自信，让你思考，让你乐观。这件事如果用心去做，效果奇佳，其实不论什么事情，用心去做，结果都不会太差，而对于我来说，这个运动就是跑步 关于跑步跑步这项运动，是一项古老的运动，奔跑是人类的本能。 感谢第二次搬家，让我在北京可以愉快的跑步，最开始我是在门口的清河边跑步，直到那个仿佛宿命般的那个夜晚，我突破了我自己。 那个夜晚正如朱自清先生描述的的月光如流水一般，静静的泻在这一片叶子与花上。薄薄的清雾浮起在荷塘里面。，我定下了每周至少长跑10公里的计划，后来长跑便去了奥森公园开启了长跑之旅，短跑仍在门前的清河边，还是很喜欢那条河，像极了荷塘月色，塘中的月色并不均匀，但光与影有着和谐的旋律，如梵婀玲上奏着的名曲，夜晚静静的听着河水缓缓的流动，感觉棒极了。 长跑时间很长，这也给了我思考的时间，慢慢的改造了我的一些思维。 不要急于求成。这个毛病是我一直以来的问题，包括我在寻找就业方向的失败经历，都是惨痛的。循序渐进的提高跑量，不要长时间没有跑了，一下子就上强度，很容易受伤不说，还让我产生一种这运动很累，没有任何美感。于是我改进了以前的跑步策略，在慢慢的跑步，跑到心情通畅时、身体状态完美时开始提速，去享受长跑，享受带来的乐趣，缓解一天的劳累。 保持自己的节奏。其实这条和上一条本质差不多，但是这一条带有一点宠辱不惊的色彩，我跑步时被后来者超过，总是不服的，急于把它超过，打乱自己的节奏，会变得很累，而如果保持自己的节奏，状态极好时主动地取决调节节奏，再去超越。 坚持跑步。不坚持的理由有很多很多，但是坚持的理由就只有一个，喂，你喜欢跑步吗，去跑步吧。坚持做点什么，平凡的生活，可能会不一样吧。 跑步的提高很多时候并不来源于跑步自身。我停留在6公里处好久，跑多了膝盖会酸，我知道继续单纯的跑步会伤害。这个时候跑步跑步这件事情本身已经不能再提高我的里程了。我查阅资料，开始强化核心力量，核心改造，突破了10公里，可以稳固的在这区间跑步。我联想到其他方面，当这件事情本身已经不能提高的时候，或许是其他方面的突破才能刺激这件事情。它山之石可以攻玉。 要做自由的风，快乐的奔跑～ 不安分的思想这一年又把之前看的小说刷了几遍，依然热血澎湃，引人遐想，会情不自禁的笑，也会回想起以前自己稚嫩的小说。 不管怎么样吧，这些奇思妙想我还是想让他们活下去，让灵感留住，给2019年留下一个巨大的任务～ 2019的展望 工作继续精益求精。深入自己涉及的领域，实践未来流行的主流技术。 跑步每周10公里，争取年度突破400公里。参加1-2场半马。 至于什么是理想主义者，在这个安静或不安静的夜晚，打开笔记本，于是一切都有了答案。 生命不息，奋斗不止，2018，再见～","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"2018总结","slug":"2018总结","permalink":"https://codevvvv9.github.io/tags/2018总结/"}]},{"title":"Deepin配置Java环境","slug":"Deepin配置Java环境","date":"2018-12-29T13:56:32.000Z","updated":"2018-12-29T14:17:07.000Z","comments":true,"path":"2018/12/29/Deepin配置Java环境/","link":"","permalink":"https://codevvvv9.github.io/2018/12/29/Deepin配置Java环境/","excerpt":"","text":"下载JavaSe开发包 Oracle官网下载，地址 配置环境变量 下载完之后，解压，记住目录 12345678//在你的.bashrc 或者 .zshrc，以及 /etc/profile添加如下代码export JAVA_HOME=/home/wsl/Documents/jdk1.8.0_191export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH// etc要想生效还要sourcesudo vim /etc/profilesource /etc/profile 问题 deepin有内置的openJDK，会影响Oracle的JDK 1234567//查看版本多了一个_JAVA_OPTIONSjava -version Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gaspjava version \"1.8.0_05\"Java(TM) SE Runtime Environment (build 1.8.0_05-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode) 多余文件的文本内容 终极解决方案 12//在上面配置的环境变量前面添加unset _JAVA_OPTIONS","categories":[{"name":"LearnJava","slug":"LearnJava","permalink":"https://codevvvv9.github.io/categories/LearnJava/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codevvvv9.github.io/tags/Java/"}]},{"title":"记录用户状态","slug":"记录用户状态","date":"2018-10-21T14:56:12.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/10/21/记录用户状态/","link":"","permalink":"https://codevvvv9.github.io/2018/10/21/记录用户状态/","excerpt":"今天主要记录本周开发中遇到的一个问题——记录用户状态。 问题的来源我们做的产品是某款安检产品的数据集中管理，主要是为了处理AI所需的样本，我们通过web进行标注任务、数据传输任务、设备型号、设备类型、存储源、传输协议等等的管理与分配，以上各种东东的管理（各种简单的复杂的增删改查）是我负责。","text":"今天主要记录本周开发中遇到的一个问题——记录用户状态。 问题的来源我们做的产品是某款安检产品的数据集中管理，主要是为了处理AI所需的样本，我们通过web进行标注任务、数据传输任务、设备型号、设备类型、存储源、传输协议等等的管理与分配，以上各种东东的管理（各种简单的复杂的增删改查）是我负责。 那是一个风和日不丽的周一，leader说客户（其实就是某个人脸识别的兄弟部门）需要一项训练集的管理web，毫无疑问的，这个任务是我的。AI嘛，说白了就是不断训练数据，获得模型，再训练，再通过新的数据进行测试，根据结果再通过新数据训练，再得到算法模型，再测试，周而复始的调参。所以训练集必须要好好管理啊。 那么，当我创建一个新的训练集的时候，训练集本身包含5个自有属性，还要通过一个数据包的查询接口来获得的数据包，以上的5个自有属性+这个数据包（不知道有多少，反正是通过另外三个查询条件获得数据包内容）组成一条数据集。 这条训练集数据可以被编辑、被删除、被导出。 编辑的业务场景是：点击编辑时首先通过获得当前项训练集的id的接口来回显数据库中存储的数据，而训练集只有那五个自有属性可以被修改，数据包的内容以及创建时的三个查询条件（也就是创建时的查询状态）不可修改。 基于上面的业务场景，我添加一条新的训练集的时候，该训练集的五个自有属性+数据包+查询状态都应该存储到数据库中。 而一开始与我对接的java后台的数据库中表没有对应字段去存储查询状态，我与之进行第一轮交涉，经过思考，他觉得这样太复杂，因为这个查询条件没有单独的id去存储，需要再建新的数据库表，希望前台来处理这个状态，因为通过数据包的查询接口获得了表征查询获得的所有数据包的一串标识码和数据包总数，他认为我可以通过一个对象记住，然后编辑时再把它关联回去。既然后台要建表，还要建新的实体类，比较复杂，那我前台看看处理下。 可是，我一思考，这个查询条件要与该条训练集绑定才能保证编辑该条训练集的时候回显正常 的数据，也就是说要把查询状态与该训练集的id关联起来， 那么问题来了，添加的时候，并没有id，此id是往数据库存储时后台自动生成的，前台也没法拿到这个id，那么我也没法通过一个对象把查询状态+创建该训练集的id存储起来，好像前台也没法处理。 可是这个任务必须要做啊，我和后台的小伙伴两个萌新大眼瞪小眼。 问题的解决没办法了，去跟leader商量了，结果人家云淡风轻的说： 后台在表里面建个searchCondition字段，给它个长点的字符串格式。 前台创建时把查询条件包装成一个大字符串，数据库就存这个大字符串就行了。 编辑时前台拿到那个长字符串，再解析，分别把数据回填到查询状态的form里面就行了。 听完之后我俩回来后，讨论了一下就开始干了，有了明确的方向干活就是快啊。 改造添加时的方法123456789101112131415if (action === \"add\") &#123; let searchCondition = &#123; businessType: this.form.businessType, //时间戳处理，原始处理是new Date().getTime(),应使用其他方法去处理时间戳的问题 uploadTime: this.form.uploadTime, plotTask: this.form.plotTask &#125; axios.post(`$&#123;base_url&#125;/trainSet/...`, &#123; //其他代码 searchCondition: JSON.strinify(searchCondition) &#125;) .then(res =&gt; &#123; //代码... &#125;)&#125; 编辑时的方法123456789101112131415showFormData(id) &#123; let val = &#123; id = this.form.id, //... &#125; axios.get(`$&#123;base_url&#125;/trainSet/getTrainSetById?id=$&#123;val.id&#125;`) .then(res =&gt; &#123; let data = res.data.data let searchConditionJSON = JSON.parse(data.searchCondition) this.form.businessType = searchConditionJSON.businessType //... //或者直接用解构，通过查询条件再调一遍查询的接口即可获得所有的数据包以及总数目 &#125;) &#125; 感悟具体问题还是没法深入到代码层面去分析，对于数据库的知识比较匮乏，不知道如何去抽象业务场景。 原来JSON的基本玩法这么玩。 多思考，多请教，多记录。","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"think","slug":"think","permalink":"https://codevvvv9.github.io/tags/think/"}]},{"title":"虚拟DOM","slug":"虚拟DOM","date":"2018-09-19T15:46:07.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/09/19/虚拟DOM/","link":"","permalink":"https://codevvvv9.github.io/2018/09/19/虚拟DOM/","excerpt":"学习底层的虚拟DOM原理 二话不说，直接上代码 基本的代码如下：","text":"学习底层的虚拟DOM原理 二话不说，直接上代码 基本的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144let nodeData = &#123; tag: 'div', children: [&#123; tag: 'p', children: [&#123; tag: 'span', children: [&#123; tag: '#text', text: 'wushao.xyz' &#125;] &#125;] &#125;, &#123; tag: 'span', children: [&#123; tag: '#text', text: 'wushao.com' &#125;] &#125; ]&#125;/* 等同于这段html代码&lt;div&gt; &lt;p&gt; &lt;span&gt;wushao.xyz&lt;/span&gt; &lt;/p&gt; &lt;span&gt;wushao.com&lt;/span&gt;&lt;/div&gt; *//** * ES6的写法 */class VNode &#123; constructor(tag, children, text) &#123; this.tag = tag this.children = children this.text = text &#125; render() &#123; if (this.tag === '#text') &#123; return document.createTextNode(this.text) &#125; let el = document.createElement(this.tag) this.children.forEach(vChild =&gt; &#123; el.appendChild(vChild.render()) &#125;); return el &#125;&#125;/** * 创建虚拟dom节点的简便函数 * @param &#123;标签名&#125; tag * @param &#123;子标签&#125; children * @param &#123;文本值&#125; text */function v(tag, children, text) &#123; //如果没有tag,第二个参数是字符串的话 if (typeof children === 'string') &#123; text = children children = [] &#125; return new VNode(tag, children, text)&#125;/** * ES5的写法 * @param &#123;*&#125; tag * @param &#123;*&#125; children * @param &#123;*&#125; text */function vNode(tag, children, text) &#123; this.tag = tag this.children = children this.text = text&#125;vNode.prototype.render = function () &#123; if (this.tag === '#text') &#123; return document.createTextNode(this.text) &#125; let el = document.createElement(this.tag) this.children.forEach(vChild =&gt; &#123; el.appendChild(vChild.render()) &#125;); return el&#125;//举例说明let vNode1 = v('div', [ v('p', [ v('span', [v('#text', 'wushao.xyz')]) ]), v('span', [ v('#text', 'wushao.com') ])])console.log(vNode1);const root = document.querySelector('#root')root.appendChild(vNode1.render()) //把虚拟的dom映射进了真实的dom结构里面let vNode2 = v('div', [ v('p', [ v('span', [v('#text', 'wushao.xyz')]) ]), v('span', [ v('#text', 'wushao.com') ]), v('span', [ v('#text', 'wushao') ])])document.querySelector('#change').onclick = function () &#123; root.innerHTML = '' root.appendChild(vNode2.render())&#125;/** * 比较前后两个节点 * @param &#123;要比较的DOM结构&#125; parent * @param &#123;旧的节点&#125; newVNode * @param &#123;*新的节点 oldNode * @param &#123;索引&#125; index */function patchElement(parent, newVNode, oldNode, index = 0) &#123; if (!oldNode) &#123; //新增元素 parent.appendChild(newVNode.render()) &#125; else if (!newVNode) &#123; parent.removeChild(parent.childNodes[index]) &#125; else if (newVNode.tag !== oldNode.tag || newVNode.text != oldNode.text)&#123; parent.replaceChild(newVNode.render(), parent.childNodes[index]) &#125; else &#123; for (let i = 0; i &lt; newVNode.children.length || i &lt; oldNode.children.length; i++) &#123; patchElement(parent.childNodes[index], newVNode.children[i], oldNode.children[i], i) &#125; &#125;&#125; 可以在HTML中直接测试12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;虚拟DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;/div&gt; &lt;button id=\"change\"&gt;change&lt;/button&gt; &lt;script src=\"./v-dom.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Vue的学习","slug":"Vue的学习","permalink":"https://codevvvv9.github.io/categories/Vue的学习/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://codevvvv9.github.io/tags/Vue/"}]},{"title":"SEO不完全指北","slug":"SEO不完全指北","date":"2018-09-02T13:49:34.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/09/02/SEO不完全指北/","link":"","permalink":"https://codevvvv9.github.io/2018/09/02/SEO不完全指北/","excerpt":"这个周末学习了一下关于把个人站点进行SEO的初级操作，觉得很有意思，以此文记录一下，如果你也使用HEXO那将会有帮助。 SEO指 Search Engine Optimization，意指搜索引擎优化的意思，通过必要的网站结构的设计让spider机器人爬取有用的数据，提高网站在搜索时的排名与在相关领域的权重。 百度站长国内的话，首推百度站长，前提是你要有自已 的域名了。","text":"这个周末学习了一下关于把个人站点进行SEO的初级操作，觉得很有意思，以此文记录一下，如果你也使用HEXO那将会有帮助。 SEO指 Search Engine Optimization，意指搜索引擎优化的意思，通过必要的网站结构的设计让spider机器人爬取有用的数据，提高网站在搜索时的排名与在相关领域的权重。 百度站长国内的话，首推百度站长，前提是你要有自已 的域名了。 添加站点按照下图操作 前面两部基本没问题，注意一下第三步的操作： 通常选择文件验证和CNAME验证，我选择的是文件验证，这里要把百度的验证文件放到你的域名的根目录下，具体的在这里指：source目录下，要注意如果是html文件要使用如下代码处理，防止后续部署时把html文件给处理了。 123layout: false---FZKjy3o3f6 //你的验证文件的内容，显然百度分配给每个人都不一样 添加站点地图 首先安装两个插件 12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 修改项目根目录下的_config.yml 的URL 1234# URLurl: http://wushao.xyz //你的个人站点的名字root: /permalink: :year/:month/:day/:title/ //这里将会在后续的URL持久化章中优化 进行如下代码的部署，在根目录下的public目录生成sitemap.xml 和 baidusitemap.xml 1hexo g -d //相当于hexo generate 然后 hexo deploy 把上面生成的sitemap.xml提交给百度，按照第一章的做法把站点添加到百度后，按照下图的方式提交 这里有两种方式提交，很明显选择自动提交——主动推送的方式，注意这里的token，很重要 使用如下代码完成主动推送 1234567891011121314151617//1.先安装插件npm install hexo-baidu-url-submit --save//2.在根目录下的_config.yml 添加baidu_url_submit属性baidu_url_submit: count: 100 # 提交最新的一个链接,最新的100个链接，想写几个写几个 host: wushao.xyz # 在百度站长平台中注册的域名 token: # 请注意这是您的秘钥，就是上图模糊处理的那个所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在public目录下//3.修改根目录下的_config.yml 的deploy属性,注意有两个deploy时的格式！！！# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: github: 你的github coding: 你的coding- type: baidu_url_submitter 下面介绍几个优化爬取的方法 添加robots.txt这里是为了告诉搜索引擎哪些可以爬取哪些不可以爬取，在source目录下添加robots.txt，文本内容如下 12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /posts/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://你的站点/sitemap.xml //Sitemap: https://你的站点/baidusitemap.xml Url持久化还记的_config.yml里面关于url的描述嘛。permalink属性中的/决定了你的url有几级，通常引擎只会爬取三层，而且对于汉字的处理不完美，可是你的文章名字难免会有汉字，所以这里要进行必要的转化。 12345# # URL# ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: 你的站点名字root: /permalink: :year/:month/:day/:title/ //优化处 借助hexo-abbrlink插件，感谢大神的插件 123456789101112npm install hexo-abbrlink --save// Modify permalink in config.yml file:permalink: posts/:abbrlink/# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex//部署完之后所有的url如下所示http://wushao.xyz/posts/6ed52419.html //6ed52419这个就代表你原来的名字http://wushao.xyz/posts/7a43570f.htmlhttp://wushao.xyz/posts/7b3b172b.htmlhttp://wushao.xyz/posts/77ac3545.html 此时你会发现你以前的的文章标题会有变化 Google站长Google的方便多了，直接google站长，然后进Search console,添加属性就是添加个人站点的意思，后续步骤和上面一样，但是收录的速度快多了。","categories":[{"name":"前端之外","slug":"前端之外","permalink":"https://codevvvv9.github.io/categories/前端之外/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"https://codevvvv9.github.io/tags/SEO/"}]},{"title":"最强的团队","slug":"最强的团队","date":"2018-08-31T13:33:32.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/08/31/最强的团队/","link":"","permalink":"https://codevvvv9.github.io/2018/08/31/最强的团队/","excerpt":"所在的团队入职已经有一个半月了，目前的团队氛围对于我这个新人来说，就一句话如鱼得水，感谢机缘，能让我在转行的第一份工作中遇见这个团队，而我也会为了这个团队努力工作，让前端的大旗迎风飞扬。","text":"所在的团队入职已经有一个半月了，目前的团队氛围对于我这个新人来说，就一句话如鱼得水，感谢机缘，能让我在转行的第一份工作中遇见这个团队，而我也会为了这个团队努力工作，让前端的大旗迎风飞扬。 团队组成由4个java后端、1个Python后端、3个前端、1个架构师。 java四人组构成：3个主力web服务，使用sprintboot等先进技术， 1个使用各种大数据技术的java小头目。Python后端主要负责系统的基础架构，比较高深。 Python大牛是南京土著，开车贼梦，公认的飙车王，宽高比几乎相同，哈哈，当然了，很nice的队友，给我普及了很多南京的知识，同时多线支持南京的机器学习计算平台的开发，强！！！ 接下来重点介绍前端阵容，前端项目毫无疑问使用Vue全家桶技术，由两位女生和我组成，两位女生和我年纪一样，但是我读研期间人家已经夯实好了前端技术，她俩人都超级好，总是结伴讨论问题，对我的vue提升帮助很大，尤其是小leader——玥之魔法师，她炒鸡耐心，总结：炒鸡nice的小组织。 架构师是从业10多年的大牛，虽然不懂前端，所以就由玥之魔法师组织，但是他的宏观把握力、带队能力、沟通写作、各个部门协调资源、做人做事的风格，让我叹为观止，原来程序员也可以这么风趣幽默，给团队成员极大的自由空间，后面我将重点讲讲大佬的故事。 说实话，以我目前的能力来说，遇到这么一个团队，对于刚转行过来的人来说，有幸也有不幸。幸的是：有充足的时间去丰富自己的js技能，打磨我的vue技能，极大的空间去发掘潜力，不幸的是：没有紧迫的互联网急速迭代的产品，客户都是固定的。不过后来也想通了，当下选择的就是最棒的，坦然接受这个角色，做好自己，很怕自己又折在好高骛远的毛病上。18年的上半年，浪费了很多时间，导致自己在算法数据结构、计算机网络的学习上欠缺了相当多，这是后期要与js一起恶补的方向。 这段时间的总结和未来正如我的slogan一样，道阻且长，以梦为马，不忘初心。👊 学会解放生产力还记得我前面说的大佬吗，他在工作两年时就已经带领一个8人团队做出一番大事了，他也鼓励我们在工作到2-3年时要刻意的去培养管理的技能与意识，而不仅仅是敲代码。 善假于物也 使用jira。大佬鼓励我们使用jira进行项目的各个任务的分解，同时进行任务流的分解，不同的任务流分配不同的时间比如3w，2h，1d，让整个团队看到各自的时间分配与做的东西，这不就是各大畅销书提倡的时间管理技巧嘛，例如西红柿时间管理法、四象限时间管理法，从来没有想到在程序员生涯中会用到这些，我以为就是坐那敲代码，调bug而已。可能其他大厂也都用的各种管理技巧，可能比我们的很高级，但是我的体会是：入行以后就要专业，你要体现出你是专业的，不是学校、或者二流程序员做事的风格，你要有一个专业的做事风格，告诉别人，我是一流的技术人员，所以团队的第一天就这么要求，真的对我的职业生涯有很大的帮助与启发。 及时提出帮助。大佬每日早晨给我们开会，他使用邮件做了一个定时发送，他起的名字是 “每日站会”，每天早晨傍晚都会收到它。这个定时事件流或者会议的功能，早就有了，但是从来没用过的团队大有人在，工具就摆在那里，不会用或者不擅于利用，这真是极大的浪费啊。我们站会的精髓是：“昨天做了什么，今天做什么，需要什么帮助”，我最大的体会是第三点——需要什么帮助。人，都有一个毛病，觉得自己很牛，多花点时间总会搞出来，后来人类总结了一个成语叫自以为是，尤其在技术人员中，这一点尤甚，工作几年后，技术有了进步，就一头扎进代码，出不来了，明明可以请教一下就解决了，非要自己研究，导致莫名的加班，假如此时，你及时向上级请求这个帮助，提高了处理效率，还能节省时间研究其他的东西，真实的代码产出率也会上升。当然上述的问题是指浅层次的疑难问题，像复杂的业务逻辑、源码分析，还是要自己深入理解，花很大气力的，至于上述的及时提出帮助具体指什么，聪明人读到这里应该已经懂了。所以如果没有懂，具体场景具体分析也应该作为一项必备技能。大佬的这个要求每天都会让我反思，我是否可以借别人的帮助，一起解决问题，提高协作能力。 上述的两点可以简单的归纳为一句：善假于物也，古人的大智慧历久弥新啊。 君子生非异也，善假于物也。 集腋成裘提早规避错误，每日提交代码，使用git管理代码，这就引出了持续集成——CI的概念，我们前端每日凌晨4点自动bulid,通过后才会打包一个包，如果当前节点有问题，及时修改，不至于到了后期，一整合，发现错误时已经尾大不掉，无法及时有效定位错误了，即使能定位，也会花费大量时间在测试上，以上我对持续集成的简单理解。 具体执行起来使用Jenkins。这又是一个大话题了，后期会继续深入。","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"think","slug":"think","permalink":"https://codevvvv9.github.io/tags/think/"}]},{"title":"工作小结-1","slug":"工作小结-1","date":"2018-08-28T15:22:20.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/08/28/工作小结-1/","link":"","permalink":"https://codevvvv9.github.io/2018/08/28/工作小结-1/","excerpt":"scrollTop的兼容性问题在做移动端布局时，监控touchmove事件经常会使用scrollTop来模拟页面的滑动距离，但是 仅仅使用document.body.scrollTop来进行滑动距离的判断，会失效","text":"scrollTop的兼容性问题在做移动端布局时，监控touchmove事件经常会使用scrollTop来模拟页面的滑动距离，但是 仅仅使用document.body.scrollTop来进行滑动距离的判断，会失效 1234567if (document.body.scrollTop &gt; 100) &#123; console.log('滑动距离大于100像素'); this.isShow = true&#125; else &#123; console.log('滑动距离小于100像素'); this.isShow = false&#125; 此时应该考虑兼容性，不应该去监听body的滚动距离，而应该去监听html元素的滚动距离 12345678let scrollTop = document.body.scrollTop || document.documentElement.scrollTopif (scrollTop &gt; 100) &#123; console.log('滑动距离大于100像素'); this.isShow = true&#125; else &#123; console.log('滑动距离小于100像素'); this.isShow = false&#125; 上图才是正确的结果，当滚动距离大于100像素时，出现回到顶部的按钮。 事件戳的转化问题URL里的token分析为了web安全考虑一般在路径里面后端会传入一个token来标识用户，防止反复攻击，例如http://10.20.20.109/?nuctoken=111#/，只有带有nuctoken才会访问到正确的页面，如果没有就会显示errorpage i18n在vue中的使用为了扩展字符的国际化语言，使用i18n，在vue中单独把汉字字端放到一个cn.js文件中，相当于一个字典。 使用 1$t('字典中某个字段的名字')","categories":[{"name":"三省吾身","slug":"三省吾身","permalink":"https://codevvvv9.github.io/categories/三省吾身/"}],"tags":[{"name":"think","slug":"think","permalink":"https://codevvvv9.github.io/tags/think/"}]},{"title":"Vue的组件间通信","slug":"Vue的组件间通信","date":"2018-05-07T09:51:51.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/05/07/Vue的组件间通信/","link":"","permalink":"https://codevvvv9.github.io/2018/05/07/Vue的组件间通信/","excerpt":"组件是插槽式的，例如某个页面有两个组件，其中搜索作为其中一个组件，当它作为组件的时候，它作为子组件的时候需要把参数通过属性的方式传递进来，通知父组件的时候通过触发事件来进行通信。 以上是组件化的简单描述，与模块化的组要区别在于组件化课深度定制不同的属性，借助父组件的参数值。 那么问题来了，组件间如何进行通信呢？","text":"组件是插槽式的，例如某个页面有两个组件，其中搜索作为其中一个组件，当它作为组件的时候，它作为子组件的时候需要把参数通过属性的方式传递进来，通知父组件的时候通过触发事件来进行通信。 以上是组件化的简单描述，与模块化的组要区别在于组件化课深度定制不同的属性，借助父组件的参数值。 那么问题来了，组件间如何进行通信呢？ 父子组件通信最经典的通信方式就是：父组件与子组件之间进行通信。 组件的基本写法123456Vue.component('shareLink', &#123; data() &#123;&#125;, props: ['shareLink'], methods: &#123;&#125;, template: ``,&#125;) 上述的代码就创建了一个名为shareLink的组件，并且可传递一个名为shareLink的参数值。 但是注意： HTML的规范规定，标签名与属性名都必须是小写字母，所以上述的组件在HTML代码里面默认写成share-link 组件里面的data必须是函数，而不是app.js中的对象写法。 具体一点的写法是： 12345678910111213Vue.component('share', &#123; props: ['shareLink'], template: ` &lt;div class=\"share\" v-cloak&gt; &lt;h2&gt; 请将下面链接分享给面试官 &lt;/h2&gt; &lt;div&gt; &lt;textarea readonly&gt;&#123;&#123;shareLink&#125;&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; `,&#125;) 其中props中是参数的名字，接受别的组件传递的信息。 12&lt;share v-bind:share-link=\"shareLink\" v-show=\"shareVisible\"&gt;&lt;/share&gt;//在html的页面中这样写 v-bind将参数的名字绑定上，值是通过app.js获得的shareLink 简单的对应规则 v-bind :share-link = “shareLink” 对应的 props: [‘shareLink’] app.js中{shareLink: ‘ ‘} 需求分析 子组件想改父组件的data。例如登录后的关闭按钮无用的例子。 12&lt;login v-show=\"loginVisible\"&gt;&lt;/login&gt; //这是父组件的写法，loginVisible是父组件的变量,很明显儿子无法修改爸爸的数据啊 但是儿子特别像修改爸爸的数据 那么唯一的解决方案就是叫爸爸去修改 解决方案： 子组件通过事件告诉爸爸，我需要你做一些改变。 @click=&quot;$emit(&#39;close&#39;)&quot; 注意：在methods中需要使用this.$emit(&#39;&#39;)，但是在@click中不需要用this 那么爸爸根据儿子的需要做出如下改变 &lt;login v-show=&quot;loginVisible&quot; @close=&quot;loginVisible = false&quot;&gt; @close等同于v-on:close 父子组件通信的demo链接 爷孙组件间的通信需求分析 爷爷看不到孙子在哪里 但是呢，爷爷就是想控制孙子 所以呢，借助爸爸来间接的去控制孙子就好啦 本质上Vue只有父子间通信，爷孙间通信需要使用两次父子间通信。 爷爷只控制孙子该版本中爷爷只能控制孙子的显示，但是目前孙子无法反向操作爷爷。 demo的链接 孙子逐级冒泡通知爷爷孙子先冒泡到爸爸那里，使用 1234567891011121314151617Vue.component('child', &#123; props: ['visible'], template: ` &lt;div&gt; 我是儿子 &lt;grand-child v-show=\"visible\" @close=\"$emit('close')\"&gt;&lt;/grand-child&gt; &lt;/div&gt; `&#125;)Vue.component('grandChild', &#123; template: ` &lt;div&gt; 我是孙子 &lt;button @click=\"$emit('close')\"&gt;关闭&lt;/button&gt; &lt;/div&gt; `&#125;) 爷爷那里就可以监听到孙子的动作了 123456789&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=\"xxx = true\"&gt;打开&lt;/button&gt; &lt;hr&gt; &lt;child :visible=\"xxx\" @close=\"log\"&gt;&lt;/child&gt; &lt;/div&gt; &lt;/body&gt; demo的链接","categories":[{"name":"Vue的学习","slug":"Vue的学习","permalink":"https://codevvvv9.github.io/categories/Vue的学习/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://codevvvv9.github.io/tags/Vue/"}]},{"title":"初级前端打怪升级之路","slug":"初级前端打怪升级之路","date":"2018-03-30T14:14:29.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/03/30/初级前端打怪升级之路/","link":"","permalink":"https://codevvvv9.github.io/2018/03/30/初级前端打怪升级之路/","excerpt":"如何自学前端，以及应该学习的顺序……自己想了下，总结一下 仅代表初级前端能找到一份养家糊口的工作，至少需要一年多的理解，如果有过其他编程基础，可能需要8个月吧。","text":"如何自学前端，以及应该学习的顺序……自己想了下，总结一下 仅代表初级前端能找到一份养家糊口的工作，至少需要一年多的理解，如果有过其他编程基础，可能需要8个月吧。 零基础的学习计划 安装vscode 先学 html 5，用MDN文档去学，废弃的属性不需要去看，大跨步的前进，xhtml的那些东西不需要去学了，记住MDN文档里面写的那些新属性，这些是以后面试时经常问的问题。学习是着重注意html 5语义化的含义，体会下。 接着学习 CSS 3，对于新的属性格外注意，各种特殊情况包括各种居中怎们做，花点时间，记住吧，这个css要多敲代码，看的再多也没用。css是区分优秀前端和其他兼职前端的分界线。 此时模仿你喜欢的网站做点静态页面。 继续学习ES 5，这是javascript基础知识，此时进入前端的瓶颈了，多花点时间理解吧，例如函数、闭包、this、作用域、原型链重点理解。 精进的计划 学点MVC思想与面向对象的基础知识，方便后面的jq的理解。 学习ajax，引出跨域的概念，以及破解跨域的另一个解决方案JSONP，学习主流的数据交换格式JSON。 进军jquery与bootstrap。jq是第一个你需要接触的框架，减少很多代码量，提升自信心。bootstrap的思想值得细细品味。 此时有了前端基础和框架，做一个一个完整的项目吧。学会前端工程化的目录结构。 以上算是前端的小小入门。接下来是升华阶段。 升华阶段 补充http的知识，cookie、session、localstorage、sessionstorage。学习缓存机制以及持久化化存储。 学习从MVC到MVVM的转换，目前主流的都是MVVM。学习axios库替换jq去操作ajax。 学习ES 6,这是现在主流框架以及工作要用到的js规范。 学习前端自动打包器-webpack不用学其他的了，其他的都淘汰了！！！！ 安装webstorm，学习Vue，以及它的全家桶系列。不要学angular，初学者千万不要学它，也不用先学typescript。 做一个基于Vue全家桶的项目。 以上是现代化前端必备的知识体系！！！ 注：锦上添花的是学会react以及小程序开发～，这一步不是必备的 未来一年努力夯实基础知识，争取早日到达中级前端！！！！！！！！！","categories":[{"name":"前端之外","slug":"前端之外","permalink":"https://codevvvv9.github.io/categories/前端之外/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"https://codevvvv9.github.io/tags/Dev/"}]},{"title":"前端必备网站","slug":"前端必备网站","date":"2018-03-29T13:58:16.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/03/29/前端必备网站/","link":"","permalink":"https://codevvvv9.github.io/2018/03/29/前端必备网站/","excerpt":"弃一些花里胡哨的没个卵用的网站，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~ 在自学前端的道路上，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~ 配上英语，学的更好哦~","text":"弃一些花里胡哨的没个卵用的网站，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~ 在自学前端的道路上，关注下面的网站，绝对不会让你们失望了，坚持使用3个月以上，学不好前端，你们来砍我~ 配上英语，学的更好哦~ 必备的文档类的网站 MDN web文档 很权威的文档。有各种详细的使用说明，包括前端但不止于前端，http、ajax都有很深的涉及，示例代码都是各界权威们写的demo，代码清晰、易用；新的标准、废弃的标准、推荐你应该学习的特性，各种官方spec的链接，绝对不会歪曲理解概念；你还可以修改中文的翻译，提出贡献，翻译的的好，可能会有人邀请你工作。当然最好是还是看英文原版的。 国外的w3scools，看清楚了 链接是这个 https://www.w3schools.com/ 错误很少，文档很简洁，还能学习英语，就像科学、音乐不分国界一样，代码同样不分国界，都能看得懂。 所有的你要用的库、框架的官方文档 比如webpack、less、jquery、node-sass、Vue、react、BootStrap等 处理常见的报错和学习新技术经常去的网站 Github 与Stack Overflow 学习各种流行库、框架的时候，会报很多错，可以去github上看对应的issue，一般都有解决方案；去Stack Overflow上搜索也能搜索出来。 国内的segmentfault 以及 掘金 segmentfault是立志成为国内的Stack Overflow的，也可以解决一部分问题，挺好用的，掘金上面以技术为主的文章很多，还有面试分享，程序员必须的网站。 专业性的技术网站 阮一峰的JS入门教程 http://javascript.ruanyifeng.com/ 以及 他的ES6入门 http://es6.ruanyifeng.com/ 阮一峰大神是经济学博士，现在在支付宝团队，他学习就是很理智的故事，关注他的博客吧，最前沿的知识都能学到，他也做出了相应的demo。 廖雪峰的个人网站 廖雪峰的js教程以及git教程很好。 学习CSS 3的三个好网站 css-tricks https://css-tricks.com/ 从CSS3入门到深爱 codrops https://tympanus.net/codrops/ 颠覆你对CSS3的认识 codepen https://codepen.io/ 各种提升你CSS3内力的demo 国内CSS第一人张鑫旭的博客 一丝的博客 他的关于为什么要清除浮动以及如何清除浮动的文章，完美解释了面试要问的所有问题。 高逼格的的v2EX 国内的专业前端团队 淘宝前端 http://taobaofed.org/ 腾讯前端团队 http://www.alloyteam.com/ 360前端技术团队 https://www.75team.com/ 其他的前端团队也很猛，可以多去了解 通过前端技术大拿的博客 开拓眼界 Twitter、weibo上的前端大神啊 Vue的作者尤雨溪、蚂蚁金服玉伯、阿里 winter、i5ting(狼叔，nodejs布道者)、CNode负责人alsotang、寸志、大漠、死月、小芋头君等等大神的言论，注意甄别，以上排名不分前后，都是碾压一切的boss,如果大家记得其他的大佬，我忘了的话，欢迎关注我的github，然后怼我……","categories":[{"name":"前端之外","slug":"前端之外","permalink":"https://codevvvv9.github.io/categories/前端之外/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"https://codevvvv9.github.io/tags/Dev/"}]},{"title":"云音乐-2","slug":"云音乐-2","date":"2018-02-25T13:53:39.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/25/云音乐-2/","link":"","permalink":"https://codevvvv9.github.io/2018/02/25/云音乐-2/","excerpt":"获取歌曲的外链通过七牛的文档说明，先去js官方文档，然后通过里面的js源码地址，选择1.0的版本，进入之后，选择示例网站，在获得代码里面，可以发现下面代码 12345678910111213 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info.response 是文件上传成功后，服务端返回的json，形式如 // &#123; // \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\", // \"key\": \"gogopher.jpg\" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html // var domain = up.getOption('domain'); // var res = parseJSON(info.response); // var sourceLink = domain + res.key; 获取上传成功后的文件的Url&#125;,","text":"获取歌曲的外链通过七牛的文档说明，先去js官方文档，然后通过里面的js源码地址，选择1.0的版本，进入之后，选择示例网站，在获得代码里面，可以发现下面代码 12345678910111213 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info.response 是文件上传成功后，服务端返回的json，形式如 // &#123; // \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\", // \"key\": \"gogopher.jpg\" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html // var domain = up.getOption('domain'); // var res = parseJSON(info.response); // var sourceLink = domain + res.key; 获取上传成功后的文件的Url&#125;, 很明显最后三行与我的目的有关，打开注释，改造成我所需要的 123var domain = up.getOption('domain');var response = JSON.parse(info.response);var sourceLink = 'http://' + domain + '/' + encodeURIComponent(response.key); 几点要注意的 response的key就是我拖曳或者上传的歌曲 为什么要用encodeURIComponent 因为你上传的时候必然会有中文吧，浏览器和服务器端都不会懂你问的这些中文是什么鬼，我们要用URL编码处理一下这个response.key（也就是歌曲的名字），之所以不用encodeURI，是因为它会把一个东西当做一个整体的，如果含有&amp;，还是会把&amp;传给你，而这个很有可能会有歧义。 如果我想把带有&amp;的一串东西放到查询参数里面，需要使用encodeURIComponent。 CSS布局以及HTML结构划分初步规划是左边第一栏是new-song，中间是song-list,底部是upload-song，右面是song-form部分 1234567891011121314151617181920&lt;page&gt; &lt;aside class=\"sidebar\"&gt; &lt;div class=\"newSong\"&gt; &lt;/div&gt; &lt;div id=\"songList-container\"&gt; &lt;/div&gt; &lt;div class=\"uploadArea\"&gt; &lt;div id=\"uploadContainer\" class=\"draggable\"&gt; &lt;div id=\"uploadButton\" class=\"clickable\"&gt; &lt;p&gt;点击或者拖曳文件&lt;/p&gt; &lt;p&gt;文件大小不能超过 40MB&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt; &lt;main&gt; &lt;/main&gt;&lt;/page&gt; page区域使用flex布局，是的aside和main区域左右分布，然后aside在使用flex布局并使用flex-direction=column。使之上下排列。 CSS的一些小技巧 border: dashed是把阴影虚线化。 git commit -v查看更改的内容是什么。 属性选择器 .form input[type=button] 为了实现选中label激活里面的input可能会选择label包裹input的布局，可是存在风险。比如如果label的文字过多，你加了宽度是没有用的，只是会换行而已（显然不是我想看到的），因为label是inline元素，可是改成inline-block又会有bug（一道空隙）。所以只能选择不用label去包裹input了。 优化的代码如下 12345678910.form &gt; .row &gt; label&#123; display: flex; justify-content: flex-end; align-items: center; width: 4em; margin-right: 5px;&#125;.form &gt; .row.actions&#123; margin-left: calc(4em + 5px);&#125; input的字体应该继承才行，不然字体大小不对。input{font: inherit;} 背景色是在border里面的，margin上没有背景色 模块化和MVC的设计如果一个模块变化了，如何通知另外的模块我变了呢，最简单的是使用一个全局的js，告诉其他的js，我变了。 先写一个全局的app.js 123&#123; window.app = &#123;&#125;&#125; 在要发起通信的js文件上写上下面的代码 1234window.app.newSong.active()window.app.songForm.reset()...window.app.uploadSong = controller 也就是说其他的js模块只是往外暴露他们对应的js就可以了。但是这种方式的通信耦合度有点高，不利于后期更改。 因为假如3变了要去通知1和4的话，1和4还是知道3的存在，所以不应该让1和4知道3的存在。采取中间环节来转换，那就是发布订阅模式。 发布订阅模式 使用全局的eventHub模块 1234567891011121314151617181920212223242526272829303132window.eventHub = &#123; events: &#123; // '遗憾': [fn], // '追光者': [], &#125;, /** * 发布 * @param &#123;*事件名字&#125; eventName * @param &#123;*数据&#125; data */ emit(eventName, data) &#123; for(let key in this.events) &#123; if(key === eventName) &#123; let fnList = this.events[key] fnList.map((fn) =&gt; &#123; fn.call(undefined, data) &#125;) &#125; &#125; &#125;, /** * * @param &#123;*订阅的事件名字&#125; eventName * @param &#123;*订阅事件之后执行的函数&#125; fn */ on(eventName, fn) &#123; if (this.events[eventName] === undefined) &#123; this.events[eventName] = [] &#125; this.events[eventName].push(fn) &#125;&#125; 其他模块的js使用的时候就可以使用 1234window.eventHub.emit('upload', &#123; 'url': sourceLink, 'name': response.key&#125;) 几个注意要点 ES6的一个特性 123render(data = &#123;&#125;) &#123; &#125; 如果你传值的时候，没有传值或者传的值是undefined就给你一个空对象。 省略一点代码 在view里面写上 123init()&#123; this.$el = $(this.el)&#125; Vue框架里面V-for出现的必要性 如果直接用template的话 123456789101112&lt;ul class=\"songList\"&gt; &lt;li&gt;歌曲1&lt;/li&gt; &lt;li class=\"active\"&gt;歌曲233333&lt;/li&gt; &lt;li&gt;歌曲3&lt;/li&gt; &lt;li&gt;歌曲4&lt;/li&gt; &lt;li&gt;歌曲52222222&lt;/li&gt; &lt;li&gt;歌曲6&lt;/li&gt; &lt;li&gt;歌曲7&lt;/li&gt; &lt;li&gt;歌曲8&lt;/li&gt; &lt;li&gt;歌曲9&lt;/li&gt; &lt;li&gt;歌曲1033&lt;/li&gt;&lt;/ul&gt; 很显然这种template很难看，所以使用如下的代码改造。 12345678910111213141516let view = &#123; el: '#songList-container', template: ` &lt;ul class=\"songList\"&gt; &lt;/ul&gt; `, render(data) &#123; let $el = $(this.el) $el.html(this.template) let &#123;songs&#125; = data let liList = songs.map((song) =&gt; $('&lt;li&gt;&lt;/li&gt;').text(song.name)) $el.find('ul').empty() liList.map((domLi) =&gt; &#123; $el.find('ul').append(domLi) &#125;) &#125;, 而以上的仍然麻烦，所以Vue发明了V-for的语法，不过人家是使用了正则表达式去实现的。 4.深拷贝与浅拷贝的阴影 1234let string = JSON.stringify(this.model.data)let object = JSON.parse(string)// window.eventHub.emit('create', this.model.data) //一开始用的是这句代码，明显this.model.data会被多次篡改window.eventHub.emit('create', object)","categories":[{"name":"云音乐","slug":"云音乐","permalink":"https://codevvvv9.github.io/categories/云音乐/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://codevvvv9.github.io/tags/jQuery/"}]},{"title":"云音乐-1","slug":"云音乐-1","date":"2018-02-21T03:37:49.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/21/云音乐-1/","link":"","permalink":"https://codevvvv9.github.io/2018/02/21/云音乐-1/","excerpt":"本文是云音乐的需求分析以及基本环境的搭建，主要是LeanCloud和七牛的使用。 需求分析先根据网易云音乐移动端去分析需求，看看有哪些能做的 做啥 目前初步分析的需求如上图所示，主要针对两个角色（普通用户和管理员）。","text":"本文是云音乐的需求分析以及基本环境的搭建，主要是LeanCloud和七牛的使用。 需求分析先根据网易云音乐移动端去分析需求，看看有哪些能做的 做啥 目前初步分析的需求如上图所示，主要针对两个角色（普通用户和管理员）。 用啥在学习阶段主要是学会核心概念、流程、代码，能用原生JS做就用原生JS做，少用库去做事。 可是到了做项目的时候项目（建立在已经学会了基本的概念与敲了足够的代码量之后），应该采取不同的策略去完成项目，例如选择合适的库、看文档、写demo、copy大神成功的代码。 所以本项目采用了成熟的jQuery以及LeanCloud、七牛作为后台的数据库。 LeanCloud一个简单的数据库(比MySQL都简单，主要是更加形象，能与项目迅速的结合并给我很多正反馈)。 安装直接去看文档 12345//存储服务（包括推送和统计）cd 项目目录npm install leancloud-storage --save// 2. 在html里引入av.min.js&lt;script src=\"../node_modules/leancloud-storage/dist/av-min.js\"&gt;&lt;/script&gt; 初始化AV对象我们使用LeanCloud主要是用的这个AV对象 1234567var APP_ID = '0ISMRGDfPWtQcP8WktXGADsl-gzGzoHsz'; //与项目相关var APP_KEY = 'FKV4IYQNPyB6C5jFBv8vJ7LT'; //与项目相关AV.init(&#123; appId: APP_ID, appKey: APP_KEY&#125;); 写完上述代码可以简单的测试一下是否成功，最简单的就是直接打印console.log(window.AV) 官方推荐如下 1234567var TestObject = AV.Object.extend('TestObject');var testObject = new TestObject();testObject.save(&#123; words: 'Hello World!'&#125;).then(function(object) &#123; alert('LeanCloud Rocks!'); //成功后将在屏幕上弹出这句话 &#125;) 此时会发现LeanCloud的项目应用下多一个表TestObject,表里面有一个字段是words，值是Hello World! 所以可以推测出这个就是LeanCloud提供给我们生成数据库表以及字段的代码，所以我实际中可以如下使用 12345678910111213141516//创建数据库，只是本地而已var TestObject = AV.Object.extend('Playlist'); //创建一条记录var testObject = new TestObject(); //保存记录，LeanCloud端testObject.save(&#123; name: 'test', cover: 'test', creatorId: 'test', description: 'test', songs: ['1', '2']&#125;).then(function(object) &#123; alert('LeanCloud Rocks!'); &#125;, () =&gt; &#123; alert('failed')&#125;) 效果如下图所示 通过上图可以简单的看出LeanCloud可以存储字符串以及数组。 ACL: Access Control Layer 像MP3等文件只能借助下面的七牛去存储了 七牛这是一个使用云存储的信赖度极高的工具。 毫无疑问的，先要看文档安装 安装目前有1.X和2.X版本，可以预料到版本的问题有可能会产生bug. 12npm install qiniu-js&lt;script src=\"../node_modules/qiniu-js/dist/qiniu.min.js\"&gt;&lt;/script&gt; 通过sctipt标签引入该文件，会在全局生成名为 qiniu 的对象(2.X版本的)，而这个对象会为后面的上传文件埋下致命的bug。 可以通过简单的console.log(qiniu)，验证是否成功。 可以看一下，七牛的用例 一个小bug在后面的plupload的时候会报错，很奇怪。后来看七牛的用例的源码，在人家的qiniu.min.js的里面发现的Qiniu,而我的没有，所以猜测七牛用例使用的是1.x版本，果断通过更改版本 1234567\"dependencies\": &#123; \"leancloud-storage\": \"^3.6.0\", \"qiniu-js\": \"^1.0.2\" &#125; //修改完package.json npm i 上传文件在页面中引入qiniu.min.js后，初始化uploader，在这之前需要安装plupload,而安装这个有需要安装moxie。 plupload直接通过npm就可以了，而这个moxie需要去github下载源码自己导入。 服务端准备 本 SDK 依赖服务端颁发的上传凭证，可以通过以下二种方式实现： 利用七牛服务端 SDK 构建后端服务 利用七牛底层 API 构建服务，详见七牛上传策略和上传凭证 后端服务应提供一个 URL 地址，供 SDK 初始化使用，前端通过 Ajax 请求该地址后获得 upToken。 Ajax 请求成功后，服务端应返回json 如上是七牛为了安全性考虑的，必须获得一个token。所以我选择使用node做一个假的服务端，来获取token. nodejsServer惯例使用七牛的nodejs文档 先安装 1npm install qiniu 在server.js里面简单的构建 12345678910111213141516171819202122232425if (path === '/uptoken') &#123; response.statusCode = 200 response.setHeader('Content-Type', 'text/json;charset=utf-8') response.setHeader('Access-Control-Allow-Origin', '*') //定义好其中鉴权对象mac： var config = fs.readFileSync('./qiniu-key.json') //真正的accessKey, secretKey在这里 config = JSON.parse(config) let &#123;accessKey, secretKey&#125; = config var mac = new qiniu.auth.digest.Mac(accessKey, secretKey); //简单上传的凭证 var options = &#123; scope: \"163-music-demo-1\", //应用的名字 &#125;; var putPolicy = new qiniu.rs.PutPolicy(options); var uploadToken=putPolicy.uploadToken(mac); response.write(` &#123; \"uptoken\": \"$&#123;uploadToken&#125;\" &#125; `) response.end() &#125; 做好这个工作之后，uploader可以工作了 123456var uploader = Qiniu.uploader(&#123; ... uptoken_url: 'http://localhost:8888/uptoken', //只需要注意这一句，其他代码抄文档。以后每次先开一个node server.js 8888 ...&#125;); 至此所有的代码，可以看这个版本 既然支持拖曳上传和普通上传，需要做一些简单的css样式的修改以及html的改动。 12345678910111213141516171819&lt;style&gt; p&#123;margin: 5px; padding: 0;&#125; #container&#123; padding: 50px 80px; border: 2px dashed #ddd; border-radius: 20px; display: flex; justify-content: center; align-items: center; width: 200px; flex-direction: column; &#125; &lt;/style&gt; &lt;div id=\"container\"&gt; &lt;span id=\"pickfiles\"&gt;点击或者拖曳文件&lt;/span&gt; &lt;p&gt;文件大小不能超过 40MB&lt;/p&gt; &lt;/div&gt; &lt;div id=\"uploadStatus\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132var uploader = Qiniu.uploader(&#123; browse_button: 'pickfiles', //上传选择的点选按钮，**必需** ... container: 'container', //上传区域DOM ID，默认是browser_button的父元素， max_file_size: '40mb', //最大文件体积限制 dragdrop: true, //开启可拖曳上传 drop_element: 'container', //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传 auto_start: true, //选择文件后自动上传，若关闭需要自己绑定事件触发上传 init: &#123; 'FilesAdded': function (up, files) &#123; plupload.each(files, function (file) &#123; // 文件添加进队列后,处理相关的事情 &#125;); &#125;, 'BeforeUpload': function (up, file) &#123; // 每个文件上传前,处理相关的事情 &#125;, 'UploadProgress': function (up, file) &#123; // 每个文件上传时,处理相关的事情 uploadStatus.textContent = '上传中' //提示用户上传进度的 &#125;, 'FileUploaded': function (up, file, info) &#123; uploadStatus.textContent = '上传完毕' &#125;, 'Error': function (up, err, errTip) &#123; //上传出错时,处理相关的事情 &#125;, 'UploadComplete': function () &#123; //队列文件处理完毕后,处理相关的事情 &#125; &#125; &#125;); 至此，简单的上传文件的效果做完了，全部的代码版本","categories":[{"name":"云音乐","slug":"云音乐","permalink":"https://codevvvv9.github.io/categories/云音乐/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://codevvvv9.github.io/tags/jQuery/"}]},{"title":"爱搞事情的webpack","slug":"爱搞事情的webpack","date":"2018-02-13T14:06:29.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/13/爱搞事情的webpack/","link":"","permalink":"https://codevvvv9.github.io/2018/02/13/爱搞事情的webpack/","excerpt":"webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 基本安装 局部安装,官方也是推荐安装到项目目录下 1234mkdir webpack-demo-1cd webpack-demo-1npm init -y //生成package.json,并且一路同意,如果没啥个性化的内容则省了你一路狂按enternpm install --save-dev webpack //安装到开发环境里面(devDependicies) webpack基本配置文件","text":"webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 基本安装 局部安装,官方也是推荐安装到项目目录下 1234mkdir webpack-demo-1cd webpack-demo-1npm init -y //生成package.json,并且一路同意,如果没啥个性化的内容则省了你一路狂按enternpm install --save-dev webpack //安装到开发环境里面(devDependicies) webpack基本配置文件 12touch webpack.config.jsvi webpack.config.js 配置文件内容如下12345678910const path = require('path');module.exports = &#123; entry: './src/index.js', // 这里应用程序开始执行,webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 filename: 'bundle.js',//输出资源块的名字(asset chunk) path: path.resolve(__dirname, 'dist') // 所有输出文件的目标路径,我的就是./dist/bundle.js &#125;&#125;; 把当前目录的src下的index.js打包到了dist目录下，并且生成了(emmited)一个改头换面的bundle.js，里面的代码面目全非啊。 可以有多个入口(entry)12345678910entry: &#123; scss: './src/css/main.scss', //对象的键名scss 就是输出文件的name bundle: './src/js/app.js' &#125;, output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, 'dist/js') // publicPath: \"/output/\" &#125;, 多个入口最好写成对象的形式，官网说如果写成了数组，输出的内容会是数组的第一个。 上述代码会在dist/js目录下生成scss.js和bundle.js path其中，配置文件的第一行代码使用了Node的内置模块path,并且在它前面加上 __dirname这个全局变量(也就是第七行代码)。可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作。即使你的index.js内容为空，bundle.js里面也有一些基本的打包代码。 基本的使用123456789101112131415//第一种方法，使用当前目录的node_modules里面的webpack./node_modules/.bin/webpack //第二种方法使用npm脚本//首先在你的package.json里面添加下列代码&#123; ... \"scripts\": &#123; \"build\": \"webpack\" &#125;, ...&#125;//然后，使用下列代码即可npm run bulid//第三种方法，高版本的npm自带了npxnpx webpack //npx会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ 所以说呢，我选择了第三种使用方法。 babel-loaderES6或其他版本js转换成通用js代码，毫无疑问应该使用babel，不过在webpack的世界里面统一使用loader，所以我们google webpack babel-loader。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 有个坑，很容易搞错的坑babel-loader不同版本的安装脚本、配置文件是不同的……(@ο@) 哇～你搜出的最新的文档用这么小的文字告诉你，你用webpack 3.x babel-loader 7.x | babel 6.x的去这个链接,webpack 3.x | babel-loader 8.x | babel 7.x的去当前的这链接链接。好吧，我用上一版本的吧。所以我的安装脚本是1npm install --save-dev babel-loader babel-core babel-preset-env webpack 配置文件是123456789101112131415161718//依然属于webpack.config.js配置的一部分，module: &#123; //这是关于模块的配置 rules: [ //模块规则（配置 loader、解析器等选项） &#123; test: /\\.js$/, //使用正则判断后缀是js的文件 exclude: /(node_modules|bower_components)/, //除了这两目录下的node_modules|bower_components use: &#123; loader: 'babel-loader', //用这个loader处理.js的文件 options: &#123; presets: ['env'] //选项，还记得单独使用babel的时候建立的那个.babelrc嘛，就是那个作用。 &#125; &#125; &#125; ]&#125; 借此可以得到loader的两个作用： 识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 转换这些文件，从而使其能够被添加到依赖中（并且最终添加到 bundle 中）(use 属性)在./src/js/有module-1.js、module-2.js、app.js三个文件，都是新的语法，用的模块化写法，有的浏览器不支持，所以需要转化。 1234567891011121314151617//module-1.js代码function fn()&#123; console.log(1)&#125;export default fn//module-2.jsfunction fn()&#123; console.log(2)&#125;export default fn//app.jsimport x from './module-1.js'import y from './module-2.js'x()y() 最终效果，打开的我的预览链接,使用ctrl+shift+J，会看到打印出1和2 sass-loader如果使用了预编译的scss语言，要把scss文件变成css并加入到html里面，思路同上，google webpack scss得到如下代码1npm install sass-loader node-sass webpack --save-dev 模块配置文件12345678910111213141516// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot; // translates CSS into CommonJS &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;] &#125;] &#125;&#125;; 这个官方的就比较给力了，很清楚地用法 先用sass-loader把./src/csa/main.scss编译成main.css 再用css-loader把main.css变成符合CommonJS规范的 把main.css变成js字符串，并创建style节点，把它放进去，这样html就可以显示啦。 不过坑爹依旧☺……用的时候报错喽～ 第一次就说缺style-loader，好吧……自觉点把另一个一起安装了把。 1npm i --save-dev css-loader style-loader 所以，打开我的预览链接，会看到我的预览的背景是灰色的。 此时的webpack.config.js最终代码123456789101112131415161718192021222324252627282930313233const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/js/app.js&apos;, output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist/js/&apos;) &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;] &#125; &#125; &#125;, &#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot; // translates CSS into CommonJS &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;] &#125; ]&#125;&#125;; 所以借助webpack强大的模块化，通过其构建的依赖关系图(dependency graph)把js、scss都搞到了bundle.js里面，真是牛～ html-loader本来搞了一个html-loader，优化html，把空格、注释都给压缩掉，提高性能，可是实际使用中也没有报错，也没啥效果，比较尴尬……自己埋个坑后面补一补。 Copy Webpack Plugin目前呢，前面的loader用的都很爽。在src目录下修改完了代码，一个npx webpack，刷新就可以看到效果了，体验很棒。但是今天坐在电脑前面，回想代码，以前在前端工程话的道路上，scss、js、html都是被监视着(wacth)，开四个命令行窗口，只要src下一有风吹草动，就会把修改后的代码更新过去。 目前使用的webpack可以完全自动化scss、js了，可我如果修改了src/index.html，dist/也无法获知我的修改啊 然后我google一一会，发现了这货Copy Webpack Plugin 哎呀，是个plugin，终于webpack的四大基本概念都到齐了,前面搞了entry output loder，今天用一下plugin。 loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。基本安装1npm i -D copy-webpack-plugin Copy Webpack Plugin配置文件(plugin的和loader的配置文件可不是一个套路。loader是在module.rules数组的每一个对象里面(即rules数组的每一个value)，而plugin是在module的plugins数组里面)12345678//依然在webpack.config.jsconst CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const config = &#123; plugins: [ new CopyWebpackPlugin([ ...patterns ], options) ]&#125; Copy Webpack Plugin的github给的代码，一开始把我搞蒙了，和webpack官网的代码不大一样啊。后来才发现原来用了module.exports = config;在我的小demo里使用的是12345678plugins: [ new CopyWebpackPlugin([ &#123; //原来一个plugin就是一个对象啊，使用的时候实例化对象即可 from: &apos;src/index.html&apos;, //从src/index.html目录下复制 to: &apos;../index.html&apos;, //到dist/index.html toType: &apos;file&apos; //复制类型是文件 &#125;], &#123; copyUnmodified: true &#125;) //把未修改的部分也复制过去 ] 这个插件可以实现很多功能，具体的细节看这里 关于目录的一个小问题上面代码为什么这么写呢to: &#39;../index.html&#39;, ，试了好几遍发现没有报错，就是没有结果，最后搞明白了是路径的问题……还记得 四大基本概念的output里面的path吗，回头看一开始的path1234output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist/js/&apos;)&#125;, 项目的path是dist/js下，所以应该复制到上一级目录下../也就是dist/目录下了。 可以看到预览链接里面的文字啦动态效果可以看下图 postcss-loader上述代码有个小问题使用了display： flex把ul&gt;li变成了横排，但是这玩意有兼容性。当初我的一篇文章唯一的一个评论就是这么说我的…… 检查兼容性(虽然这是严谨要求，我还是老忘)，可以去caniuse 看一下,(@ο@) 哇～IE没有绿的哎，支持太差了。( ⊙ o ⊙ )！万一以后我项目搞大了，IE的用户、老安卓的用户想看我项目咋办呢，只能加一下前缀优化一下啦。有个挺牛的在线的autoprefixer，也可以去在线转换。既然使用了webpack就Google webpack autoprefixer，遗憾的发现autoprefixer官方推荐使用postcss-loader postcss-loader解决兼容性问题先吐槽一下，这货的文档也是稀烂…… 官方安装脚本 1npm i -D postcss-loader 需要单独配置文件postcss.config.js，官方的写法是下面这个（最无语的就是这个……，下面的必错，写出来就是警告大家，官方的也不一定对） 12345678module.exports = &#123; parser: &apos;sugarss&apos;, // 铪？？？？解析器是sugarss??? plugins: &#123; &apos;postcss-import&apos;: &#123;&#125;, &apos;postcss-cssnext&apos;: &#123;&#125;, &apos;cssnano&apos;: &#123;&#125; &#125;&#125; 在webpack.config.js的添加时还要注意下面的几点 After setting up your postcss.config.js, add postcss-loader to your webpack.config.js. You can use it standalone or in conjunction with css-loader (recommended). Use it after css-loader and style-loader, but before other preprocessor loaders like e.g sass|less|stylus-loader, if you use any. 这段文档的要点就是让你注意postcss-loader应该在css-loader style-loader之后，但是一定要在其他的预处理器preprocessor loaders之前，例如sass|less|stylus-loader。 官方给了一个推荐的配置代码 123456789101112131415//依然是webpack.config.jsmodule.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ] &#125; ] &#125;&#125; 本项目用的是.src/css/main.scss,只能尝试着将上述代码加到相应的位置12345678910111213141516rules: [ ... &#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot;, options: &#123; importLoaders: 1 &#125;// translates CSS into CommonJS &#125;, &#123; loader: &quot;postcss-loader&quot; &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;] &#125;, ... ] 下面的几点可都是官网文档没写的，只能自己踩一踩的坑…… 运行npx webpack,连续报错，不过是缺必备的module的错误,也就是缺postcss.config.js里面的postcss-import postcss-cssnext cssnano sugarss 。没办法，先npm i -D 上面的四个模块名字，依然报错，这次是语法错误(⊙v⊙)嗯？？？它说我不必要的大括号？？？我这标准的scss语法啊，又不是sass的语法(它省略了大括号和分号)，先Google一波这个错误。终于在在postcss的issue里面发现了蛛丝马迹,问题果然出在那个令我疑惑的postcss.config.js里面错误原因分析 错误的使用了sugarss的解析器(这货和sass类似，没有大括号，所以它说我大括号错了，它的特点是Indent-based CSS syntax for PostCSS.SugarSS MIME-type is text/x-sugarss with .sss file extension.)，而我写的是scss语法。 postcss-loader哪来的勇气确定大家都是用的.sss后缀的sugarss语法呢，还敢直接在文档的醒目位置推荐稀烂的postcss.config.js，O__O “… 那么多的预编译的css语法，果然需要webpack打包工具啊，找到合适的loader去解析啊。 注释掉parser: &#39;sugarss&#39;,这句代码，可以使用默认的解析器去解析了，正常运行了。不过查看代码，发现好像转换后的css有点小丑 autoprefixer冗余仔细观察命令行，发现有线索，一个警告警告信息提示我说：postcss-cssnext发现有个冗余的autoprefixer插件在我的postcss插件里面，这个可能有不良影响，我应该移除它，因为它已经包括在了postcss-cssnext里面。 webpack的警告说的很明白，postcss-cssnext是无辜的，而且我确定按照官网代码走的，没有安装autoprefixer插件，错误必然在剩下的两个插件里面了。12345678//修改后的postcss.config.js只剩下这些了module.exports = &#123; plugins: &#123; &apos;postcss-import&apos;: &#123;&#125;, //1.它错了？ &apos;postcss-cssnext&apos;: &#123;&#125;, //webpack告诉我它是清白的 &apos;cssnano&apos;: &#123;&#125; //2.它错了？ &#125;&#125; 我选择了排除法： 先注释&#39;postcss-import&#39;: {},，发现无法转换后的css代码不对，说明它是无辜的。 那么问题必然是最后一个插件，注释掉&#39;cssnano&#39;: {}，终于完美了，而且代码很优美。 本着打破砂锅问到底的精神，我搜了一下cssnano,在其官网看到了真实的错误原因，webpack很明智啊，诚不欺我，果然冗余插件了。 cssnano里面有autoprefixer导致了冗余。 extract-text-webpack-pluginwebpack 把所有的资源都当成了一个模块, CSS、JS 文件 都是资源, 都可以打包到一个 bundle.js 文件中.但是有时候需要把样式 单独的打包成一个文件需要抽离出css文件到单独的css/下。 使用extract-text-webpack-plugin插件可以做到。 安装脚本 1npm install extract-text-webpack-plugin --save-dev 配置webpack.config.js，官方推荐的配置如下，但是需要结合自己的项目修改一下…… 1234567891011121314151617const ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); //插件的套路。都要require进来module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", //失败了就用它解析 use: \"css-loader\" //是css文件，就用这个处理 &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(\"styles.css\"), ]&#125; 目前的问题我如果使用的是scss，就很尴尬了 最开始由一个错误引起 Google一下，解决掉error，fallbak里面使用了style-loader，use里面不应该使用了，那么问题又来了 问题一：无法使用style-loader把我的main.scss转化后的css代码插入到style标签里面。 详见代码注释部分 1234567891011121314&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, //如果在use里面写上style-loader，就报错window未被定义，可是不写的话，我的bundle.js里面就无法把css放到style标签里面，只能手动把分离的css加到index.html，很无语。 use: [&#123; loader: &quot;css-loader&quot;, options: &#123; importLoaders: 1 &#125;// translates CSS into CommonJS &#125;, &#123; loader: &quot;postcss-loader&quot; &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;] &#125;) &#125; 问题2：可以提取出单独的css文件，但是没想到如何放到单独的css/下，很尴尬，代码未提交，还在摸索中。 问题大约知道应该出现在下面这个函数里面 123456new ExtractTextPlugin(&#123; filename: (getPath) =&gt; &#123; return getPath('../main.css').replace('../js', '../css'); // 本意是生成在dist/css/main.css,结果只是在dist/main.css目录下，没有css/ &#125;, allChunks: true&#125;) 所有的代码都在我的demo里面。 蛋疼的无力吐槽算……是……搞定了webpack的基本使用了……吧，最简单的符合我目前技术栈的各种loader,plugin都会安装了。当然，还有无数的webpack的loader、plugin在前方等着我去探索……各种稀奇古怪的配置文件……痛并快乐着☺ 五花八门的配置文件挺让我糟心的……幸亏有了node爸爸帮我啊，webpack爸爸虽然也是比较严厉的，但是省了你用四个命令行窗口的啊，还是很感人的啊。 工具这个东西嘛 配置出错了怎么办，默念三句 如果真的搞蹦了怎么办。熊得，送你一句名言 没有什么bug不是一遍webpack解决不了额，如果有的话，那就来三遍webpaack。总有一天让webpack叫你爸爸！！！ 新的挑战者parcel现在的吐槽大概是没有经历过以前更蛋疼的日子吧，幸好有了新的后起之秀—parcel，它的官网老厉害了，智能提示我用了中文，真是贴心。 回顾一下webpack的首页 在对比一下parcel的首页 两者的目的是一样的，不过parcel不需要插件，而且速度快。 快速开始是真的快快速开始 没有配置，最好以html或者js为入口，直接npm init -y , parcel index.html，可以实现index.js。 它会自动帮你打包到dist目录下的一个js文件里面，并复制index.html过去，而这一切只需要上面的一行代码。 一开始我的项目的目录结构 执行parcel index.html的目录结构 而我当时搞webpack的时候的快速开始至少需要安装webpack、webpack.config.js、修改配置内容、安装插件才能实现上述的功能。 模块化和scss的解析很方便当我在parcel-demo目录下使用parcel index.html的时候，它自动发现我引入了index.js。 123&lt;body&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt; 里面的内容是模块化的内容，它自动帮我转成了dist/parcel-demo.js，我在webpack的时候需要babel-loader 我用的是scss,它也会自动发现，并且竟然 还帮我自动下载了node-sass 其他的特点都在官网去发掘吧～希望日后parcel快速崛起吧 而现在我还是要用webpack的……","categories":[{"name":"自动打包工具","slug":"自动打包工具","permalink":"https://codevvvv9.github.io/categories/自动打包工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://codevvvv9.github.io/tags/webpack/"}]},{"title":"持久化存储与HTTP缓存","slug":"持久化存储与HTTP缓存","date":"2018-02-11T15:50:34.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/11/持久化存储与HTTP缓存/","link":"","permalink":"https://codevvvv9.github.io/2018/02/11/持久化存储与HTTP缓存/","excerpt":"本文主要学习一下一些高级的HTTP知识，例如Session LocalStorage Cache-Control Expires ETag 其实主要就是涉及到了持久化存储与缓存的技术 在此之前已经学习了Cookie的相关知识，其中Cookie有个缺点可以人为修改，有一定的安全隐患。 所以，针对这个缺点，诞生了Session Session一般来说Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，除非暴力穷举才有可能获得敏感数据。 sessionId我们使用Cookie的时候，一般是服务器给用户一个响应头，设置Cookie 1response.setHeader('Set-Cookie', 'sign_in_email=...;HTTPOnly') 既然Session还是基于Cookie实现的，那么还是应该在Set-Cookie上搞事情。","text":"本文主要学习一下一些高级的HTTP知识，例如Session LocalStorage Cache-Control Expires ETag 其实主要就是涉及到了持久化存储与缓存的技术 在此之前已经学习了Cookie的相关知识，其中Cookie有个缺点可以人为修改，有一定的安全隐患。 所以，针对这个缺点，诞生了Session Session一般来说Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，除非暴力穷举才有可能获得敏感数据。 sessionId我们使用Cookie的时候，一般是服务器给用户一个响应头，设置Cookie 1response.setHeader('Set-Cookie', 'sign_in_email=...;HTTPOnly') 既然Session还是基于Cookie实现的，那么还是应该在Set-Cookie上搞事情。 12345678//预先在服务器端预留对象准备存储各种sessionlet sessions = &#123;&#125;...let sessionId = Math.random() * 100000sessions[sessionId] = &#123;sign_in_email: email&#125;response.setHeader('Set-Cookie', `sessionId=$&#123;sessionId&#125;;HTTPOnly`) 使用随机数来做sessionId,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的sessions对象里面。它就像一个密码簿一样，有效的信息与sessionId一一对应，这是服务器的事，保证了安全性。 当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个sessionId，服务器获得这个sessionId后，然后一转化就知道是正确的用户了。 12345let sessions = &#123; sessionId: &#123; sign_in_email: ... &#125;&#125; 持久化存储在HTML里面js文件里面的变量或对象，每当网页刷新的时候，就会死掉，又重新生成，虽然还是那个a，但是刷新后已经是另一块内存了。既然它也没变，我们为什么不把它一直保留着呢，即使刷新了a还是那个a，也就是持久化存储的意义。以前使用Cookie做这个功能，不过Cookie每次发请求会把Cookie里面的所有东西都带着去服务器，加重内存的负担，而且请求响应时间长，所以html5给了一个新的API localStorage 关于Cookie如何工作的，我发现这篇文章写得特别好 LocalStorage它本质上还是个hash，不过是存在于浏览器端的，不同于session存在与服务器端的hash。一般存储的都是没有用的或者不敏感的信息。 localStorage是window的全局属性，常用的有三个方法 123456//1. 添加键、值localStorage.setItem('a', '...')//2. 获得键、值localStorage。getItem('a')//3.清空localStoragelocalStorage.clear() 注意，它存的值全是字符串，即使你写的像对象也没有卵用。 如果想存储字符串需要用到JSON.stringify( ) 一个实际应用很简单的一个例子：网站进行更新了，用户登录进来了，想提示用户一下—我有新东西啦，这个提示并不应该在每次刷新的时候反复告诉用户，只是在第一次用户进来的时候告诉他即可。 1234567 let already = localStorage.getItem('已经提示过了') if (!already) &#123; alert('我们的网站新进了一些货物，您看一下有没有您需要的啊O(∩_∩)O～') localStorage.setItem('已经提示过了', true) &#125; else &#123;&#125; 当第一次访问的时候，already为null，所以进入if代码片段，提示用户一次，接着把already设为true，不会进入if，也就不再提示了。 不基于Cookie的session学习了localStorage，就可以搞一些黑科技了，前面说了，session一般是基于Cookie的，那么有没有例外呢。 有的。利用查询参数和localStorage可是实现sessionId`。 小结一下 Cookie的特点 服务器通过 Set-Cookie 头给客户端一串字符串 客户端每次访问相同域名的网页时，必须带上这段字符串 客户端要在一段时间内保存这个Cookie Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间。比如max-age和后面要讲的Expires 大小大概在 4kb 以内 Session的特点 将 SessionID（随机数）通过 Cookie 发给客户端 客户端访问服务器时，服务器读取 SessionID 服务器有一块内存（哈希表）保存了所有 session 通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email 这块内存（哈希表）就是服务器上的所有 session LocalStorage的特点 LocalStorage 跟 HTTP 无关 也就是说发送任何请求都不会带上 LocalStorage 的值 只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格） 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样） 常用场景：记录有没有提示过用户（没有用的信息，不能记录密码等敏感信息） LocalStorage 永久有效，除非用户清理缓存 SessionStorage会话存储主要特点与localStorage基本相同，最大的不同是SessionStorage在用户关闭页面（会话结束）后就失效。 HTTP缓存技术三兄弟假如说我们要访问的的文件比较大，我们请求完之后，下载需要花很长时间，当我们刷新页面的时候，虽然文件没有任何更新，但是我们又从服务器端下载了一遍大文件，导致每次响应时间依然很长。 通过上图的实验可以看到localhost的请求响应很快，10ms；而default.css、main.js文件较大，响应时间是localhost的25倍，而jq文件使用了cdn加速，是从内存的缓存中获得的，几乎瞬间。如果每次都这样的话，用户体验肯定很差。 那么我们能不能在第一次响应完毕之后，如果资源没有更新，就不去服务器端下载，而是去某个地方获得呢？ 答案是肯定的，可以实现，通过缓存，正如上图的jq实现的方法一样。 这部分可以作为web性能优化的一个方法。 Cache-Control通过max-age设置缓存的有效时间(持续时间) 1234567if (path === '/css/default.css')&#123; let string = fs.readFileSync('./css/default.css', 'utf8') response.setHeader('Content-Type', 'text/css;charset=utf-8') response.setHeader('Cache-Control', 'max-age=1000000') response.write(string) response.end() &#125; 在响应头里面加上Cache-Control，表示在100000秒内不要再去向服务器要这个资源了，就从我的内存缓存里面获得。 虽然使用了缓存技术，不过有一点疑惑的就是有时候从硬盘的缓存里面获得，这个速度提升并不大，但是仍然避免了向服务器再次发起请求获得资源的过程；有时候从内存的缓存里面获得，这个就特别快了。大概是因为内存的缓存特别快吧。 通常我们把Cache-Control的有效时间设的很长。 以经常逛得知乎为例。 如果一个文件长期不变，把它设为从缓存里面获得，知乎设置了32596169秒的有效时间，超过了1年=31536000秒的时间。 首页尽量不用缓存技术我们刷一些论坛性质的或者新闻性质的网站，注重时效性，一般会把爆炸性的、高质量的内容放到首页去，如果我们看了一会，想刷新看看新的更新的内容，而你设了缓存，看到的还是10分钟之前的首页，那就太尴尬了☺…… 所以首页尽量不用缓存技术，只对那些长期不变的文件、图片等使用缓存技术。 还是以知乎为例。 对于知乎的Cache-Control的写法我是比较懵逼的。 MDN的语法上 public Indicates that the response may be cached by any cache. private Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response. no-cache Forces caches to submit the request to the origin server for validation before releasing a cached copy. no-store The cache should not store anything about the client request or server response. must-revalidate The cache must verify the status of the stale resources before using it and expired ones should not be used. MDN推荐关闭缓存的写法是Cache-Control: no-cache, no-store, must-revalidate。 那么如果有的资源确实被更新了，如何去更新缓存呢。 更新缓存通过服务器端代码server.js我们可以发现 123456789if (path === '/js/main.js') &#123; ... response.setHeader('Cache-Control', 'max-age=1000000') ...&#125; else if (path === '/css/default.css')&#123; ... response.setHeader('Cache-Control', 'max-age=1000000') ...&#125; 只要当URL符合要求的时候，会使用缓存技术，不去发起请求重新下载资源。 所以当文件确实被更新了之后，我们可以改变URL，那么就会去重新下载新的文件了。 既然我们的网页入口是html，可以在这里面动手脚 123...&lt;script src=\"./js/main.js?V2\"&gt;&lt;/script&gt;... 当你更新代码之后，理论上只需要在URL上添加查询参数？V2即可。 我们还是去知乎看看他们的例子。 可以看到知乎也是把URL改了，只不过比我那种高级，它在文件名字动了手脚，大概是用了什么框架或者处理工具吧，不过更新缓存的思路上是一样的。文件变了，知乎就把文件缓存的URL填点东西；没变的话，就缓存一年，在你的硬盘某处睡一年^_^。 小结一下使用缓存就用response.setHeader(&#39;Cache-Control&#39;, &#39;max-age=100000&#39;)，当你想更新的时候就改变文件的URL。 当然，缓存存多了，你的硬盘估计就爆了，浏览器会去权衡这些的，应该优先清楚哪些缓存，是浏览器的事。 俗话说得好啊，吃井不忘挖井人啊，要学会忆苦思甜啊，我们现在用的可爽的Cache-Control也不是凭空冒出来的，是有历史原因的，以前呢，是用Expires实现缓存的技术。 ExpiresExpires的英文是到期的意思，很明显是与缓存有关的技术，不过从其英文意思也能看出它是到某个时间点截止的意思，不是Cache-Control的有效时间。 从语法和示例可以看出它是基于格林威治时间的。 我们还要处理一下时间 12var d = new Date() //Sat Feb 10 2018 11:18:54 GMT+0800 (CST)d.toGMTString() //\"Sat, 10 Feb 2018 03:18:54 GMT\" 能看出来，这个响应头的最大的弊端在于，时间戳是与你的本地时间关联的 如果本地电脑的时间系统错乱了，而且这种毛病还真的时常发生，那你的缓存就毫无作用了。maybe这就是HTTP要升级这个响应头的原因吧O(∩_∩)O～ 当Cache-Control和Expires共同存在的时候 如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么 Expires 头就会被忽略。 关于缓存的技术，还有最后一个兄弟ETag，在搞定它之前，先来学习一下它的小跟班MD5 MD5MD5是一个摘要算法。经常用于比较两个文件是否完全一样，如果有一点不一样，误差会放大。例如我们经常重装系统的话，有良心的系统提供者会给你一个对应的MD5值，当你下载完毕后，查看你下载的系统的MD5值是否与官方提供给你的一样，确保是否会因为网络原因导致你下载的东西不完整。 在Linux系统里面使用md5sum指令进行MD5校验 第一个红框里面就是1.txt文件(内容设定为123456)的MD5值，第二个红框里面就是1-copy文件(内容被我改为了123460)的MD5值。 在nodejs里面如何使用呢，Google后发现有npm的MD5。 1234npm install md5...//在server.js引入var md5 = require('md5'); 准备工作做完，可以搞ETag了。 ETag The ETag HTTP response header is an identifier for a specific version of a resource.It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (“mid-air collisions”). If the resource at a given URL changes, a new Etag value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server. 这个响应头是特定资源版本的标识符。 如果给定URL中的资源更改，则一定要生成新的Etag值。因此Etags类似于指纹，也可能被某些服务器用于跟踪。 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。 可以看出ETag应该是一串值，此时上一节的MD5就派上用场了，我们使用MD5来比较前后两次请求文件的内容。 当某个URL来访问服务器的资源的时候，如果服务器设置了响应头ETag:一串md5值，那么 现在没有什么其他变化，如果第二次刷新的话，你会发现 请求头多了一个If-None-Match:一串MD5值。 比较上述两图，我的main.js没有改变过，发现ETag:一串md5值和If-None-Match:一串MD5值的一样，稍微一思考的话，就能明白，第二次刷新的时候如果我的main.js变了的话，那么 第二次向服务器发起请求，下载的main.js的ETag的MD5值必然不同了。 根据这个现象，然后结合MDN文档 ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的If-None -Match header字段： 12&gt; If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;&gt; 服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用（新鲜）。 可以推理出如下的代码了： 123456789101112if (path === '/js/main.js') &#123; let string = fs.readFileSync('./js/main.js', 'utf8') response.setHeader('Content-Type', 'application/javascript;charset=utf-8') let fileMd5 = md5(string) response.setHeader('ETag', fileMd5) if (request.headers['if-none-match'] === fileMd5) &#123; response.statusCode = 304 &#125; else &#123; response.write(string) &#125; response.end() &#125; 304状态码的含义 HTTP 304 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match或If-Modified-Since。 304和缓存的区别： 缓存不会发起请求了，直接从内存或者硬盘中获得 304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。 几个常见的考题Cookie和Session的区别 Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。 而Session是存放在服务器端的内存中，其 Session ID 是通过 Cookie 发送给客户端的，这个Session ID每次都随请求发送给 Server。 Cookie 和 LocalStorage 的区别 Set-Cookie之后，用户的每次访问服务器，请求里面都会带着Cookie到服务器上，与HTTP有关，而LocalStorage不用发到服务器端，它是存储在浏览器里面的，与HTTP无关，是浏览器的属性，window.localStorage。 Cookie一般比较小，大约4k左右，而LocalStorage大约能用5M Cookie默认会在用户关闭页面后失效，不过后端可以设置保存时间，而LocalStorage永久有效，除非用户手动清理。 LocalStorage 和 SessionStorage 的区别 LocalStorage永久有效，除非用户手动清理localStorage.clear()。不会自动过期 但是SessionStorage在会话结束后就会失效，也就是用户关闭了页面，就失效了。会自动过期 Cookie 如何设置过期时间？如何删除 Cookie？ 设置过期时间：Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt; data`是格林威治时间，响应头里里面应该这么写代码 1response.setHeader('Expires', 'Fri, 09 Feb 2018 11:29:48 GMT') 也就是说Cookie在格林威治时间的2018年2月9号的11点29分48秒失效。 设置cookie过期时间小于当前时间，那么就会删除该cookie。 123function deleteCookie(name) &#123; document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;'&#125; Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？ Cache-Control: max-age=1000的缓存 是直接不发请求的，1000秒内相同URL的用户请求资源的时候，不会再去发请求访问服务器了，直接从本地内存的缓存里面获取 ETag的缓存是不管怎么样都要发起请求，第二次访问的是时候会多一个请求头If-None-Match : md5值，如果两次请求之间的MD5值相同就不会去下载新的文件，响应体是第一次下载的；如果MD5值变了，就要去下载新的文件。","categories":[{"name":"HTTP高级知识","slug":"HTTP高级知识","permalink":"https://codevvvv9.github.io/categories/HTTP高级知识/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://codevvvv9.github.io/tags/HTTP/"}]},{"title":"一块小饼干的故事-Cookie-的故事-下篇","slug":"一块小饼干的故事-Cookie-的故事-下篇","date":"2018-02-09T15:33:53.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/09/一块小饼干的故事-Cookie-的故事-下篇/","link":"","permalink":"https://codevvvv9.github.io/2018/02/09/一块小饼干的故事-Cookie-的故事-下篇/","excerpt":"上篇介绍了注册的基本流程，下篇简单的讲讲登录的流程以及Cookie的出现 实现登录的小功能当你在浏览器的输入框里输入localhost:8080/sign_in的时候，会发起GET请求，去访问sign_in.html 1234567if (path === '/sign_up' &amp;&amp; method === 'GET') &#123; let string = fs.readFileSync('./sign_up.html', 'utf8') response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.end()&#125; CSS布局与上篇的布局基本一样，略去不表～","text":"上篇介绍了注册的基本流程，下篇简单的讲讲登录的流程以及Cookie的出现 实现登录的小功能当你在浏览器的输入框里输入localhost:8080/sign_in的时候，会发起GET请求，去访问sign_in.html 1234567if (path === '/sign_up' &amp;&amp; method === 'GET') &#123; let string = fs.readFileSync('./sign_up.html', 'utf8') response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.end()&#125; CSS布局与上篇的布局基本一样，略去不表～ 比对用户的信息与数据库里面的信息是否匹配依然是上篇的套路，获得用户formdata后，分析数据，和数据库里面的比对 1234567891011121314151617181920var users = fs.readFileSync('./db/users', 'utf8')try &#123; users = JSON.parse(users) //[] JSON也支持数组&#125; catch (exception) &#123; users = []&#125;let found for (let i = 0; i &lt; users.length; i++) &#123;if (users[i].email === email &amp;&amp; users[i].password === password) &#123; found = true break &#125;&#125;if (found) &#123; response.setHeader('Set-Cookie', `sign_in_email=$&#123;email&#125;;HTTPOnly`) response.statusCode = 200&#125; else &#123; response.statusCode = 401&#125; 不同的是引入了一个header，也就是今天的主角–Cookie 其实这和平常上网的情形类似的，有时候我们访问一些购物网站，并没有登录，但是你在购物车里面添加东西了，当你逛了以后再回来的时候，发现购物车里面有你的记录，帮你做这个事的也是cookie。 因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话)中的状态。 可以看出，当你在sign_in发起GET请求并设置了Set-Cookie之后，其他的同源的页面，又都会带上Cookie，也就能保证同源的网页向服务器发起请求的时候，服务器能够明白，你己经是登录的用户了，与那些没有拿到cookie的页面区别开来。 Cookie的入门为什么要在cookie里面写上HttpOnly呢，因为这个可以防止有些牛人使用JS修改Cookie的内容。 如果不写这个的话，可以使用js修改的 写了HttpOnly之后将无法修改 _ga是啥这个是Chrome的功能，用于分析cookie的 每一部分的作用详见这里 Cookie的特点通过上述的例子，可以总结几点重要的特点 服务器通过 Set-Cookie 响应头设置 Cookie 浏览器得到 Cookie 之后，每次请求都要带上 Cookie 服务器读取 Cookie 就知道登录用户的信息（email） 当然了，还有几个问题需要解答一下。 Cookie 存在哪存在硬盘的一个文件里面 Cookie会被用户篡改吗？可以，也就是说它并不安全的。 Cookie 有效期吗？ 默认有效期20分钟左右，不同浏览器策略不同后端可以强制设置有效期 12Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt; 具体语法看 Set-Cookie 用户登录后，首页显示不同既然你成功登录，理应跳转到首页，并显示相应的界面。 12345678$.post('/sign_in', hash).then((response) =&gt; &#123; window.location.href = '/'&#125;, (request) =&gt; &#123; alert('邮箱与密码不匹配') &#125;) 然后首页的信息应该根据用户信息做出相应的变化 1234567891011121314151617181920212223let cookies = request.headers.cookie.split('; ') //['email=..@..', 'a=1']let hash = &#123;&#125;cookies.forEach((cookie) =&gt; &#123; let parts = cookie.split('=') let key = parts[0] let value = parts[1] hash[key] = value&#125;)let email = hash.sign_in_emaillet users = fs.readFileSync('./db/users', 'utf8')users = JSON.parse(users)let foundUserfor (let i = 0; i &lt; users.length; i++) &#123; if (users[i].email === email) &#123; foundUser = users[i] break &#125;&#125;if (foundUser) &#123; string = string.replace('email', foundUser.email)&#125; else &#123; string = string.replace('恭喜，email你已成功登录', '没有该用户')&#125; 这里的代码逻辑与上篇的基本一致，唯一的不同在于第一行代码 let cookies = request.headers.cookie.split(&#39;; &#39;) //[&#39;email=..@..&#39;, &#39;a=1&#39;] 为什么用；字符来分割呢，这是因为可以有多个cookie Cookie的两个作用一般来说常见的作用有如下两个： 识别用户的身份。当用户A去访问localhost:8080的时候，服务器会给A一个独一无二的id=00A(这就是cookie)，当用户A访问localhost:8080的其他网页的时候，都会带着那个独一无二的id。当B用户来访问localhost:8080的时候，服务器发现他没有任何标识，也会给他一个独一无二的id=00B，所以借助cookie服务器端就能够分清楚谁是谁了。 记录你的浏览历史。最常见的需求就是你去逛购物网站，你添加到购物车里面的东西过几天一定会在，而不会凭空消失了。例如A用户去taobao.com去买点东西，添加了一个热水壶、一部小米手机到购物车里面，那么服务器端可以改写你上面的cookie使之具体化「id=00A; cart=A1,A2」，表示你购物车里面买了俩东西。你过几天想起来了，去购物车里面看，热水壶、小米手机还在里面。浏览器并不会删除你存到硬盘上的cookie。 一张图总结注册登录的过程 接下来可以去搞一搞其他的，像什么session LocalStorage……(@ο@) 哇～ 代码链接sign_in.html server.js","categories":[{"name":"HTTP高级知识","slug":"HTTP高级知识","permalink":"https://codevvvv9.github.io/categories/HTTP高级知识/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://codevvvv9.github.io/tags/HTTP/"}]},{"title":"一块小饼干-Cookie-的故事-上篇","slug":"一块小饼干-Cookie-的故事-上篇","date":"2018-02-09T15:28:24.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/09/一块小饼干-Cookie-的故事-上篇/","link":"","permalink":"https://codevvvv9.github.io/2018/02/09/一块小饼干-Cookie-的故事-上篇/","excerpt":"cookie 如果非要用汉语理解的话应该是 一段小型文本文件，由网景的创始人之一的卢 蒙特利在93年发明。 上篇是熟悉一下注册的大致流程，下篇熟悉登录流程以及真正的Cookie 实现基本的注册功能我们打开网站，浏览网站，最常见的两个操作就是注册以及登录，所以有必要探索一下这两个功能如何实现的。 本地模拟，当输入localhost:8080/sign_up的时候，浏览器发起get请求，服务器给你响应sign_up.html 12345678//服务器端代码if (path === '/sign_up' &amp;&amp; method === 'GET') &#123; let string = fs.readFileSync('./sign_up.html', 'utf8') response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.end() &#125;","text":"cookie 如果非要用汉语理解的话应该是 一段小型文本文件，由网景的创始人之一的卢 蒙特利在93年发明。 上篇是熟悉一下注册的大致流程，下篇熟悉登录流程以及真正的Cookie 实现基本的注册功能我们打开网站，浏览网站，最常见的两个操作就是注册以及登录，所以有必要探索一下这两个功能如何实现的。 本地模拟，当输入localhost:8080/sign_up的时候，浏览器发起get请求，服务器给你响应sign_up.html 12345678//服务器端代码if (path === '/sign_up' &amp;&amp; method === 'GET') &#123; let string = fs.readFileSync('./sign_up.html', 'utf8') response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.end() &#125; CSS布局的几个小坑在写sign_up.html的时候，注意几点css知识： 如果想让你的登录页面的body占满整个屏幕，随着窗口的大小变化而变化的话，可以写 123456body, html&#123;height: 100%&#125;//或者body&#123;min-height: 100%&#125;html&#123;height: 100%&#125;//不能这么写body, html&#123;min-height: 100%&#125; 当然了，实际上这么写就可以了 1body&#123;min-height: 100vh&#125; label标签是display: inline，不能设置宽度，行内元素则会根据行内内容自适应宽度，所以行内元素设置width是没有效果的。改成inline-block就可以了 获得用户的数据既然是注册的需求，那么我们首要关注的点就是–用户的注册信息我们如何获得呢 选择合理的数据结构存储数据是很重要的。 每个input的name可以使用数组存储 input的value应该使用hash,也就是对象来存储。 上述的套路会一直用下去，hash+[]的组合。 12345678910//使用jq来写let hash = &#123;&#125;let $form = $('#signUpForm')$form.on('submit', (e) =&gt; &#123; e.preventDefault() //不用form表单的默认提交，而是使用我们的的ajax提交 let need = ['email', 'password', 'password_confirmation'] need.forEach((name) =&gt; &#123; let value = $form.find(`[name=$&#123;name&#125;]`).val() hash[name] = value&#125;) 最终hash里面存储的就是 12345&#123; 'email': '...', 'password': '...', 'password_confirmation': '...'&#125; 到目前为止我们把用户的数据封装到了一个对象里面了。 不过在把hash用ajax发出去之前要先进行一些必要的非空验证 非空验证主要是检测邮箱是否为空、密码是否为空、两次输入的密码是否一致。 1234567891011121314151617//发起请求之前验证是否为空if (hash['email'] === '') &#123; $form.find('[name=\"email\"]').siblings('.errors').text('请您输入邮箱') return false //精髓啊，不然没用了&#125;if (hash['password'] === '') &#123; $form.find('[name=\"password\"]').siblings('.errors').text('请您输入密码') return false //精髓啊，不然没用了&#125;if (hash['password_confirmation'] === '') &#123; $form.find('[name=\"password_confirmation\"]').siblings('.errors').text('请您再次输入确认密码') return false //精髓啊，不然没用了&#125;if (hash['password'] !== hash['password_confirmation']) &#123; $form.find('[name=\"password_confirmation\"]').siblings('.errors').text('两次输入密码不匹配') return false //精髓啊，不然没用了&#125; 如果忘记写return的话，即使你为空了还是会直接越过这一步检测，去发起ajax请求的，所以一定不要忘了写上return false. 如果仅仅这么写的话会有一个bug。当出现错误提示后，你把信息填对了，错误信息依然显示，这显然是不合理的。应该填入信息后，错误信息就消失的。 123$form.find('.errors').each((index, span) =&gt; &#123; $(span).text('')&#125;) 使用上述的jq代码来解决这个bug即可。 非空验证完了之后，意味着浏览器收集用户数据的工作完成了，可以把hash发到服务器端了，接下来就是ajax请求了。 使用ajax提交数据12345678$.post('/sign_up', hash).then((response) =&gt; &#123; //成功了就打印这个 console.log(response)&#125;,() =&gt; &#123; //错误了打印这个&#125;) 服务器端解析formData因为formData是一段一段上传的(具体原因略复杂，可以取极限法，如果formdata很多，不可能一下子上传过来)，自己不会写，就去搜索代码片段解析formdata google: node get post data 把获得的代码封装成了一个函数 12345678910111213function readBody(request) &#123; return new Promise((resolve, reject) =&gt; &#123; let body = [] request.on('data', (chunk) =&gt; &#123; body.push(chunk) &#125;).on('end', () =&gt; &#123; body = Buffer.concat(body).toString(); resolve(body) &#125;) &#125; )&#125; 如何使用上述代码片段呢 123456789101112131415...if (path === '/sign_up' &amp;&amp; method === 'POST') &#123; readBody(request).then((body) =&gt; &#123; let strings = body.split('&amp;') //['email=1', 'password=2', 'password_confirmmation=3'] let hash = &#123;&#125; strings.forEach(string =&gt; &#123; //想得到类似这种的 string == 'email=1' let parts = string.split('=') //再用=分割,得到['email', '1'] let key = parts[0] let value = parts[1] hash[key] = decodeURIComponent(value)//hash['email'] = '1' &#125;) let &#123;email, password, password_confirmation&#125; = hash //ES6的解构赋值 &#125; ... 当服务器端接收到了所有的formdata数据后，其实是一串形如email=1&amp;password=2&amp;password_confirmation=3 的字符串，所以我们考虑使用&amp;字符分割成数组。 得到一个形如[&#39;email=1&#39;, &#39;password=2&#39;, &#39;confirmation=3&#39;]的数组之后，我们为了得到string = &#39;email=1&#39;这种形式的，开始遍历数组，把数组的每个元素按照=分割，得到 [email, 1] 用第二小节提供的hash+[]方法，处理成hash 服务器端简单的校验既然服务器端已经获得了formdata了，那么应该进行一下简单的校验，比如邮箱的格式，没有问题了就把数据存到数据库里面。(目前校验水平很入门，没有涉及到完备的注册校验功能) 校验前的准备工作上一节我们把formdata完美的封装到了hash里面，为了校验我们要把hash再拆开一个一个的看 或许这么做是最直接的 123let email = hash['emai']let password = hash['password']let password_confirmation = hash['password_confirmation'] 不过ES6提供了一种解构赋值的语法糖，很甜很贴心…… 1let &#123;email, password, password_confirmation&#125; = hash 由@编码引发的bug好了，我们这一步就先看看邮箱格式是否正确。 我是菜鸟级校验邮箱，看到了邮箱的独特标志---@，最起码有这个标志才叫邮箱吧，也就是说没有这个标志，我就可以认为邮箱格式不对啊，翻译成代码就是 1234if (email.indexOf('@') === -1) &#123; response.statusCode = 400 response.write('email is bad') //单引号只是为了标记这是一个字符串&#125; 很好，目前来说，事情的发展都很正常，直到一个bug的到来。 一个合法的邮箱，却进入了非法邮箱处理的代码片段里面…… 毫无疑问，邮箱是合法的，代码也是合理的，那么出问题的必然是我，某个地方的理解有问题。 找bug,把可能出错的代码片段分成几个区间，打log. 12console.log(email.indexOf('@'))console.log(email) 没错，email这个字符串的@索引真的是-1，可是我的邮箱写的明明有@啊。 为啥呢，接着又打印出了email的内容，终于真相大白了，email字符串里面真的没有@， 却发现了一串你没想到的%40，(⊙v⊙)嗯，没错了，这就是我认为的那个@的另一个形态。 我在浏览器看到的只是浏览器想让我看到的东西而已，既然已经被浏览器处理了，那到了服务器端自然无法处理。 那这个%40哪来的呢 Google走起，在w3schools的HTML URL Encoding Reference找到了解释(不是国内的w3school……) URL encoding converts characters into a format that can be transmitted over the Internet. URL编码把字符转化成了一种可以在互联网上传播的格式，也就是说，我在网页上看到的字符是被URL编码处理的结果。 那接下来就去搞定什么是URL编码 搞定这个之前，文档先要让你明白啥是URL Web browsers request pages from web servers by using a URL. The URL is the address of a web page, like: https://www.w3schools.com. Web浏览器通过使用URL从Web服务器请求页面。 该网址是网页的地址，例如：https：//www.w3schools.com。 复习一下URL的组成6部分： https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5 通过这个你就可以访问到一个 “唯一的” 网址 名字 作用 https: 协议 www.baidu.com 域名 /s 路径 wd=hello&amp;rsv_spt=1 查询参数 #5 锚点 端口 默认80 复习完了URL，继续搞URL编码 URLs can only be sent over the Internet using the ASCII character-set. Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format. URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits. URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20. URL只能用ASCII编码在互联网之间发送。 既然URL通常包括ASCII字符编码集之外的字符(很明显嘛，ASCII码表太少)，所以URL必须转化成有效的ASCII格式。 这是重点，URL编码使用%后面紧跟着两个16进制数字的编码格式来代替不安全的ASCII码表 URL不能包括空格。所以URL编码通常使用+号或者20%来代替空格。 继续往下翻，找到了%40。 所以要把value的值解码回去 1hash[key] = decodeURIComponent(value) decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。毕竟URL属于URI。 错误信息的提示方法如果有了错，需要提示用户错了，后端写的代码，用户不一定看的懂，需要前端润色一下使用户看懂，或者前端和后端沟通一下，maybe后端脾气不好，前端也是暴脾气，所以应该选择一个前后端都要用的东西做桥梁，很明显JSON是完美的候选人。 1234567891011if (email.indexOf('@') === -1) &#123; response.statusCode = 400 response.setHeader('Content-Type', 'application/json;charset=utf-8') //直接告诉浏览器我是json response.write(` &#123; \"errors\": &#123; \"email\": \"invalid\" &#125; &#125; `)&#125; 这就合理多了，后台只管写个json给前台看，其他不管了，前台翻译一下给用户看喽～ 那么前台如何获得这个json呢 12345678910$.post('/sign_up', hash).then((response) =&gt; &#123; //成功了就打印这个 console.log(response)&#125;,(request, b, c) =&gt; &#123; console.log(request) console.log(b) console.log(c)&#125;) 忘记了错误函数里面的参数是啥了，那就都打印出来看看。 可以看到，如果没用JSON的话，request对象里面有一个后端写的responseText属性可以利用。 设置了Content-Type:application/json;charset=utf-8之后，可以利用多出来的responseJSON属性，获得json的内容啊。 最终失败函数里面写 123456(request) =&gt; &#123; let &#123;errors&#125; = request.responseJSON if (errors.email &amp;&amp; errors.email === 'invalid') &#123; $form.find('[name=\"email\"]').siblings('.errors').text('您输入的邮箱错啦') &#125;&#125; 校验邮箱是否已经存在了12345678910111213141516171819202122232425var users = fs.readFileSync('./db/users', 'utf8')try &#123; users = JSON.parse(users) //[] JSON也支持数组&#125; catch (exception) &#123; users = []&#125;let inUse = falsefor (let i = 0; i &lt; users.length; i++) &#123; let user = users[i] if (user.email === email) &#123; inUse = true break &#125;&#125;if (inUse) &#123; response.statusCode = 400 response.setHeader('Content-Type', 'application/json;charset=utf-8') response.write(` &#123; \"errors\": &#123; \"email\": \"inUse\" &#125; &#125; `)&#125; 本文并没有使用真正意义上的数据库，只是使用了简单的db文件做数据库，其实就是存的数组，也就是users其实就是数组[]。 之所以使用了try{}catch(){}，是因为一旦除了错，可以将其初始化为空数组，后续代码可以继续执行，可能并不严谨，不过本文是侧重了解注册的思路的。 同样的，如果邮箱已经存在了，就提示用户 123if (errors.email &amp;&amp; errors.email === 'inUse') &#123; $form.find('[name=\"email\"]').siblings('.errors').text('这个邮箱已被注册啦')&#125; 后端校验必须很严格，因为可以通过curl越过前端的校验。 把信息写入数据库没有错误之后，就可以把信息写到数据库里面啦 1234users.push(&#123;email: email, password: password&#125;)//是个对象啊var usersString = JSON.stringify(users)fs.writeFileSync('./db/users', usersString)response.statusCode = 200 users实现是个对象，而对象是内存里面的东西，数据库里面应该存储的是字符串，所以用了JSON.stringify(users) 好啦，上篇注册篇结束啦，下篇讲一讲如何登录以及Cookie登场 相关代码见sign_up.html server.js","categories":[{"name":"HTTP高级知识","slug":"HTTP高级知识","permalink":"https://codevvvv9.github.io/categories/HTTP高级知识/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://codevvvv9.github.io/tags/HTTP/"}]},{"title":"科学上网","slug":"科学上网","date":"2018-02-03T13:02:02.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/02/03/科学上网/","link":"","permalink":"https://codevvvv9.github.io/2018/02/03/科学上网/","excerpt":"","text":"科学上网如何科学上网是个很严肃的问题(⊙o⊙)哦 以Linux为例12sudo apt-get install python-pip; sudo pip install shadowsocks; 如果你遇到 _cleanup 不存在的提示，可能是遇到 bug 了，你要将 openssl.py 中的 _cleanup 全部改为 _reset 才行。 如果你不会改，使用 12sed -i 's/_cleanup/_reset/g' xxxxxxxxxxxxxxxxxxxxxx/openssl.py // 注意把 xxxxxxxxxxxxxxxxxxxxxx/openssl.py 改成图中的 openssl.py 文件的路径 创建sslocal 配置文件创建 sslocal 配置文件（如果你不知道在哪创建就创建在 ~/.ssconf.json），配置文件的内容可使用我的服务器，你也可以自己买服务器（显然自己买服务器更靠谱） 12345678910&#123; \"server\":\"45.76.180.233\", //自己买 \"server_port\":27148, //自己买 \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"A7#x8Jyzme)jkFfc\", //自己买 \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; 可以使用了 使用 ss-local -c ~/.ssconf.json 或 sslocal -c ~/.ssconf.json 开启代理，其中 ~/.ssconf.json 是配置文件的路径-","categories":[{"name":"Linux入门","slug":"Linux入门","permalink":"https://codevvvv9.github.io/categories/Linux入门/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://codevvvv9.github.io/tags/Linux/"}]},{"title":"AJAX的出现与跨域","slug":"AJAX的出现与跨域","date":"2018-01-31T12:21:24.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/31/AJAX的出现与跨域/","link":"","permalink":"https://codevvvv9.github.io/2018/01/31/AJAX的出现与跨域/","excerpt":"XMLHttpRequest JSON AJAX CORS 四个名词来开会 如何发请求在前端的世界里也逛荡了不少日子了，目前已经get到大约5种发起请求的方式，主流的、非主流的。 何种方式 请求方法 最常见的form表单 默认GET，多用POST,只此两种 会刷新页面或者新开页面 a 标签 GET请求 也会刷新页面或者新开页面 img的src属性 GET 只能以图片的形式展现 link标签 GET 只能以CSS、favicon的形式展现 script标签 GET 只能以脚本的形式运行 可是 我们可能想用GET POST PUT DELETE 方法 不想刷新整个页面，想用一种更易于理解的方式来响应","text":"XMLHttpRequest JSON AJAX CORS 四个名词来开会 如何发请求在前端的世界里也逛荡了不少日子了，目前已经get到大约5种发起请求的方式，主流的、非主流的。 何种方式 请求方法 最常见的form表单 默认GET，多用POST,只此两种 会刷新页面或者新开页面 a 标签 GET请求 也会刷新页面或者新开页面 img的src属性 GET 只能以图片的形式展现 link标签 GET 只能以CSS、favicon的形式展现 script标签 GET 只能以脚本的形式运行 可是 我们可能想用GET POST PUT DELETE 方法 不想刷新整个页面，想用一种更易于理解的方式来响应 AJAX出现浏览器和服务器交互模式 V1.0在AJAX未出现之前，浏览器想从服务器获得资源，注意是获取资源，会经过如下一个过程 浏览器发起请求-&gt;服务器接到请求响应给你HTML文档-&gt;浏览器收到资源，刷新页面，加载获得的的HTML。简略的过程 我称这种交互方式是 V1.0，此时还是以获取资源为导向。后来随着时代的发展，人们日益增长的文化需求成为了社会的主要矛盾……有一天，小明看了一篇报道，他只是想在下面评论一下，发表对实事的亲切问候，问候完了，唉，你给我刷新页面干啥，我只是想评论一下啊。 大概那是网民们第一次对 良好的用户体验 提出了要求。后来的苹果爸爸，把大家惯坏了，天天嚷着 “你这产品用户体验太差了”…… 彼时，微软还是对web做出了很大的贡献的。 交互模式2.0大约1999年，微软发布IE 5.0版本，它允许JavaScript脚本向服务器发起HTTP请求。不过很遗憾，当时也没有火起来，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。2005年，一个叫Jesse James Garrett的人提出了一个新术语—-AJAX，它是一系列技术的组合体，全称是 Asynchronous JavaScript + XML(异步的JS和XML)可以阻止页面整体刷新，只是动态响应用户的操作，快速显示到局部，用户就可以很愉快的继续上网了。 AJAX 可以看出IE当时还是很猛的，随着IE 6.0 市场份额进一步扩大，IE已经把火狐整的半死不活，放眼整个浏览器市场，微软是当之无愧的王者，后来微软就把浏览器团队解散了……不得不说这是一波神操作，能与之媲美的操作大概只有残血我能反杀 塔下我能秀他了。微软强行为后续各家浏览器的发展提供了优秀的工程师，尤其是08、09年出生的谷歌浏览器，再看如今的IE…… 既然AJAX是一系列的技术的组合体，接下来认识一下其中的几位主角 XMLHttpRequestXMLHttpRequest对象是用来在浏览器和服务器之间传输数据的。 古代的操作的是： 浏览器构造XMLHttpRequest实例化对象 用这个对象发起请求 服务器响应一个XML格式的字符串，是字符串，是字符串，是字符串，也就是说响应的第四部分是字符串。 JS解析符合XML格式的字符串，更新局部页面。 什么是XML，可扩展标记语言。 以上是最初的用法，用的是XML，前端代码片段如下 12345678910111213141516171819202122let request = new XMLHttpRequest() //实例化XMLHttpRequest对象request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; console.log('请求和响应都完毕了') if (request.status &gt;= 200 &amp;&amp; request.status &lt;= 300) &#123; console.log('说明请求成功了') console.log(request.responseText) let parser = new DOMParser() let xmlDoc = parser.parseFromString(request.responseText, \"text/xml\") //用parser解析request.responseText let c = xmlDoc.getElementsByTagName('body')[0].textContent console.log(c) &#125; else if (request.status &gt;= 400) &#123; console.log('说明请求失败了') &#125; &#125; &#125;request.open('GET', '/xxx') //配置requestrequest.send() 服务器端的对应代码片段如下 1234567891011121314...response.statusCode = 200response.setHeader('Content-Type', 'text/xml;charset=utf-8')response.write(`&lt;note&gt; &lt;to&gt;木木&lt;/to&gt; &lt;from&gt;少少&lt;/from&gt; &lt;heading&gt;你好哇&lt;/heading&gt; &lt;body&gt;好久不见啊&lt;/body&gt;&lt;/note&gt;`)response.end()... 本地模拟的话,一定要记得开俩不同的端口例如: 12node server.js 8001node server.js 8002 XMLHttpRequest实例的详解正如上面的前端代码片段写的一样，主要用到了open() send()方法， onreadystatechange readyState 属性。 request.open(method, URL, async)方法。 一般用三个参数，第一个参数是请求的方法，可以用GET POST DELETE PUT等等，URL是用访问的路径，async是是否使用同步，默认true,开启异步，不需要做修改即可，所以实际中只写前两个参数 如果非要写false，开启同步，会对浏览器有阻塞效应，而且如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据 request.send()方法。 发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回 readyState属性。 描述请求的五个状态。 0 === 常量 UNSENT(未打开) open()方法未调用 1 === OPENED (未发送) 只是open()方法调用了 2 === HEADERS_RECEIVED (已获取响应头) send()方法调用了，响应头和响应状态已经返回了 3 === LOADING (正在下载响应体) 响应体下载中，responseText已经获取了部分数据 4 === DONE (请求完成) 整个响应过程完毕了。 这个值是实际中用到的。 只要不等于4，就表示请求还在进行中。 responseText属性是此次响应的文本内容。 onreadystatechange属性。 readyState属性的值发生改变，就会触发readyStateChange事件。 我们可以通过onReadyStateChange属性，指定这个事件的回调函数，对不同状态进行不同处理。尤其是当状态变为4的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。即前面的代码片段的处理方式。 其他的方法、属性、事件详见阮一峰博客、MDN文档 习惯用javaScript的前端是不想和XML打交道的，应该用一种符合js风格的数据格式语言。 JSON后来一个美国程序员道格拉斯·克罗克福特发明了JSON，解决了上面的问题，这货还写了一本蝴蝶书JavaScript语言精粹，还发明了一个JS校验器 —-JSLint。 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 以上是JSON官网的简介，可以看出它是一门全新的语言，不是JavaScript的子集。 JSON很简单，数据类型和JS有点不同的地方。 JavaScript JSON string “string” 必须写双引号 number number object {“object”: “name”} 必须双引号 undefined 没有 null null boolean 直接写true false array array function 没有 variable 浏览器的全局对象window上有JSON对象，直接使用window.JSON.parse(string) 12let string = request.responseTextlet json = window.JSON.parse(string) //string 要符合JSON的格式 以上是JSON解析部分的代码。 此时服务器端代码是 123456789101112response.statusCode = 200response.setHeader('Content-Type', 'text/json;charset=utf-8')response.write(` &#123; \"note\" : &#123; \"to\" : \"木木\", \"from\" : \"少少\", \"heading\" : \"你好哇\", \"content\" : \"好久不见啊\" &#125; &#125;`) 我们浏览器有同源政策，不是同协议 同域名 同端口 的网页无法相互访问。 4.AJAX恰好是同源政策的拥趸 CORS 如果AJAX向非同源的地址发起请求，会报错。 这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200，也就是说即使你看到了200的正确码，也没有用 但是form表单无视同源政策，可以发起跨域请求。 12345&lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 上述请求响应都没有问题然而对于AJAX就不行 123...request.open(&apos;GET&apos;, &apos;http://www.baidu.com&apos;)... 这是为什么呢,因为 原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容,所以浏览器认为这是安全的。而 AJAX 是可以读取响应内容的，因此浏览器不能允许你这样做。如果你细心的话你会发现，其实请求已经发送出去了，你只是拿不到响应而已。所以浏览器这个策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。 作者：方应杭链接：https://www.zhihu.com/question/31592553/answer/190789780来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 那么如何让AJAX跨域发起请求呢。答案是CORS CORS目前是W3C的标准，它允许浏览器跨域发起XMLHttpRequest请求，而且可以发起多种请求，不像JSONP只能发起GET请求，全称是”跨域/源资源共享”（Cross-origin resource sharing）。 如果想要发起跨域请求 例如: http://wushao.com:8001 要想访问 http://shaolin.com:8002,可以做如下处理 1request.open(&apos;GET&apos;, &apos;http://wushao.com:8001/xxx&apos;) //配置request 服务器端的代码需要做如下处理 1response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://shaolin.com:8002&apos;) 一定要注意是谁去访问谁,8001去访问8002,那么8001的前端代码要告诉8002的后端代码,咱们是一家人,你和浏览器说说别让它禁我了。 AJAX一些其他知识既然可以发请求,那么请求头的四部分如何获得的,响应的四部分又是如何获得呢 获得请求和响应头 获得请求头的方法 12345request.open(&apos;GET&apos;, &apos;http://shaolin.com:8002/xxx&apos;)// 请求的第一部分request.setRequestHeader(&apos;Content-Type&apos;, &apos;x-www-form-urlencoded&apos;)//请求的第二部分request.setRequestHeader(&apos;wushao&apos;, &apos;18&apos;) //请求的第二部分request.send(&apos;我要设置请求的第四部分&apos;) //请求的第四部分request.send(&apos;name=wushao&amp;password=wushao&apos;) //请求的第四部分 对应的典型的http请求四部分 123456GET /xxx HTTP/1.1HOST: http://shaolin.com:8002Content-Type: x-www-form-urlencodedwushao: 18name=wushao&amp;password=wushao 获得响应的方法 12345request.status //响应的第一部分 200request.statusText //响应的第一部分 OKrequest.getAllResponseHeaders //响应的第二部分,这个方法好啊,全部的响应头request.getResponseHeader(&apos;Content-Type&apos;) //响应的第二部分具体的request.responseText //响应的第四部分 对应的典型的http响应的四部分 1234567891011HTTP/1.1 200 OKContent-Type: text/json;charset=utf-8&#123; &quot;note&quot; : &#123; &quot;to&quot; : &quot;木木&quot;, &quot;from&quot; : &quot;少少&quot;, &quot;heading&quot; : &quot;你好哇&quot;, &quot;content&quot; : &quot;好久不见啊&quot; &#125; &#125; 回顾一下各个status对应的意思 123456789100200 === OK，请求成功301 === 被请求的资源已永久移动到新位置302 === 请求临时重定向，要求客户端执行临时重定向304 === 和上次请求一样，未改变403 === 服务器已经理解请求，但是拒绝访问404 === 请求失败，服务器上没有这个资源502 === 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 === Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。 练习一下JQuery封装AJAX 初级的jq封装这是一个很简陋的效果，首先我还是把jq假设的很简单，就是一个window的属性，请轻喷…… 1234567891011121314151617181920212223242526272829303132window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123;&#125; nodes.addClass = function () &#123;&#125; nodes.html = function () &#123;&#125; return nodes&#125;window.jQuery.ajax = function (options) &#123; let url = options.url let method = options.method let headers = options.headers let body = options.body let successFn = options.successFn let failFn = options.failFn let request = new XMLHttpRequest() //实例化XMLHttpRequest对象 request.open(method, url) for (let key in headers) &#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt;= 300) &#123; successFn.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; failFn.call(undefined, request) &#125; &#125; &#125; request.send(body)&#125; 以上就是jq对ajax的简陋的封装，ajax()方法接受一个对象作为参数，这个对象有很多键。这些键就是http请求的头的各个部分，以及一个成功函数和一个失败函数。 123456789101112131415161718myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123; window.jQuery.ajax (&#123; url: &apos;/xxx&apos;, method: &apos;POST&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;wushao&apos;: &apos;18&apos; &#125;, body: &apos;a=1&amp;b=6&apos;, successFn: (x) =&gt; &#123; ... &#125;, failFn: (x) =&gt; &#123; ... &#125; &#125;) &#125;) 以上就是简化后的使用方法，给button绑定事件的时候，函数体直接就是ajax() 目前你会发现options这个对象傻傻的，因为总有一些用户不希望只传一个参数。所以我们稍微改造一下。 12345678910111213let url if (arguments.length === 1) &#123; url = options.url &#125; else if (arguments.length === 2) &#123; url = arguments[0] options = arguments[1] &#125; let method = options.method let headers = options.headers let body = options.body let successFn = options.successFn let failFn = options.failFn 加了一点，判断ajax()的参数个数。 一千个人有一千零一个成功或失败函数的写法，所以为了维护世界和平，大家约定俗成了一套理论 Promise then( ) 12345678//Promise这个对象呢，大概长这个样子，真实面目我是没见过//简单的写一下promisewindow.Promise = function (fn) &#123;//...一些其他代码return &#123; then: function () &#123;&#125; &#125;&#125; Promise这个构造函数呢，又会返回一个函数，这个返回的函数一个then属性，value又是一个函数。处处都体现着函数是第一公民的地位！！！那我们可以利用这个强大的Promise对象搞一些事情了。 1234567891011121314151617181920212223//第一步的代码改造成这样，第一步用到了ES6的解构赋值法window.jQuery.ajax = function (&#123;url, method, body, headers&#125;) &#123; return new Promise(function (resolve, reject) &#123; let request = new XMLHttpRequest() request.open(method, url) for(let key in headers) &#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt;= 300) &#123; resolve.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; reject.call(undefined, request) &#125; &#125; &#125; request.send(body) &#125;)&#125; 关于解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）详见ES6解构赋值 1234567891011121314151617181920//经过上面这么一折腾，可以很简单的使用了myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123; let promise = window.jQuery.ajax(&#123; url: &apos;/xxx&apos;, method: &apos;get&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;wushao&apos;: &apos;18&apos; &#125; &#125;) promise.then( (responseText) =&gt; &#123; console.log(responseText) &#125;, (request) =&gt; &#123; console.log(request) &#125; ) &#125;) 注意then可以传入两个函数，第一个函数表示成功了执行这个，第二个函数表示失败了执行这个，而且可以进行链式调用，一直点下去。 所以实际上jq的写法大多是这么写的 1234567891011121314151617181920212223myButton.addEventListener(&apos;click&apos;, (e) =&gt; &#123; $.ajax(&#123; url: &apos;/xxx&apos;, type: &apos;GET&apos;, &#125;).then( (responseText) =&gt; &#123; console.log(responseText) return responseText &#125;, (request) =&gt; &#123; console.log(&apos;error&apos;) return &apos;已经处理&apos; &#125; ).then( (responseText) =&gt; &#123; console.log(responseText) &#125;, (request) =&gt; &#123; console.log(error2) &#125; )&#125;) 链式调用的意思就是：成功函数成功了，就执行第二个then的第一个函数；成功函数失败了，就执行第二个then的第二个函数。 完整代码详见我的gitHub","categories":[{"name":"同源的问题及解决思路","slug":"同源的问题及解决思路","permalink":"https://codevvvv9.github.io/categories/同源的问题及解决思路/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://codevvvv9.github.io/tags/AJAX/"}]},{"title":"破解浏览器同源政策利器之JSONP","slug":"破解浏览器同源政策利器之JSONP","date":"2018-01-23T14:35:46.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/23/破解浏览器同源政策利器之JSONP/","link":"","permalink":"https://codevvvv9.github.io/2018/01/23/破解浏览器同源政策利器之JSONP/","excerpt":"本文是在了解了浏览器的同源规则之后，学习了破解这个规则的一个简单有效的方法-&gt;JSONP。主要通过阮一峰老师的博客学习 浏览器的同源规则 有这样一个背景，如果你通过银行的网站进行的取钱的交易，而其他用户可以通过某个渠道获得你在银行网站的信息，那将是很可怕的。","text":"本文是在了解了浏览器的同源规则之后，学习了破解这个规则的一个简单有效的方法-&gt;JSONP。主要通过阮一峰老师的博客学习 浏览器的同源规则 有这样一个背景，如果你通过银行的网站进行的取钱的交易，而其他用户可以通过某个渠道获得你在银行网站的信息，那将是很可怕的。 所以，1995年NetScape公司(火狐的前身),提出了浏览器的同源政策，目的是保护使用网站的用户的信息安全。那么何谓同源呢 协议相同 域名相同 端口号相同 不过，随着互联网的发展，有些时候我们需要破解同源，所以要先学习一下，古老而有效的JSONP方法。 浏览器如何向服务器提交数据 有一天，程序员小白在自学，看到JSONP很牛，就向大神程序员小黑请教。小黑，小黑，这个JSONP是啥啊，感觉很牛( ⊙ o ⊙ )！。 小黑扶了扶500度的眼镜，摸了一下头顶的几根头发，若有所思的问小白。 小白啊，你说，浏览器怎么向服务器提交数据啊，比如说，你要付款这个情形。 form表单啊，我规定&lt;form method=&quot;POST&quot; action=&quot;/...&quot;&gt;&lt;/form&gt;，我不用get请求。 123456&lt;h5&gt;您的账户余额是&lt;span id=\"amount\"&gt;200&lt;/span&gt;&lt;/h5&gt;&lt;button id=\"button\"&gt;付款1块钱&lt;/button&gt;&lt;form action=\"/pay\" method=\"post\"&gt; &lt;input type=\"text\" name=\"number\" value=\"1\"&gt; &lt;input type=\"submit\" value=\"付款\"&gt;&lt;/form&gt; 恩，还是不错的啊，知道用POST发起请求。那你这提交完了之后，是不是还要在当前页面刷新一下，才能看到余额啊。 ……哎，是啊，不过我可以给你加一个iframe，就在当前页面刷新 123456&lt;form action=\"/pay\" method=\"post\" target=\"result\"&gt; &lt;input type=\"text\" name=\"number\" value=\"1\"&gt; &lt;input type=\"submit\" value=\"付款\"&gt;&lt;/form&gt;&lt;iframe name=\"result\" src=\"about:blank\" frameborder=\"0\"&gt;&lt;/iframe&gt; 有什么反馈信息都在iframe显示。 恩，也还行，不过你为啥要把总额200写死在页面呢，不应该动态从数据库中获得吗 ╮(╯▽╰)╭，稍等我改一哈 123456789&lt;h5&gt;您的账户余额是&lt;span id=\"amount\"&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt;&lt;button id=\"button\"&gt;付款1块钱&lt;/button&gt;...button.addEventListener('click', (e) =&gt; &#123; let n = amount.innerText let number = parseInt(n, 10) let newNumber = number - 1 amount.innerText = newNumber&#125; 我用&amp;&amp;&amp;amount&amp;&amp;&amp;占位符表示总额，服务器端可以如下处理 1234var amount = fs.readFileSync('./db', 'utf-8') //从db中读取string = string.replace('&amp;&amp;&amp;amount&amp;&amp;&amp;', amount) //把占位的数据换成真的数据...response.write(string) 恩，不错，你再想想有没有其他的方式也可以发送数据到服务器端啊，不用刷新页面的那种 ……还有其他的( ⊙ o ⊙ )啊！ 那我老黑我给你讲讲前辈程序员们试过的方法吧 12345678910//用图片发起get请求let image = document.createElement('img')image.src = '/pay'image.onload = function() &#123; alert('打钱成功') amount.innerText = amount.innerText - 1&#125;image.onerror = function() &#123; alert('打钱失败')&#125; 这种也是可以的，而且也会用提示给用户，交互性还可以，不过只能发起GET请求，哈哈，我就是秀一下黑科技，很少用啦…… (@ο@) 哇～这也可以，小黑，你好棒，又长见识啦,不过还是没给我讲JSONP啊,你是不是忘了…… 没忘啦，不要着急，接下来，就给你好好讲讲这个JSONP 动态创建JS脚本发数据 小白啊，你平常用的最多的是哪门语言啊 中文啊，英语不大好。 ……我说编程的时候 呃呃，那个用的JavaScript多啊 好，那咱们就用js脚本发数据呗 1234567891011121314151617181920212223//用js脚本发起请求 let script = document.createElement('script') script.src = '/pay' document.body.appendChild(script) script.onerror = function() &#123; alert('failed') &#125; ... //服务器端一般这么干 if(path === '/pay') &#123; var amount = fs.readFileSync('./db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./db', newAmount) response.setHeader('Content-Type', 'application/javascript') response.statusCode = 200 response.write(` amount.innerText = amount.innerText - 1 `) response.end()&#125; 以上是js脚本的大致意思，细节不要深究，明白就行。注意一下，添加script后，要记得document.body.appendChild(script) 不过，小黑啊，你这动态加上了script没错，可是你每次都往我的html底部加js，这破坏我的html啊 恩，小白啊，你思考能力还是可以的，目前确实有这个弊端，我给你处理一下 1234567891011//用js脚本发起请求 let script = document.createElement('script')script.src = '/pay'document.body.appendChild(script)script.onload = function(e) &#123; e.currentTarget.remove() //加载完了，就移除&#125;script.onerror = function(e) &#123; alert('failed') e.currentTarget.remove() //加载完了，就移除&#125; 可以可以，小黑你这波操作可以的。快让我见识见识JSONP吧 好，这就给你变出来 ​ 1234567891011121314151617181920button.addEventListener('click', (e) =&gt; &#123; //用js脚本发起请求 let script = document.createElement('script') let functionName = 'wushao' + parseInt((Math.random()*100000), 10) window[functionName] = function (result) &#123; if (result === 'success') &#123; amount.innerText = amount.innerText - 1 &#125; else &#123; &#125; &#125; script.src = 'http://想访问的另一个网站:端口号/pay?callback=' + functionName document.body.appendChild(script) script.onload = function(e) &#123; e.currentTarget.remove() &#125; script.onerror = function(e) &#123; alert('failed') e.currentTarget.remove() &#125; &#125;) ヾ(｡｀Д´｡)黑神，你这跨度有点大，咋变了个大魔术。 O(∩_∩)O哈哈~，你让我给你快点讲的……，我给你讲讲细节吧 let functionName = ‘wushao’ + parseInt((Math.random()*100000), 10) 使用一个随机函数构建自己的函数名字，可以与服务器端代码完美解耦，服务器端只需要，获得查询参数?callback=functionName 里面的functionName就可以了。 window[functionName] = function (result) { } 在window全局对象上添加functionName属性，它的值是一个函数，当服务器端响应回来后，浏览器端的写的函数的参数就是服务器端的success，我们就知道我的数据成功了。 1234//服务器端只需要这样就可以了，不关心你写的是什么函数名字response.write(` $&#123;query.callback&#125;.call(undefined, 'success')`) 哇，厉害啊，不过你又犯了一个相同的错误啦，哈哈，每次要把添加的全局对象的属性去掉哦～ 123456789script.onload = function(e) &#123; e.currentTarget.remove() delete window[functionName]&#125;script.onerror = function(e) &#123; alert('failed') e.currentTarget.remove() delete window[functionName]&#125; O(∩_∩)O哈！，这样子就对了，小白啊，既然你学过jQuery，你试一试jQuery的写法吧 (^o^)/~行，小黑，我也给你变一个 12345678910111213141516$.ajax(&#123; url: \"http://想访问的另一个网站:端口号/pay\", // The name of the callback parameter, as specified by the YQL service jsonp: \"callback\", // Tell jQuery we're expecting JSONP dataType: \"jsonp\", // Work with the response success: function (response) &#123; if(response === 'success') &#123; amount.innerText = amount.innerText - 1 &#125; &#125;&#125;) 哎呦，不错呦，小白～ O(∩_∩)O哈哈~，我就是Google的 jquery jsonp 不过，这个可和ajax，没啥关系啊，不明白为啥jquery为啥这么写。 具体的代码链接在============&gt;传送门 什么是JSONP呢请求方是一个网站(浏览器端)，响应方是另一个网站（服务器端） 请求方动态的创建一个script脚本，src属性是响应方的地址，同时传递一个查询查参数？callback=functionName，一般functionName使用随机函数构造。 响应方根据收到的查询参数callback=functionName,去构造形如 2.1 functionName.call(undefined, &#39;success&#39;) 2.2 或者直接functionName.(&#39;success&#39;) 这样的响应。 浏览器收到响应之后，就会执行functionName.call(undefined, &#39;success&#39;)或者functionName.(&#39;success&#39;) 然后，请求方就知道了他想要获得的数据如何了。 这就是JSONP的原理 为什么JSONP不支持POST请求呢答曰：JSONP是动态创建的js脚本，这个方法只能发起GET请求，不能发起POST请求。 接下来学习ajax啦～加油↖(^ω^)↗","categories":[{"name":"同源的问题以及解决思路","slug":"同源的问题以及解决思路","permalink":"https://codevvvv9.github.io/categories/同源的问题以及解决思路/"}],"tags":[{"name":"JSONP","slug":"JSONP","permalink":"https://codevvvv9.github.io/tags/JSONP/"}]},{"title":"node-sass安装失败的究极解决方法.md","slug":"node-sass安装失败的究极解决方法","date":"2018-01-19T15:24:07.000Z","updated":"2018-12-01T10:53:56.000Z","comments":true,"path":"2018/01/19/node-sass安装失败的究极解决方法/","link":"","permalink":"https://codevvvv9.github.io/2018/01/19/node-sass安装失败的究极解决方法/","excerpt":"记录一下安装node-sass的过程.关于CSS是不是一门编程语言,这里不讨论,但是它没有变量 语句 函数(反正我觉得他不是编程语言).于是程序员们发明了CSS预处理器(css preprocessor),它是一种专门的编程语言,可以使用你会的基本的编程知识进行编程,然后再转化成css文件. 12月更新本次重新安装node-sass是因为电脑换了固态重装系统了，在新系统下很长时间内没有用过sass，一切都是那个风平浪静，直到11月的最后一晚，想折腾一下博客，看到一个好看的主题，这个主题需要安装两个插件，其中有一个需要node-sass的加持。 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save #就是这货 不出意外的，国内不采取特殊途径，hexo-renderer-sass安装报错，根据log日志，很容易的发现，他需`node-sass@4.10.0`支持，但是下载失败。 解决方案1：先在global下安装node-sass 重装后我全是采用的nvm管理的node版本，所有的包都在.nvm目录下，避免权限不够的错误(或者采取分割线以下的阮一峰老师的方法避免包权限的问题)。 配置.npmrc，先touch ~/.npmrc。这次直接采取node-sass的官方推荐的方式，npm install -g mirror-config-china --registry=http://registry.npm.taobao.org，所有的国内有问题的包全都避免了。 结果竟然无法下载，log日志提醒我可能是代理的问题，可能是我的FQ的系统代理有问题，去控制台一看，果然SOCKETS 有个错误，尝试使用npm添加代理的方式，均告失败，毕竟以后也不能总靠代理过日子，这个方式不可取。这次想找个一劳永逸的方式彻底解决这个垃圾问题。 终于发现了，直接使用下载好的Realease包去安装，先去node-sass主页下载系统需要的类型，这个完全可以解决系统不同的问题，很具用普适性。 到底你的系统需要那个具体的包呢，这个就是最关键的了，我的方式是：先安装，失败后会提示你哪个版本的node包无法下载，这个时候再去下载这个包。通过如下代码去安装： 12npm i -g node-sass@4.9.3 --sass_binary_path=/home/wsl/Downloads/chromeDownloads/linux-x64-64_binding.node# path需要替换成你系统的那个包名字 But我以为下载成功了，就万事大吉了呢，发现我真是太天真了。安装完后第一件事就是检验安装的包能不能用，node-sass -v一下，最不济出现个node-sass not found这种类似的初级错误啊，结果报了个无语的错误。 这个目录是node-sass规定的 为啥没有这个目录呢，因为通过 我采用的是设置本地下载路径，没有通过网上的下载。所以需要手动建立一个vendor目录（issues里面通过npm rebulid node-sass可以解决，但是我没生效），接着会报第二个新错误，这就很合理了，报错一点不可怕，能看懂并解决掉就很是进步。 新的错误是需要binding.node文件，刚才建立的vendor是个空目录所以找不到，在其内部建立二级目录，并把刚才下载的包改名为binding.node，即vendor/linux-X64-64/binding.node 至此，本地安装node-sass完毕，以后可以随便玩node-sass了，管你能不能翻墙，能不能设置镜像。 本来以为全局安装完毕就可以在博客目录下直接安装hexo-renderer-sass，竟然还是报错。没办法，在newBlog目录下又按照上述的方法安装了一个`node-sass@4.10.0，因为hexo-render-sass`需要4.10.0版本。最后终于成功了。 分割线以下为传统解决方法，尤其针对Linux用户 介绍主流的CSS预处理器有8种,我们今天介绍sass.它的官网,不过需要安装ruby.","text":"记录一下安装node-sass的过程.关于CSS是不是一门编程语言,这里不讨论,但是它没有变量 语句 函数(反正我觉得他不是编程语言).于是程序员们发明了CSS预处理器(css preprocessor),它是一种专门的编程语言,可以使用你会的基本的编程知识进行编程,然后再转化成css文件. 12月更新本次重新安装node-sass是因为电脑换了固态重装系统了，在新系统下很长时间内没有用过sass，一切都是那个风平浪静，直到11月的最后一晚，想折腾一下博客，看到一个好看的主题，这个主题需要安装两个插件，其中有一个需要node-sass的加持。 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save #就是这货 不出意外的，国内不采取特殊途径，hexo-renderer-sass安装报错，根据log日志，很容易的发现，他需`node-sass@4.10.0`支持，但是下载失败。 解决方案1：先在global下安装node-sass 重装后我全是采用的nvm管理的node版本，所有的包都在.nvm目录下，避免权限不够的错误(或者采取分割线以下的阮一峰老师的方法避免包权限的问题)。 配置.npmrc，先touch ~/.npmrc。这次直接采取node-sass的官方推荐的方式，npm install -g mirror-config-china --registry=http://registry.npm.taobao.org，所有的国内有问题的包全都避免了。 结果竟然无法下载，log日志提醒我可能是代理的问题，可能是我的FQ的系统代理有问题，去控制台一看，果然SOCKETS 有个错误，尝试使用npm添加代理的方式，均告失败，毕竟以后也不能总靠代理过日子，这个方式不可取。这次想找个一劳永逸的方式彻底解决这个垃圾问题。 终于发现了，直接使用下载好的Realease包去安装，先去node-sass主页下载系统需要的类型，这个完全可以解决系统不同的问题，很具用普适性。 到底你的系统需要那个具体的包呢，这个就是最关键的了，我的方式是：先安装，失败后会提示你哪个版本的node包无法下载，这个时候再去下载这个包。通过如下代码去安装： 12npm i -g node-sass@4.9.3 --sass_binary_path=/home/wsl/Downloads/chromeDownloads/linux-x64-64_binding.node# path需要替换成你系统的那个包名字 But我以为下载成功了，就万事大吉了呢，发现我真是太天真了。安装完后第一件事就是检验安装的包能不能用，node-sass -v一下，最不济出现个node-sass not found这种类似的初级错误啊，结果报了个无语的错误。 这个目录是node-sass规定的 为啥没有这个目录呢，因为通过 我采用的是设置本地下载路径，没有通过网上的下载。所以需要手动建立一个vendor目录（issues里面通过npm rebulid node-sass可以解决，但是我没生效），接着会报第二个新错误，这就很合理了，报错一点不可怕，能看懂并解决掉就很是进步。 新的错误是需要binding.node文件，刚才建立的vendor是个空目录所以找不到，在其内部建立二级目录，并把刚才下载的包改名为binding.node，即vendor/linux-X64-64/binding.node 至此，本地安装node-sass完毕，以后可以随便玩node-sass了，管你能不能翻墙，能不能设置镜像。 本来以为全局安装完毕就可以在博客目录下直接安装hexo-renderer-sass，竟然还是报错。没办法，在newBlog目录下又按照上述的方法安装了一个`node-sass@4.10.0，因为hexo-render-sass`需要4.10.0版本。最后终于成功了。 分割线以下为传统解决方法，尤其针对Linux用户 介绍主流的CSS预处理器有8种,我们今天介绍sass.它的官网,不过需要安装ruby. 不想安ruby,那就借助node安装node-sass吧.github主页 本人是deepin Linux 15.5版本安装 由于node-sass会去github主页下载binding-node,然后又去亚马逊去下载,所以国内因为一些不可抗力无法下载.简单的进行如下的设置,都是初学者,我就不用命令的形式写了,下面直接写上内容.基本的命令用多了也就会了. 在主目录下建立一个.npmrc的文件,在里面加上 12345sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/electron_mirror=https://npm.taobao.org/mirrors/electron/registry=https://registry.npm.taobao.org///顺序好像会有影响,我一开始不是这个顺序,后来改成这个,能安装成功 还必须在主目录的.bashrc下添加 1export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot; 好了,按理说可以用如下命令正常安装了,但是出问题了. 12npm i -g node-sass 问题出现第一个错误 用了上述的命令,我第一次就报错,Error显示说权限不够,我果断用了 1sudo npm i -g node-sass 恩,然后就是无休止的错误,ctrl+c终止后,发现node_modules里面有node-sass,但是明显不能用.去github的issue上搜,大神都是用了1npm rebulid node-sass 然而成功是属于其他人的. 我试了一下,又是报错, 还是权限不够,我又加了sudo. 恩,又是报错.此时我很烦,你说没权限,我加了权限你又报错,这个死循环……. 没办法,生活还要继续,又去stackoverflow和github上搜,在node-sass的项目的Troubleshooting上发现了问题所在,如下是Linux部分的官方文档 LinuxThis can happen if you are install node-sass as root, or globally with sudo. This is a security feature of npm. You should always avoid running npm as sudo because install scripts can be unintentionally malicious. Please check npm documentation on fixing permissions.If you must however, you can work around this error by using the --unsafe-perm flag with npm install i.e.12&gt; $ sudo npm install --unsafe-perm -g node-sass&gt; If this didn’t solve your problem please open an issue with the output from our debugging script. 文档说: 当你用root角色或者全局使用sudo命令安装的时候,就会发生这个错误.(-妈个鸡,我就是全局安装node-sass啊),不过人家说了,这是npm的安全特性.(-你牛你说啥都行),你应该总是避免使用sudo去执行npm,因为安装脚本会发生意想不到的致命错误(-确实意想不到,以前我都是sudo安装模块,就这次栽了,不过你倒是说咋解决啊),请左转去npm的官方文档(- 这是重点,解决方法就在这里),如果你非要用sudo,用下面的命令吧…………..如果这些仍没有解决你的问题,请看了我们的debugging脚本里面的解决方法在开启一个新的issue吧(如果大家还有和我不一样的错误,这里有很多解决方法)our debugging script. 好了,翻译完了,咱们去npm的第三章去看看咋解决. 第三章写的写的很明白. 如何避免权限错误 下面是文档原文 If you see an EACCES error when you try to install a package globally, read this chapter. This error can be avoided if you change the directory where npm is installed. To do this, either:Reinstall npm with a version manager (recommended),orChange npm’s default directory manually. 它说:如果你尝试安装一个全局的包,遇到了权限的错误,应该读读这一章.如果npm被安装的时候你改变了npm的目录,这个错误就会被避免(- 言下之意,就是让你改目录,就可以避免不能操作/usr/local/底下的内容了,你或者可以改变目录的权限 chmod [mode] dir,效果应该一样的,我没试过,而且官方也没说),要想做到这个,要么用版本管理工具重装npm(- 官方推荐的),要么就手动改变npm的默认目录(我用的这个). 好了,翻译完了,如果你想用官方推荐的方法就用版本管理工具重装npm,就去看文档的第二章版本管理工具 官方推荐用nvm,我以前误打误撞安了一个TJ大神(尤雨溪的偶像)的n模块( 不会用,就会升级,好尴尬啊) 还有一个 If you are using npm version 5.2 or greater, explore tools such as npx to circumvent permissions issues. 如果你的npm版本是5.2以上,可以用npx(又是好尴尬,我有npx,也不会用…..) 还有特别火的小猫yarn,快30000的star了(不过我没用……) 恩,前端的世界很精彩啊. 手动更改npm目录 Back-up your computer before moving forward.Make a directory for global installations: 12&gt; mkdir ~/.npm-global&gt; Configure npm to use the new directory path:12&gt; npm config set prefix &apos;~/.npm-global&apos;&gt; Open or create a ~/.profile file and add this line:12&gt; export PATH=~/.npm-global/bin:$PATH&gt; Back on the command line, update your system variables:12&gt; source ~/.profile&gt; Instead of steps 2-4, you can use the corresponding ENV variable (e.g. if you don’t want to modify ~/.profile):12&gt; NPM_CONFIG_PREFIX=~/.npm-global&gt; 官方确实够详细,也能用,你不想麻烦,就在环境变量里面NPM_CONFIG_PREFIX=~/.npm-global 我试过这个方法,不过建立的.npm-global隐藏得太深了,ctrl+H都看不到它,我就采用了阮一峰大神的方法,方法还是要用大神的博客的方法或者官方的啊. 123456789101112首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。prefix = /home/yourUsername/npm然后在主目录下新建npm子目录。mkdir ~/npm此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。export PATH=~/npm/bin:$PATH 做完这个之后,全局卸载不能用的node-sass,再npm i -g node-sass 12# 卸载全局模块$ npm uninstall [package name] -global 很遗憾,旧目录的没删成功,不过新目录的能用就行…………………… 安装小总结 1. 一定不要用sudo安装,先手动改npm的目录2. 更改.npmrc 和 .bashrc3. npm i -g node-sass4. 英语多学点,文档多看点,命令行多用点. node-sass的简单使用 它的使用方法和ruby的sass有一点小区别 1node-sass -wr scss -o css 官方使用手册 阮一峰教程 加油啊,sass","categories":[{"name":"Sass使用","slug":"Sass使用","permalink":"https://codevvvv9.github.io/categories/Sass使用/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://codevvvv9.github.io/tags/Sass/"}]},{"title":"理解Event的冒泡模型","slug":"理解Event的冒泡模型","date":"2018-01-17T13:22:38.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/17/理解Event的冒泡模型/","link":"","permalink":"https://codevvvv9.github.io/2018/01/17/理解Event的冒泡模型/","excerpt":"本文探索一下Event的冒泡过程和初学遇到的几个小bug DOM Event概述Event接口是检测在DOM中的发生的所有事件，我们一直在用，而且从DOM的很早的版本就一直在用着。早期的网景(后来的火狐)和IE是各自为战，直到W3C一统江湖，DOM版本一路发展而来，经历了DOM-0(洪荒时代)、DOM-1(只有两章核心内容)、DOM-2(划时代的一个版本，我们学的Event就在这个版本，而且目前的用的也是这个版本)、DOM-3、DOM-4(草案阶段)。","text":"本文探索一下Event的冒泡过程和初学遇到的几个小bug DOM Event概述Event接口是检测在DOM中的发生的所有事件，我们一直在用，而且从DOM的很早的版本就一直在用着。早期的网景(后来的火狐)和IE是各自为战，直到W3C一统江湖，DOM版本一路发展而来，经历了DOM-0(洪荒时代)、DOM-1(只有两章核心内容)、DOM-2(划时代的一个版本，我们学的Event就在这个版本，而且目前的用的也是这个版本)、DOM-3、DOM-4(草案阶段)。 通过一个例子唤醒对Event的认识 123456789101112//1、有一个js函数如下function print()&#123; console.log(1)&#125;//2、在html的button里面点击触发上面的函数&lt;button id=button onclick=\"?\"&gt;点我&lt;/button&gt;//问号处填可以填什么 A. print() B.print C.print.call()//在js里面的onclick里面触发button.onclick = ?//问号处可以填什么 A. print() B.print C.print.call() 很明显第一个问号应该选A C，第二个问号应该选B 第一处在HTM中，点击事件要立刻执行代码，肯定选择带()的，而第二处在JS中，onclick是一个属性，不需要立刻执行，等用户点击了，浏览器再反应，不需要()。 既然onclick等on事件在JS中是一个属性，那么后面的就会覆盖前面的，所以DOM2里面引入了一个重要的EventListener，是一个队列。 addEventListener这是一个队列，例子1，先进先出的特点，为后面的冒泡模型做准备。 123456789101112function f()&#123; console.log(\"eventListener不会覆盖\")&#125;button2.addEventListener('click', function()&#123; console.log(\"eventListener不会覆盖1\")&#125;)button2.addEventListener('click', f)button2.removeEventListener('click', f)button2.addEventListener('click', function()&#123; console.log(\"eventListener不会覆盖3\")&#125;) 会打印出什么呢，答案是eventListener不会覆盖1 eventListener不会覆盖3 所以说既然on可以一个打印出结果，就可以借助remove来实现one执行一次的操作 1234567function f()&#123; console.log(\"eventListener不会覆盖2\") button2.removeEventListener('click', f)&#125;button2.addEventListener('click', f) 只会打印一次，不会一直打印了，也就是one的原理。 具体的模型可以看W3C 冒泡模型上面的官方文档中，我只研究一下捕获阶段(capture phase)和冒泡阶段(bubbling phase)。 什么是冒泡呢？我们先看一段代码 12345678910grand.addEventListener('click', function()&#123; console.log('我是你爷爷')&#125;)dad.addEventListener('click', function()&#123; console.log('我是你爸爸')&#125;)son.addEventListener('click', function()&#123; console.log('我是你儿子')&#125;) 这是三个div的事件，当你点击的时候，控制台打印必然会有顺序。那么应该是什么顺序呢，正常人的思维不外乎两种结果 第一种：我是你的儿子 我是你爸爸 我是你爷爷 第二种： 我是你爷爷 我是你爸爸 我是你儿子 到底是那种呢，W3C说都行，看你代码咋写的了，上面的代码打印顺序是第一个中，也就是冒泡。 如果你想实现第二种打印方式，也就是捕获阶段，应该修改代码如下 12345678910grand.addEventListener('click', function()&#123; console.log('我是你爷爷')&#125;, true)dad.addEventListener('click', function()&#123; console.log('我是你爸爸')&#125;, true)son.addEventListener('click', function()&#123; console.log('我是你儿子')&#125;, true) 也就是说addEventListener后面的参数决定了顺序，当你不写的时候是undefined，也就是false的意思。 复习一下五个falsey值 0 NaN &#39;&#39; null undefined 除此之外都是true 上图是简单的图解，注意优先运行为true的部分，再运行false的部分。 简单的实例====================&gt;demo 一个变式 123456789grand.addEventListener('click', function()&#123; console.log('我是你爷爷')&#125;, true)dad.addEventListener('click', function()&#123; console.log('我是你爸爸')&#125;)son.addEventListener('click', function()&#123; console.log('我是你儿子') 上述代码应该是什么顺序呢 谁是true，先打印谁，都是false，继续按照冒泡顺序打印。 一个奇葩的问题1234567son.addEventListener('click', function()&#123; console.log('我是你儿子true')&#125;, true)son.addEventListener('click', function()&#123; console.log('我是你儿子false')&#125;) 给同一个元素 false true，应该打印什么呢 答案是： 按照书写的顺序，谁在前面先打印谁。 意想不到的Bugparent是关键字不能使用，一不小心使用的话会出问题。 你用了关键字做变量，把鼠标点烂也看不到效果。 点击空白，对话框消失的案例 领导说有一个需求，点击某个按钮，弹出对话框，点击空白会消失。 你的第一个思路：先把div设为none，点击按钮的时候，再让这个div的display是block，点击其他地方变为none。 很好，你去实现一下吧。 第一个bug 很快你会碰到了第一个bug 第一个错误：监听错了对象 正常来说，应该点击body控制台打印数字1，你点烂了你的罗技鼠标也没出来。为什么呢？ 我们使用border大法，看看它到底在哪 使用了红色border之后，发现body的高度太矮了，点击不到啊。 你明白监听错对象了，那你就换了一个对象，监听文档呗，肯定没问题了。 第二个bug 很好，你进入了第二个bug了 第二个bug：你都能点击到，但是弹不出对话框了 根据图片 中的控制台可以发现，确实都点击到了，监听没问题，而且点击后，也是按照冒泡的顺序打印的结果。 那为什么没有对话框了呢 注释掉出问题的代码后，上图是正常的点击出现对话框啊，说明问题就出在注释的代码上。 bug出现的原因就在于：默认冒泡的影响，当你点击的浮层那个div，之后，往 body document上冒泡，在document上立刻被杀死，display变为none，你做梦能看到 弹出框啊。 修复第二个bug我们既然知道了第二个bug产生的原因，那么我们阻止冒泡顺序 解决的方案，不让其往上冒泡，自己管理。 1234567891011121314clickMe.addEventListener('click', function()&#123; popover.style.display = 'block' console.log('点击浮层了') &#125;)wrapper.addEventListener('click', function(e)&#123; e.stopPropagation()&#125;)document.addEventListener('click', function()&#123; popover.style.display = 'none' console.log('点击文档了') &#125;) 但是随之而来的是一个关于内存占用的问题，现在你是只有一个popover，只有一个函数，等你有了很多个popover，如果按照这个写法会有很多个函数，所以不能这么写，采用下面的写法，节省内存。 12345678910111213141516171819$(clickMe).on('click', function()&#123; $(popover).show() console.log('show') setTimeout(function()&#123; console.log('one click') $(document).one('click', function()&#123; console.log('我觉的他不会执行') $(popover).hide() &#125;) &#125;,0) &#125;)// $(wrapper).on('click', function(e)&#123;// e.stopPropagation()// &#125;)$(document).on('click', function()&#123; console.log('走到document啦')&#125;) 只有点击的时候才用，设置settimeout是为了让他异步，不至于立刻隐藏，产生第一个bug。 注意一下，jQuery的 show() hide() 当你点击按钮，只会打印图中这两句话，另外两句只有再次点击才会打印。 JS版本的节省内存的版本==================&gt;节省内存 jQuery版本的节省内存版本=================&gt;jQuery节省内存 对话框小三角的制作123456789101112131415161718192021222324.popover&#123; display: inline-block; border: 1px solid red; position: relative; padding: 10px; margin:10px;&#125;.popover::before&#123; position: absolute; content: ''; top: 5px; right: 100%; border: 10px solid transparent; border-right-color:red;&#125;.popover::after&#123; content: ''; border: 10px solid transparent; position: absolute; right: 100%; top: 5px; border-right-color: white; margin-right: -1px;&#125; 主要利用boder-right-color以及两个伪元素。 浮层三角的实例=============================&gt;demo 冒泡的直观体现点击一下会有惊喜的https://github.com/codevvvv9/bubble/blob/master/bubble.gif 冒个泡","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"从win7到Linux","slug":"从win7到Linux","date":"2018-01-13T02:56:06.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/13/从win7到Linux/","link":"","permalink":"https://codevvvv9.github.io/2018/01/13/从win7到Linux/","excerpt":"","text":"终于换到liunx啦","categories":[{"name":"Linux入门","slug":"Linux入门","permalink":"https://codevvvv9.github.io/categories/Linux入门/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://codevvvv9.github.io/tags/Linux/"}]},{"title":"一个优秀的项目经理与JQuery的故事","slug":"一个优秀的项目经理与JQuery的故事","date":"2018-01-09T15:14:23.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/09/一个优秀的项目经理与JQuery的故事/","link":"","permalink":"https://codevvvv9.github.io/2018/01/09/一个优秀的项目经理与JQuery的故事/","excerpt":"本文是对jQuery的起源的初步探索。先通过两个函数来扩展原生DOM的操作，然后引入命名空间以及对其重构，接着将该命名空间扩大到Node上，改造一个自己的Node2，引出jQuery。","text":"本文是对jQuery的起源的初步探索。先通过两个函数来扩展原生DOM的操作，然后引入命名空间以及对其重构，接着将该命名空间扩大到Node上，改造一个自己的Node2，引出jQuery。 引子 首先，我有一个需求===========&gt; 要获得一个&lt;li&gt;标签的所有兄弟元素。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id=\"item1\"&gt;选项1&lt;/li&gt; &lt;li id=\"item2\"&gt;选项2&lt;/li&gt; &lt;li id=\"item3\"&gt;选项3&lt;/li&gt; &lt;li id=\"item4\"&gt;选项4&lt;/li&gt; &lt;li id=\"item5\"&gt;选项5&lt;/li&gt; &lt;li id=\"item6\"&gt;选项6&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 此时你刚学完原生DOM操作，知道有nextSibling previousSibling parentNode。你发现貌似没有直接一下子获得全部兄弟元素的API啊，身为一个优秀的90后，你果断手写一个函数实现这个需求啊。 1234567891011function getSiblings(node)&#123; var allChild = item2.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i &lt; allChild.length; i++)&#123; if (allChild[i] !== node)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj&#125; 好了，以上的函数就能满足需求了,它接受你传入的某个元素，返回包含这个元素所有兄弟元素的伪数组。 注意: 要用item2.parentNode.children 这样子才不会获得文本节点。所以你想获得item2的所有兄弟，只需要getSiblings(item2) 获得所有兄弟的演示地址============&gt;demo 你刚解决了一个问题，领导又给你提了一个需求，让你给&lt;li&gt;添加一个类 领导还没说完，你立马想到了，直接item2.classList.add(&#39;类名&#39;)啊，哈哈，我好聪明啊，不愧是优秀的90后。 给你任意一个元素要直接加上这个类名，别给我的一个一个的加，太二了，如果元素原来有一个不应该存在的类名，给我删了，领导接着说完全部的需求。 这…看来不能item1.classList.add(&#39;类名&#39;) item2.classList.add(&#39;类名&#39;) item3.classList.add(&#39;类名&#39;)这么弱智的干了啊，那我还用函数嘛，你灵机一动。 嗯，不愧是善于思考的90后 12345678910function addClass(node, classes)&#123; for (var key in classes)&#123; var value = classes[key] if (value)&#123; node.classList.add(key) &#125; else&#123; node.classList.remove(key) &#125; &#125;&#125; 上图是为添加元素的时候的item2的模样，记住它，待会和下图对比。 可以看到，执行方法后，item2的类名变为b、c，这是因为你是addClass(item2, {a: 0, b: 1, c: true})这么调用的，意思是类名不应该有a,删除a，并加上b c。 以上对象的遍历并取值用到了falsey值 复习一下，js的6个falsey值 0 NaN &#39;&#39; null undefined false 除此之外，其他的全是true。 不过你想的太美了，领导看到你的代码中的这个片段，直接抓狂了…… 123456if (value)&#123; node.classList.add(key) &#125; else&#123; node.classList.remove(key) &#125; &#125; 这段代码给我优化了，明明就是一句话的事。 你回去想了一会，可以这么优化 12var methodName = value ? 'add' ： 'remove'node.classList[methodName](key) 最后你把如下代码提交。 1234567function addClass(node, classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add' : 'remove' node.classList[methodName](key) &#125;&#125; 注意一点上述代码不能用点运算符，要用[]运算符，classList[&#39;add&#39;] === classList.add 给任一元素添加类名==========================&gt;demo 命名空间你完成了上面的两个需求后，领导本着锻炼你的原则，又给你提了新的需求。 少林那，你看你这两函数写的挺好的，如果分开放，每次还要在找，不如放到一起把。 我擦嘞，让我放到一起。好吧…… 回来后，少林冥思苦想，突然想起了昨晚刚去的月坛西街的天府超市的送货车 我把那俩函数当成两种商品，我开个超市，把它俩收起来呗。 123var shaolinDom = &#123;&#125; //少林开的超市shaolinDom.addClass = addClass //把addClass这个商品收进来shaolin.getSibling = getSiblings //把getSiblings这个商品收进来 那我咋用呢，该咋用就咋用呗。 12shaolinDom.addClass(item5, &#123;a: true, b: false, c: 0&#125;) //把item5上原本的b c类名删掉，加上 a类名shaolinDom.getSiblings(item6) //获得item6的所有兄弟元素 看着上面的代码，我就在想啊，还是自己由优化一下吧，免得回来改。 12345678910111213141516171819202122232425var shaolinDom = &#123;&#125;shaolinDom.addClass = function(node, classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add':'remove' node.classList[methodName](key) &#125; &#125;shaolinDom.getSiblings = function (node)&#123; var allChild = node.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i&lt; allChild.length; i++)&#123; if (allChild[i] !== node)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj&#125;shaolinDom.addClass(item5, &#123;a: true, b: false, c: 0&#125;)var allSiblings = shaolinDom.getSiblings(item6)console.log(allSiblings) 引入命名空间=======================&gt;demo 命名空间的优化=====================&gt;demo 你提交了新的需求后，领导对你刮目相看啊，今年的新员工还是不错的 你刚想松口气，领导接着说，少林那，你看你这两函数啊只能在shaolinDom用啊，而且我每次要把item5传到函数里面，每次好麻烦的啦，你改进一下，让我的元素可以直接调用方法呗，比如item5.getSiblings()这样多好。这样子操作的话，item5拥有自主权，就像你买东西，你想去买那个东西你就去买那个东西嘛，而不是东西去选择你啊。 我擦擦嘞，想想经理分析还是很有道理的，果然还是要继续优化啊…… 回来会，我在工位上想，你不是要操作DOM吗，还想这么item5.getSiblings()操作，那我这次直接给你干到Node的原型上； 1234567891011121314151617181920Node.prototype.addClass = function(classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add':'remove' this.classList[methodName](key) &#125; &#125;Node.prototype.getSiblings = function ()&#123; var allChild = this.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i&lt; allChild.length; i++)&#123; if (allChild[i] !== this)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj&#125; 丫的，我写出这些代码之后，我瞬间感觉自己两米了呢，赶紧去找领导 领导一看，吸了一口冷气，心想，挺牛 啊，不过我要问问我这小子 this的知识 少林那，你这函数里面this是啥，再给我讲讲咋用呗 我屮艸芔茻，轮到我牛了吧，我把袖子已撸，是这么回事，巴拉巴拉 当然，我要先给经理讲一下怎么用 12item5.addClass(&#123;a: true, b: false, c: 0&#125;) //既然Node原型都有了这两函数，item5是node类型，直接用呗console.log(item6.getSiblings()) 我刚写完，领导就叫，这addClass函数里面这就一个参数啊，getSiblings函数怎么没参数啊 哦，这个啊，我讲了this后就明白了。不过讲这个this之前先要讲一讲这个call()，方便理解 123//上面的代码等同于以下代码item5.addClass.call(item5, &#123;a: true, b: false, c: 0&#125;) //call()方法的第一个参数就是thisconsole.log(item6.getSiblings.call(item6)) 如果你把call()省了，直接用()去调用函数，自己脑补call()就好啦，自然也就知道this是谁啦。 这小子还可以啊，不错。不过要继续引导一下啊 进一步升级，绑定Node的原型链上==================&gt;demo用call()方便理解this================================&gt;demo 自己写一个构造函数没多久，领导的考验又来了 少林那，你看你上次吧你自己写的函数绑到Node上了，看似挺好，但是其他人不一定用你的这两函数啊，你绑到Node上，多占地啊，而且你可以绑到Node原型上，别人也可以写一个同名函数绑到Node原型上，万一给你覆盖了，你用的时候，不就懵逼了嘛。你自己写一个全局函数实现一下相同的需求吧。 呦，这次经理说的很对啊，我的错，我改进一下 突然联想到以前的各种构造函数，String() Number() Array()可以直接返回一个对象，我也这么干吧 1234567891011121314151617181920212223window.Node2 = function(node)&#123; return &#123; getSiblings: function()&#123; var allChild = node.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i&lt; allChild.length; i++)&#123; if (allChild[i] !== node)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj &#125;, addClass: function(classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add':'remove' node.classList[methodName](key) //闭包的使用 &#125; &#125; &#125;&#125; 实现了一个全局构造函数，返回一个对象，该对象里面有两个key(getSiblings、addClass)，value分别又是两个函数(又体现了函数是第一公民的地位)，而且还用到了闭包。 123var node2 = Node2(item3) //node2就是用Node2()构造函数构造的返回的对象node2.getSiblings() //对象的点运算符去去操作属性啊node2.addClass(&#123;'a': 0, 'b': true, 'c': true&#125;) 领导一看，嗯，是时候让他见识真正的jQuery了 自己实现一个构造函数去理解=======================&gt;demo jQuery的雏形 这次领导没再提需求，而是自己改起了代码 1234567891011121314151617181920212223window.jQuery = function(node)&#123; return &#123; getSiblings: function()&#123; var allChild = node.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i&lt; allChild.length; i++)&#123; if (allChild[i] !== node)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj &#125;, addClass: function(classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add':'remove' node.classList[methodName](key) //闭包的使用 &#125; &#125; &#125;&#125; 你看看我改了一个位置，你看着这像啥 我看了一会这难道是传说中的jQuery？ 这是它的雏形，大概意思你已经一步一步写出来了，jQuey就是一个构造函数，它返回一个对象，这个对象有很多key，对应的value又是一些函数。 那怎么还用$这个操作呢 哈哈，一个语法糖吗，你看 1window.$ = jQuery 给你出个题吧，你用现在的知识用jQuery实现把某个元素变红，最好验证一下，你的参数是node还是一个选择器，提示一下，可以用querySelector()，querySelector会返回文档中匹配指定的选择器组的第一个元素 我想了一会，写出如下代码 12345678910111213141516171819202122232425262728293031323334window.JQuery = function(nodeOrSelector)&#123; let node /*判断一下nodeOrSelector是node还是一个选择器 var node2 = JQuery(item3)这是nodej节点 var node2 = JQuery('#item3')这是Id选择器 */ if(typeof nodeOrSelector === 'string')&#123; node = document.querySelector(nodeOrSelector) &#125; else&#123; node = nodeOrSelector &#125; return &#123; getSiblings: function()&#123; var allChild = node.parentNode.children var childObj = &#123;length: 0&#125; for (let i = 0; i&lt; allChild.length; i++)&#123; if (allChild[i] !== node)&#123; childObj[childObj.length] = allChild[i] childObj.length += 1 &#125; &#125; return childObj &#125;, addClass: function(classes)&#123; for (var key in classes)&#123; var value = classes[key] var methodName = value ? 'add':'remove' node.classList[methodName](key) &#125; &#125; &#125;&#125; 所以 12//var node2 = JQuery('#item3')与下列代码作用相同，把item3变红var node2 = JQuery('ul &gt; li:nth-child(3)') jQuery的雏形======================&gt;demo 使用一下自己的jQuery，写一个API 少林那，你也会用初级的jQuery了，咱们练习一下，你把修改一下所有的&lt;li&gt;的内容吧，可以使用querySelectorAll() 返回一个NodeList的伪数组 我听完之后，思考了一会，写下了如下代码 1234567891011121314151617181920212223242526272829303132333435window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; if(typeof nodeOrSelector === 'string')&#123; let temp = document.querySelectorAll(nodeOrSelector) //NodeList for (let i = 0; i &lt; temp.length; i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if(nodeOrSelector instanceof Node)&#123; nodes = &#123;0: nodeOrSelector, length: 1&#125; &#125; nodes.addClass = function(classes)&#123; classes.forEach((value) =&gt; &#123; for (let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].classList.add(value) &#125; &#125;) &#125; nodes.getText = function()&#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++)&#123; texts.push(nodes[i].textContent) &#125; return texts &#125; nodes.setText = function(text)&#123; for (let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125; 经理看了之后，告诉我其实jQuery不喜欢get set的方法，所以它把两个方法合成一个方法，用if判断你传参的类型就能知道用户想获得还是要设置text。把getText setText属性改造成如下的text属性 12345678910111213141516//等同于get、set方法nodes.text = function(text)&#123; if(text === undefined)&#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++)&#123; texts.push(nodes[i].textContent) &#125; return texts &#125; else &#123; for (let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; &#125; 控制多个&lt;li&gt;的内容================================&gt;demo 一个很低级的错误在上述的过程中，我把class这个关键字竟然当成了变量名，还纳闷哪里出错了，耽误了很多时间。 情景再现 如果你只是想给每一个&lt;li&gt;元素添加红色，直接传red就可以了 123456//addClass属性简写成nodes.addClass = function(className)&#123; for (let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].classList.add(className) &#125; &#125; 可是一开始却是这样 变量命名一定要规范啊 由jQuery构造的变量尽量`#### 来表示比如 123window.$ = jQueryvar $div = $('div') //$div变量 是 所有div元素的伪数组 最终，少林在经理的循循善诱下，开始探索jQuery的道路。虽然jQuery使用量在下降，但是依然有60%的web开发人员在用。 以上并不是完全真实的jQuery的推导，只是大约是那个意思，可以帮助我更好的理解而已。真正的JQuery必须去看文档，英文文档，中文文档 总之，jQuery我来啦~去探索真正强大的jQuery吧，去理解write less, do more的含义吧,去体会一句顶一万句的力量吧。 最后安利一波刘震云的小说一句顶一万句","categories":[{"name":"jQuery学习","slug":"jQuery学习","permalink":"https://codevvvv9.github.io/categories/jQuery学习/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://codevvvv9.github.io/tags/jQuery/"}]},{"title":"原生DOM入门学习","slug":"原生DOM入门学习","date":"2018-01-07T15:46:24.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/07/原生DOM入门学习/","link":"","permalink":"https://codevvvv9.github.io/2018/01/07/原生DOM入门学习/","excerpt":"原生DOM接口挺多的，需要花点时间研究下，不过先把基础整好，后面框架估计好学点。 1. DOM是啥1.1 知识回顾先回顾一下HTML的基本结构 1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-Hans\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上就是最简单的HTML 5的结构。一般我们会把它处理成一棵树，一棵节点树。","text":"原生DOM接口挺多的，需要花点时间研究下，不过先把基础整好，后面框架估计好学点。 1. DOM是啥1.1 知识回顾先回顾一下HTML的基本结构 1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-Hans\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上就是最简单的HTML 5的结构。一般我们会把它处理成一棵树，一棵节点树。 以上就是一棵树，浏览器把html渲染成的树，也就是Document结构。每个框就是一个Element、标题等文本内容是Text。 Document、Element、Text 的祖先都是Node。以下是MDN的继承树 可是在内存中，存的不是html树，是一棵对应html各个节点的对象树，而且对象树的节点是与html树的节点一一对应的。 以上是内存中的对象树。这些对象应该怎么定义，是由DOM规范规定的。 也可以如下这么理解 页面中的节点，根据Element、Text、Document、Comment这些构造函数，构造出对象来，内存就理解了。 比如构造div 1234var div = document.createElement('div')undefineddiv &lt;div&gt;&lt;/div&gt; //打印结果 createElement就是构造函数。 把DOM的对应和JS基本语法练习起来。 1.2 DOM的真面目前面的基础分析完了，就可以知道什么是DOM了。 DOM就是完整的把Document和Object映射到一起，符合DOM规范的结构，所以具备很多的API。 DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。所以，DOM 可以理解成网页的编程接口。DOM 有自己的国际标准，目前的通用版本是DOM 3，下一代版本DOM 4正在拟定中。 严格地说，DOM 不属于 JavaScript，但是操作 DOM 是 JavaScript 最常见的任务，而 JavaScript 也是最常用于 DOM 操作的语言。 规范里的DOM模型竟然有多达31个接口，我先只挑Node接口和Document接口学习。 [图片上传失败…(image-3bad70-1515465954210)] 2. 原生DOM APIDOM是一棵树，树上有Node,Node分为Document、Element、Text，其他的可以忽略。 由前面的继承图可知Node的研究价值很高，我们先来看Node接口的属性和方法。下面是MDN对Node接口的解释 Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。 以下接口都从Node继承其方法和属性：Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference 2.1 Node的属性DOM树的最小单位就是节点（node）。文档的树形结构就是有各个不同列类型的节点组成的，每个节点都可以看做是这棵DOM树的叶子 常见的七种node类型 名字 作用 Document 整个文档树的顶层节点 但不是根节点 DocumentType doctype标签 Element 网页的其他各种标签 Attribute 标签的属性 Text 标签与标签之间的文本 Comment 注释 DocumentFragment 文档的片段 我们只关心Document、Element、Text 2.1.1 node之间的关系属性 一个最顶层的节点 document，代表整个文档。 一个根节点 html，是文档里面最高的一层，是根节点。其他所有的html标签都是他的下级 其他节点与周围节点的关系 parentNode: 直接的那个上级的节点 childNodes: 直接的下一级的节点 sibling：拥有同一个父节点的节点 Node.childNodes返回一个NodeList集合，成员包括当前节点的所有子节点。注意，除了HTML元素节点，该属性返回的还包括Text节点和Comment节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。 childNodes 注意： childNodes会把text也打印出来，也就是两个标签之间的换行符。 而且childNodes返回一个伪数组。这个伪数组对象的每一个元素依然都是html元素，如果想操作元素的内容还要用元素的其他属性。 document的childNodes只有两个 123456document.childNodes(2) [&lt;!DOCTYPE html&gt;, html] 0:&lt;!DOCTYPE html&gt; 1:html length:2 __proto__: NodeList 所以我们不想打印出text节点，可以使用children属性啊1ParentNode.children //ParentNode要是一个HTMLCollection 上述children属性会返回 一个Node的子elements 而没有text节点。 Node.firstChild和Node.lastChildfirstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null（注意，不是undefined）。 Node.lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。 Node.nextSibling和Node.previousSiblingNode.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。 previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。 以上的三组属性使用时一定要注意结果会有text的影响。 Node.parentNode12document.parentNodenull parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：element节点、document节点和documentfragment节点。 而且document节点和documentfragment节点，它们的父节点都是null。另外，对于那些生成后还没插入DOM树的节点，父节点也是null。 Node.parentElementparentElement属性返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null。 注意： 在IE浏览器中，只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性。 ownerDocument属性返回当前节点所在的顶层文档对象，即document对象 2.1.2 node自身的属性 nodeName和nodeTypenodeName返回node的名字，如果是element那名字是大写的,其他的名字前面写上#。nodeType返回node的类型，一般用数字表示，1表示element(也可以用Node.ELEMENT_NODE来表示)，3表示text(Node.TEXT_NODE)。 如果是element，那么nodeName === tagName 如果是text，那么nodeName = #text， tagName = undefined 关于nodeType有个详细的表格，应该查看MDN记住。对照表 nodeValue nodeValue属性返回或设置当前节点的值。对于text, comment节点来说, nodeValue返回该节点的文本内容，对于 attribute 节点来说, 返回该属性的属性值，而对于document和element节点来说，返回null。 貌似没个卵用，最常见的element都是null,还是用下面的textContent吧 textContent和innerText之争火狐推出的textContent，获得一个节点及其后代的文本内容，一般用这个获得元素的内容。 IE推出的innerText,两者有很大的区别。 关于textContent、innerText、innnerHTML之间的区别请看MDN 2.2 Node的方法Node.appendChild()Node.appendChild() 方法将一个节点添加到指定父节点的子节点列表的末尾。 var child = node.appendChild(child); node 是要插入子节点的父节点. child即是参数又是这个方法的返回值. Node.cloneNode()这个方法就是克隆一个node，分为浅拷贝和深拷贝。 浅拷贝，Node.cloneNode()只克隆元素节点本身，而不会克隆它的子节点。包括它的文本节点 深拷贝，Node.cloneNode(true)克隆元素的所有属性以及子节点 [图片上传失败…(image-f034a1-1515465954210)] 注意:为了防止一个文档中出现两个ID重复的元素,使用cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID [图片上传失败…(image-f7614d-1515465954210)]如果你想克隆同一个id的元素到不同的元素后面，会报错。 Node.contains()判断一个节点是不是另一个节点的子节点。 1div.contains(div1) div1是div的子节点就返回true。 Node.hasChildNodes()1div.hasChildNodes() 判断div节点是否还有子节点，有子节点就返回true。 Node.insertBefore()在当前节点的某个子节点之前再插入一个子节点。 1var insertedElement = parentElement.insertBefore(newElement, referenceElement); 在parentElement节点的子节点referenceElement前面插入一个newElement节点。 如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。 没有 insertAfter 方法。可以使用 insertBefore 方法和 nextSibling 来模拟它。 1parentDiv.insertBefore(sp1, sp2.nextSibling); 只要sp2.nextSibling === null，那么就可以在parentDiv的末尾添加sp1元素。 Node.isEqualNode()和Node.isSameNode()两者都是比较两个node是否相等。不过isEqualNode()是两个node看起来相等就返回true，isSameNode()严格使用===判断，而且该方法已被废弃，如果要严格判断两个node是否指向同一个对象，直接用node1 === node2。 Node.normalize()就是规范化的意思。什么是规范化，在一个”规范化”后的DOM树中，不存在一个空的文本节点，或者两个相邻的文本节点。 123456789101112var wrapper = document.createElement(\"div\");wrapper.appendChild(document.createTextNode(\"Part 1 \"));wrapper.appendChild(document.createTextNode(\"Part 2 \"));// 这时(规范化之前),wrapper.childNodes.length === 2// wrapper.childNodes[0].textContent === \"Part 1 \"// wrapper.childNodes[1].textContent === \"Part 2 \"wrapper.normalize();// 现在(规范化之后), wrapper.childNodes.length === 1// wrapper.childNodes[0].textContent === \"Part 1 Part 2\" 以上是MDN的例子，很好懂。 以上是自己模仿的demo Node.removeChild()和Node.replaceChild()Node.removeChild()是从当前节点删除一个子节点，不过内存里面依然存在，只不过不在页面显示了，返回的就是被移除的那个节点。所以说一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。 以上是我做的demo Node.replaceChild方法用于将一个新的节点，替换掉当前节点的一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。 我做的实验demo Document属性和方法关于Document接口的属性和方法，且听下回分解~","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"初探JS的函数","slug":"初探JS的函数","date":"2018-01-05T15:20:38.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/05/初探JS的函数/","link":"","permalink":"https://codevvvv9.github.io/2018/01/05/初探JS的函数/","excerpt":"什么是函数函数是对象的一种，也是一段可以重复使用的代码块，开发人员为了完成某项功能，把相关代码块放到一起。 函数内部可以传参，也可以被当做参数传递","text":"什么是函数函数是对象的一种，也是一段可以重复使用的代码块，开发人员为了完成某项功能，把相关代码块放到一起。 函数内部可以传参，也可以被当做参数传递 目前定义函数有五种方法 具名函数来定义1234function f(x, y)&#123; return x + y&#125;f.name //'f' 匿名函数来定义12345var ff = function(x, y)&#123; return x + y&#125;f.name //'f' 具名函数定义了又赋值给了变量12345var f1f1 = function f(a, b)&#123; return a + b&#125;f1.name //'f' 要注意：虽然f1.name=&#39;f&#39;，但是f只在函数内部可用，实际上函数的名字还是f1 window.Function来构造12var f2 = new Function('x', 'y', 'return x + y')f2.name //'anonymous' 箭头函数123var f3 = (x, y) =&gt; &#123;return x - y&#125;var sum = (x, y) =&gt; x + y //函数体内只有一行代码，可以省略大括号和returnvar n2 = n =&gt; n*n //只有一个参数，可以省略小括号 常用的定义方法是1、2、5这三种方法。 函数的一些必备知识函数的name属性由上面的五种定义方法，我们可以知道函数具有name属性，而且不同的定义方法，name属性也很奇葩。 函数如何调用为了理解后面的this，推荐使用call()方法，而不是使用常见的f() 以第一种定义方法为例 12f.call(undefined, 1, 3)4 call()方法的第一个参数就是this,后面的参数才是函数的执行参数。 下面用代码检验一下 12345678function f1(m, n)&#123; console.log(this) console.log(m + n)&#125;undefinedf1.call(undefined, 1, 3)Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; //不是应该打印undefined，为啥是window呢？4 //这才是函数的执行内容 执行f1.call(undefined, 1, 3)后，this不是应该打印出undefined吗，为啥打印了Window呢（注意实际上是个小写的window,不是浏览器打印的大写的Window）,可以用代码验证打印的就是小写的window 12345678910111213141516function f1(m, n)&#123; console.log(this === window) console.log(m + n)&#125;undefinedf1.call(undefined, 1, 3)true //说明是小写的window4function f1(m, n)&#123; console.log(this === Window) console.log(m + n)&#125;undefinedf1.call(undefined, 1, 3)false //并不是大写的Window4 我真是服啦，那window和Window有啥区别呢。真是蛋疼啊，竟然考虑这个问题…… 答案就是 var object = new Object，那var window = new Window。而且Window毫无探讨的意义，倒是这个window是个全局属性，多少有点用。 有时候自己真是有点钻牛角尖，钻进去后，还不会举一反三。如果立刻想到obj的例子就不用浪费时间了。 这就是藏着的this这是因为浏览器捣的鬼，他把undefined变成了window。接下来使用严格模式，让undefined现身 123456789function f1(m, n)&#123; 'use strict' console.log(this) console.log(m + n)&#125;undefinedf1.call(undefined, 1, 3)undefined //这个undefined就是call()方法的第一个参数undefined4 而且call()的第一个参数是啥，this就是啥 123456789function f1(m, n)&#123; 'use strict' console.log(this) console.log(m + n)&#125;undefinef1.call('我是啥this就是啥', 1, 3)我是啥this就是啥 //打印的依然是call()的第一个参数4 arguments前面分析了call()的第一个参数，那后俩参数是啥呢。 对，你没猜错，那就是arguments。 当你写call(undefined, 1, 3)的时候。undefined可以被认为是this，[1, 3]就是arguments 函数的call stack上面我们接触了call()方法，现在我们学习一下当有多个函数调用的时候，JavaScript解析器是如何调用栈的。 MDN的解释如下 调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁） 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。 当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。 如果栈占用的空间比分配给它的空间还大，那么则会导致“堆栈溢出”错误。 以下是通过三个方面去理解call stack这个概念的。 普通调用代码如下，直观的动图可以看上述的链接 123456789101112131415161718function a()&#123; console.log('a') return 'a' &#125;function b()&#123; console.log('b') return 'b'&#125;function c()&#123; console.log('c') return 'c'&#125;a.call()b.call()c.call() 如上的代码，先有三个函数声明，然后是三个调用。浏览器先执行a.call()，然后执行b.call()，c.call()，下面结合图具体详细分析。 第一步：浏览器入口是a.call(),a函数入栈，执行a函数内部代码 第二步：console.log(‘a’)执行完毕，就出栈，接着a函数结束，出栈死亡 第三步：b.call()入栈，执行b函数内部代码 第四步： console.log(‘b’)执行完毕就出栈，接着b函数结束，出栈死亡 第五步：c.call()入栈，执行c函数内部代码 第六步：console.log(‘c’)执行完毕就出栈，接着c函数结束，出栈死亡。 整个代码结束，浏览器恢复平静。 嵌套调用123456789101112131415161718function a()&#123; console.log('a1') b.call() console.log('a2') return 'a' &#125;function b()&#123; console.log('b1') c.call() console.log('b2') return 'b'&#125;function c()&#123; console.log('c') return 'c'&#125;a.call()console.log('end') 第一步：浏览器的入口还是a.call()，a.call()入栈，执行a函数内部的代码 第二步： a函数的第一行语句console.log(‘a1’)，入栈，打印出a1，这句话就出栈死亡。此时a函数继续执行下面的代码。 第三步： a函数的第二行语句b.call()入栈。执行b函数内部的代码。 第四步：进入b函数内部，b函数的第一行语句console.log(‘b1’)入栈，打印出b1，就出栈死亡。 第五步：b函数的第二行c.call()入栈，又进入c函数内部 第六步：进入c函数的内部，第一行语句console.log(‘c’)入栈，打印出c,就出栈死亡。 第七步：c函数执行完毕，出栈死亡。 第八步：回到b函数内部，执行第三行代码console.log(‘b2’)入栈，打印出b2，出栈死亡。 第九步： b函数执行完毕，出栈死亡。 第十步： 回到a函数内部，执行第三行代码console.log(‘a2’)，入栈，打印出a2，就出栈死亡。 第十一步：a函数执行完毕，出栈死亡。 第十二步：console.log(‘end’)入栈，打印出end,出栈死亡。 整个代码运行完，浏览器归于平静。 递归调用递归调用就是上面的嵌套调用的复杂变化，细心点，分析就能明白具体的代码顺序。 函数作用域除了全局变量，其他变量只能在自己的函数内部被访问到，其他区域无法访问。通过几个面试题来学习一下。 第一道面试题 123456var a = 1function f1()&#123; alert(a) // 是多少 var a = 2&#125;f1.call() 问：alert出什么东西？ 这种题切忌上去就做，容易打错成了 a是2 一定要先把变量提升。变成如下这样的 1234567var a = 1function f1()&#123; var a alert(a) a = 2&#125;f1.call() 这样一提升就知道啦，答案：a是undefined。 第二道面试题 123456789var a = 1function f1()&#123; var a = 2 f2.call()&#125;function f2()&#123; console.log(a) // 是多少&#125;f1.call() 问：a是多少 这个题用就近原则好做。 用树形结构来分析，当上面的代码被浏览器渲染之后 全局变量里面有：var a = 1，f1、f2函数 f1函数作用域里面又重新声明了一个var a = 2 f2函数作用域里面是console.log(a) 所以打印的那个a就是全局的a，答案是a=1","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"JavaScript标准库之数组","slug":"JavaScript标准库之数组","date":"2018-01-02T14:42:38.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2018/01/02/JavaScript标准库之数组/","link":"","permalink":"https://codevvvv9.github.io/2018/01/02/JavaScript标准库之数组/","excerpt":"学习任何编程语言，数组都是绕不过去的坎，每个编程语言都在其标准库里面内置了功能强大的Array对象。通过参考阮一峰教程和MDN,我把数组常见的方法以及一些误区总结如下，内容较多，而且会继续补充，希望这一篇文章可以把数组的知识一网打尽。","text":"学习任何编程语言，数组都是绕不过去的坎，每个编程语言都在其标准库里面内置了功能强大的Array对象。通过参考阮一峰教程和MDN,我把数组常见的方法以及一些误区总结如下，内容较多，而且会继续补充，希望这一篇文章可以把数组的知识一网打尽。 1. 数组的简单概念1.1 数组是什么呢？编程总要和数据打交道，常见的普通的数据由基本数据类型可以定义，一些具有多重属性、内容的数据就需要复杂的数据类型去定义，也就是对象来定义，数组也是对象的一种。 为了方便理解，我们可以认为数组是具有一定顺序的复杂数据的组合(与对象的无序区别)，每个位置对应一个索引，索引从0开始，具有length属性，而且length属性是可变的。1.2 数组如何定义 第一种方法是通过Array构造函数来定义(该方法并不常用) 123456var arr1 = new Array(3)undefinedarr1(3) [empty × 3] length: 3 __proto__: Array(0) 以上是控制台打印结果，构造了一个长度为3的、每个元素为空的数组。 以上的写法有个小bug虽然元素为空，但是正常来说，索引应该存在的，但是事实是 索引竟然不存在1234567891011arr1[0]undefinedarr1[1]undefinedarr1[2]undefined0 in arr1false1 in arr1false2 in arr1 索引0、1、2处是undefined，完全合理，但是索引不存在，很奇怪 而且new不写也是一样的结果。 123456var arr2 = Array(3)undefinedarr2(3) [empty × 3] length: 3 __proto__: Array(0) 但是采用构造函数的这种方法容易产生一些歧义，不同的参数个数，会产生不同的结果。1.2.1 构造函数不写参数 123456var arr3 = new Arrayundefinedarr3[] length:0 __proto__:Array(0 此时构造出空的数组，而且发现构造函数的()写不写都可以 1.2.2 构造函数写1个正整数参数那这个正整数参数就是构造出来的数组的长度。 1.2.3 构造函数参数是一个非正整数(字符串、boolean、对象等其他值)1234567var arr = new Array('jjj')undefinedarr[\"jjj\"] 0: \"jjj\" length: 1 __proto__: Array(0) 1234567var arr = new Array(false)undefinedarr[false] 0: false length: 1 __proto__: Array(0) 1234567var arr = new Array(&#123;0: '我是一个对象'&#125;)undefinedarr[&#123;…&#125;] 0: &#123;0: \"我是一个对象\"&#125; length: 1 __proto__: Array(0) 这个非正整数就是数组的内容 1.2.4 构造函数写多个参数12345678var arr4 = new Array(1, 2)undefinedarr4(2) [1, 2] 0: 1 1: 2 length: 2 __proto__: Array(0) 此时直接构造出0索引是元素1、1索引是元素2的数组对象。 12345678910var arr4 = new Array('aa', 'ff', 10, 0)undefinedarr4(4) [\"aa\", \"ff\", 10, 0] 0: \"aa\" 1: \"ff\" 2: 10 3: 0 length: 4 __proto__:Array(0) 即多参数时，所有参数都是返回的新数组的成员 1.2.5 构造函数参数是非正整数，报错12345678new Array(-1)VM376:1 Uncaught RangeError: Invalid array length at &lt;anonymous&gt;:1:1(anonymous) @ VM376:1new Array(3.2)VM377:1 Uncaught RangeError: Invalid array length at &lt;anonymous&gt;:1:1(anonymous) @ VM377:1 1.2.6 数组定义的正确方法综上所述，其实实际中直接用字面量定义数组123456789101112var arr = ['这样子', '定义', 'is', true, 1, &#123;'good': '我是数组索引为5的元素的值'&#125;]undefinedarr(6) [\"这样子\", \"定义\", \"is\", true, 1, &#123;…&#125;] 0: \"这样子\" 1: \"定义\" 2: \"is\" 3: true 4: 1 5: &#123;good: \"我是数组索引为5的元素的值\"&#125; length: 6 __proto__:Array(0) 2. 数组的length属性解疑如果你是初学者，一定要记住数组的length属性和里面的元素个数无关，爱几个元素几个元素，length并不是计数的作用。这是我自学是对数组长度最大的误解。正确的理解是：数组的length属性等于最大正整数索引 + 1而数组的索引可以随便改变，那么length属性也是一个动态的值，可以变化。12345678910111213var arr = []undefinedarr[] length:0 __proto__:Array(0)arr[10] = '我是第10个元素，我前面没有元素，但是数组的长度绝对是11，你信不信'\"我是第10个元素，我前面没有元素，但是数组的长度绝对是11，你信不信\"arr(11) [empty × 10, \"我是第10个元素，我前面没有元素，但是数组的长度绝对是11，你信不信\"] 10:\"我是第10个元素，我前面没有元素，但是数组的长度绝对是11，你信不信\" length:11 __proto__:Array(0) 这个例子一开始是个空数组，长度是0，直接给他一个索引10，可以发现长度立马变为11。1234arr[100] = '这次数组长度绝对是101'\"这次数组长度绝对是101\"arr.length101 通过以上的例子，我们反向推理，把可以明白数组长度根本不连续，是动态变化的，即数组长度是可写的。唯一的不变真理是，它的长度永远等于最大索引+1。 2.1 把数组清空的方法由以上知识可以知道数组长度可以人为改变，进而大胆的猜想，改变长度会不会把数组清空呢？123456789101112131415161718192021222324252627282930var arrDemo = ['this', 'is', 'test']undefinedarrDemo(3) [\"this\", \"is\", \"test\"] 0: \"this\" 1: \"is\" 2: \"test\" length: 3 __proto__: Array(0)arrDemo['length'] = 22arrDemo(2) [\"this\", \"is\"] 0: \"this\" 1: \"is\" length: 2 __proto__: Array(0)arrDemo['length'] = 11arrDemo[\"this\"] 0: \"this\" length: 1 __proto__: Array(0)arrDemo['length'] = 00arrDemo[] length: 0 __proto__: Array(0) 把数组length设为0，证明可以清空数组。 2.2 有趣的一点由于数组本质上是对象的一种，所以我们可以为数组添加属性，但是这不影响length属性的值。一定不要有思维定式，以为添加几个新元素，长度就会加几个。123456789101112131415161718192021var arr = []undefinedarr[] length:0 __proto__:Array(0)arr['add'] = '我加一个新元素，长度绝对还是0'\"我加一个新元素，长度绝对还是0\"arr[add: \"我加一个新元素，长度绝对还是0\"] add: \"我加一个新元素，长度绝对还是0\" length:0 __proto__:Array(0)arr['add1'] = '我又加一个新元素，长度绝对还是0'\"我又加一个新元素，长度绝对还是0\"arr[add: \"我加一个新元素，长度绝对还是0\", add1: \"我又加一个新元素，长度绝对还是0\"] add: \"我加一个新元素，长度绝对还是0\" add1: \"我又加一个新元素，长度绝对还是0\" length: 0 __proto__:Array(0) 通过这个例子，一开始元素长度为0，只要你没添加一个正整数的索引，无论你添加多少其他元素，长度永远不会变化。 注意：方括号运算符里面一定要用引号，我总是手抖忘了加。3. 伪数组(array-like object)如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”12345678910111213141516171819var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3,&#125;undefinedobj&#123;0: \"a\", 1: \"b\", 2: \"c\", length: 3&#125; 0: \"a\" 1: \"b\" 2: \"c\" length: 3 __proto__: Objectobj[0]\"a\"obj[2]\"c\" 上面的对象，看着结构特别像但是绝对不是数组。因为proto指向的就不是Array的prototype，没有指向Array的共有属性，再怎么想也只是模仿，本质不同。不具备数组的其他方法（第四部分将要列举的方法）。 3.1 数组的本质由伪数组的问题引出真正的数组应该具备什么特点proto必须指向数组的公有属性才是真正的数组对象。 4. 数组实例的常见简单的方法(可以无参或者参数很简单)4.1 判断数组还是对象12345678910111213var arr = ['a']undefinedArray.isArray(arr)truevar obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3,&#125;undefinedArray.isArray(obj)false Array.isArray()方法可以判断是不是数组对象，以前学过的instanceOf也可以判断。1234arr instanceof Arraytrueobj instanceof Arrayfalse 所以现在有两个方法可以区分是数组还是对象了。 4.2 valueOf()，toString() valueOf()返回数组本身 123456var arr = ['a', 'b']undefinedarr.valueOf()(2) [\"a\", \"b\"]arr.toString()\"a,b\" toString()返回数组的字符串形式 4.3 push()123456var arr = ['a', 'b']undefinedarr.push('f')3arr(3) [\"a\", \"b\", \"f\"] 向数组的末尾添加元素，返回添加成功后的数组的长度会改变原数组 4.4 pop()1234arr.pop()\"f\"arr(2) [\"a\", \"b\"] 删除数组的最后一个元素，并返回删除的这个元素。1[].pop() // undefined 注意：对空数组使用pop方法，不会报错，而是返回undefined。这个方法会改变原数组 push() 和pop()方法一起使用可以模拟栈这个数据结构 4.5 join()以某种形式把数组的所有成员以字符串的形式返回1234arr(2) [\"a\", \"b\"]arr.join('-')\"a-b\" 以上是以中划线的形式连接起来12arr.join()\"a,b\" 如果没有规定格式，则以逗号分隔123456var arr = ['a', 'rr', null, undefined]undefinedarr(4) [\"a\", \"rr\", null, undefined]arr.join()\"a,rr,,\" 注意：如果字符串中有null和undefined的，会被转成空字符串。该方法不会改变原数组4.6 concat()是一个专业合并数组的方法。123456var arr = ['a', 'rr', null, undefined]undefinedarr.concat(['rrr'])(5) [\"a\", \"rr\", null, undefined, \"rrr\"]arr(4) [\"a\", \"rr\", null, undefined] 把一个新数组添加到旧数组的后面，返回生成的新数组。不会改变原数组 4.7 shift()删除数组的第一个元素,并返回删除的那个元素123456arr(4) [\"a\", \"rr\", null, undefined]arr.shift()\"a\"arr(3) [\"rr\", null, undefined] 会改变原数组 push()与shift()方法结合，可以模拟队列这个数据结构 4.8 unshift()在数组的第一个位置添加元素，并返回添加新元素后的数组长度123456arr(3) [\"rr\", null, undefined]arr.unshift('ffff')4arr(4) [\"ffff\", \"rr\", null, undefined] 和shift()方法的作用正好相反。一定会改变原数组 4.9 reverse()反转数组，返回反转后的数组123456arr(4) [\"ffff\", \"rr\", null, undefined]arr.reverse()(4) [undefined, null, \"rr\", \"ffff\"]arr(4) [undefined, null, \"rr\", \"ffff\"] 会改变原数组 4.10 slice()提取原数组的一部分，返回一个新的数组12345678910arr(4) [undefined, null, \"rr\", \"ffff\"]arr.slice(1,3)(2) [null, \"rr\"]arr.slice()(4) [undefined, null, \"rr\", \"ffff\"]arr.slice(1)(3) [null, \"rr\", \"ffff\"]arr(4) [undefined, null, \"rr\", \"ffff\"] arr.slice(1,3)从索引为1的位置开始截取，到索引3停止，但是不包括索引3。arr.slice()无参是原数组的拷贝arr.slice(1)从索引为1的位置开始截取，到末尾。123var a = ['a', 'b', 'c'];a.slice(-2) // [\"b\", \"c\"]a.slice(-2, -1) // [\"b\"] 如果slice方法的参数是负数，则表示倒数计算的位置。上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。 slice()方法可以把伪数组变成真的数组 不会改变原数组 4.11 splice()删除原数组的一部分成员，返回被删的元素。123456arr(4) [undefined, null, \"rr\", \"ffff\"]arr.splice(1, 3)(3) [null, \"rr\", \"ffff\"]arr[undefined] arr.splice(1,3)，从索引1开始删除，删3个元素！！！一定要注意和slice区分：splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。123456var arr = ['1', 'aaa', 'ff', 'aff', 1]undefinedarr.splice(1, 3, 'wu', 999)(3) [\"aaa\", \"ff\", \"aff\"]arr(4) [\"1\", \"wu\", 999, 1] arr.splice(1, 3, ‘wu’, 999)，从索引1开始删了3个元素，有加上两个元素，’wu’和999同样的负数表示倒数第几个位置会改变原数组splice()有两个变式 变式1:我只是想单纯的插入一个元素123var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1] 把第二个参数设为0,就可以在第2个位置插入一个元素了 变式2:我只给一个参数，就是拆分数组，为两个新数组123456a(5) [1, 1, 1111, 1, 10]a.splice(2)(3) [1111, 1, 10]a(2) [1, 1] a.splice(2)从第三个索引处拆分这个数组。 4.12 indexOf()，lastIndexOf()12345678910111213141516var arr = ['a', 'f', 'f', 1]undefinedarr(4) [\"a\", \"f\", \"f\", 1] 0: \"a\" 1: \"f\" 2: \"f\" 3: 1 length: 4 __proto__: Array(0)arr.indexOf(1)3arr.indexOf('f', 3)-1arr.lastIndexOf('f')2 indexOf()，返回括号里面 的元素第一次出现的位置。如果有两个参数则是表示搜索的位置从第二个参数开始。如果找不到该元素，则返回-1。lastIndexOf()返回括号里面的元素最后一次出现的位置。 一个MDN的实战例子：获得数组里面某个元素出现的所有位置(利用循环和返回值-1的特点)12345678910var arr = ['a', 0, 'a', 'b', 'a'];var arrTemp = []; //空数组用来存储目标元素出现的所有索引var element = 'a';var index = arr.indexOf(element);while(index != -1)&#123; arrTemp.push(index); index = arr.indexOf(element, index + 1);&#125;console.log(arrTemp);(3) [0, 2, 4] //'a'出现在0、2、4索引位置处 注意：这里有个例外数组里面包含NaN时无法判断1234567891011121314var arr = ['a', 'f', 'f', NaN]undefinedarr(4) [\"a\", \"f\", \"f\", NaN] 0: \"a\" 1: \"f\" 2: \"f\" 3: NaN length: 4 __proto__: Array(0)arr.indexOf(NaN)-1arr.lastIndexOf('NaN')-1 arr数组的第四个位置是NaN,但是无法获得索引。因为indexOf()，lastIndexOf()是严格按照===操作符来检测的，而NaN是唯一的不与自身相等的值。123456NaN === NaNfalse1 === 1true'a' === 'a'true 奇葩啊，NaN与自己都不相等 5. 数组实例的常见复杂的方法(参数是另一个函数)5.1 sort()下面MDN的解释非常棒 sort() 方法在适当的位置对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。 123456789101112131415var fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 21, 2]; scores.sort(); // [1, 10, 2, 21]// 注意10在2之前,// 因为在 Unicode 指针顺序中\"10\"在\"2\"之前var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']// 在Unicode中, 数字在大写字母之前,// 大写字母在小写字母之前. 上述代码两点注意 第一点是上述代码中的第二部分的[1, 10, 2, 21]是因为10的Unicode编码是\\u0031\\u0030，2的Unicode编码是\\u0032，所以10排在2的前面 第二点是上述代码中的第三部分的[&#39;1 Word&#39;, &#39;2 Words&#39;, &#39;Word&#39;, &#39;word&#39;]是因为&#39;Word&#39;的Unicode编码是 1\\u0026\\u0023\\u0033\\u0039\\u003b\\u0057\\u006f\\u0072\\u0064\\u0026\\u0023\\u0033\\u0039\\u003b &#39;word&#39;的Unicode编码是 1\\u0026\\u0023\\u0033\\u0039\\u003b\\u0077\\u006f\\u0072\\u0064\\u0026\\u0023\\u0033\\u0039\\u003b 所以 ‘Word’排在’word’前面。 各种编码查询站长工具sort方法明显的会改变原数组啊 我们通常不想使用默认的升序排列，sort方法可以传入函数来改变顺序。MDN的语法是arr.sort(compareFunction)compareFunction这个函数用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的诸个字符的Unicode位点进行排序。compareFunction这个函数基本的规则是传入两个参数 123function compareNumbers(a, b) &#123; return a - b;&#125; a,b参数比较 代表的意思 compareFunction(a, b) &lt; 0 a在b之前 compareFunction(a, b) &gt; 0 b在a之前 123456var a = [1, 20, 30, -7]undefineda(4) [1, 20, 30, -7]a.sort(function(a,b)&#123;return b-a&#125;)(4) [30, 20, 1, -7] 降序排列。 也可以根据具体需求来根据属性来排列123456var students = ['小明','小红','小花']; var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125;; students.sort(function(a, b)&#123; return scores[b] - scores[a]&#125;);(3) [\"小红\", \"小花\", \"小明\"] 以上是把三个学生根据成绩从大到小排列的 5.2 map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。不影响原数组。1234567var arr = ['aa', 'bb', 'cc']arr.map(function(value)&#123; return value = value + \"f\"&#125;)(3) [\"aaf\", \"bbf\", \"ccf\"]arr(3) [\"aa\", \"bb\", \"cc\"] 以上代码中map()方法里面传入的函数是一个把数组每个值都加上一个’f’。每个元素末尾都加上一个’f’，然后返回这个新的数组，原数组没有任何变化的。我初学的时候，看到上述代码反正很懵逼，这玩意咋出来的这个结果呢。琢磨了很久，还是觉得MDN的解释明白，只不过需要看个3、4遍就能明白了。语法规范是:123let new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]) callback生成新数组元素的函数，使用三个参数：currentValuecallback 的第一个参数，数组中正在处理的当前元素。indexcallback 的第二个参数，数组中正在处理的当前元素的索引。arraycallback 的第三个参数，map 方法被调用的数组。thisArg可选的。执行 callback 函数时 使用的this 值。返回值一个新数组，每个元素都是回调函数的结果。1234[1, 2, 3].map(function(currentValue, index, arr)&#123; return currentValue*index&#125;)(3) [0, 2, 6] 其实callback 的第三个参数可以不写，也知道调用的到底是哪个Array。1234[1, 2, 3].map(function(currentValue, index)&#123; return currentValue*index&#125;)(3) [0, 2, 6] 当你用map()方法的时候，callback 函数会被自动传入三个参数：数组的每一个元素，元素索引，原数组本身。既然原数组本身可以省略，那么由剩下的两个特点我们发散一下，会想到前面我们讲过，伪数组(比如字符串)也具备这两个特点会不会也能用map()方法呢，接下来做个实验。哈哈哈哈，愚蠢的人类，你想的美，怎么可能直接使用呢，必须把伪数组转换一下的。 第一种转换方法12345var upper = function (str)&#123; return str.toUpperCase();&#125;;[].map.call('abc', upper)(3) [\"A\", \"B\", \"C\"] 以上是通过map函数的call方法间接使用 第二种转换方法12'abc'.split('').map(upper)(3) [\"A\", \"B\", \"C\"] &#39;abc&#39;.split(&#39;&#39;)把字符串转成数组[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 至此，字符串和数组相互转化的方法，都学到了,总结如下。 数组转字符串 三种方法 123456[1, 3, 4].toString()\"1,3,4\"[1, 3, 4] + ''\"1,3,4\"[1, 3, 4].join()\"1,3,4\" 字符串转数组 一种方法 12'abxc'.split('')(4) [\"a\", \"b\", \"x\", \"c\"] 在map()的最后，要注意数组的空位问题。我们先看一个map()处理含有空位的数组的奇怪现象12345678var f = function(n)&#123; return n + 1 &#125;;undefined[1, , 2].map(f) (3) [2, empty, 3][1, undefined, 2].map(f)(3) [2, NaN, 3][1, null, 2].map(f)(3) [2, 1, 3] 可以发现[1, , 2].map(f)空位未执行map()。map方法不会跳过undefined和null，但是会跳过空位。1234null + 1 = 1true + 1 = 2false + 1 = 1//好奇怪 用一个更直观的例子来证明map方法会跳过空位1234567Array(2).map(function ()&#123; console.log('enter...'); return 1;&#125;)(2) [empty × 2] length: 2 __proto__: Array(0) 本文一开始就讲了Array[2]始构造了长度为2的空数组，没有打印出enter，说明未执行map()方法。 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 以上引入了数组的空位（hole）概念，那什么才是数组的空位呢var a= [1, , 2] 中间就是一个空位12345678910var a= [1, , 2]undefineda(3) [1, empty, 2] 0: 1 2: 2 length: 3 __proto__: Array(0)a[1]undefined 可以看到，空位计入数组长度,空位可读取，但是是undefined。delete命令可以删除数组内的一个元素123456789a(3) [1, empty, 2]delete a[0]truea(3) [empty × 2, 2] 2: 2 length: 3 __proto__: Array(0) delete命令删除成功，返回true,但是length不变，说明空位可以被读取到，所以用delete命令无法清空数组。目前把数组清空的唯一方法就是把length属性改为0。换句话说length属性不能过滤空位。当使用length属性进行数组遍历时，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。为什么不一样呢。 如果是空位，使用数组的forEach方法(接下来重点研究)、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。 123456789101112131415161718192021222324252627var a = [1, , , 5]undefineda(4) [1, empty × 2, 5] 0: 1 3: 5 length: 4 __proto__: Array(0)//只打印出了已经存在具体数值的1和5a.forEach(function(x)&#123;console.log(x)&#125;)15undefined//只有0索引和3索引for (var i in a) &#123; console.log(i);&#125;03undefined//只有0索引和3索引Object.keys(a)(2) [\"0\", \"3\"] 0: \"0\" 1: \"3\" length: 2 __proto__: Array(0) 如果是undefined，使用数组的forEach方法(接下来重点研究)、for…in结构、以及Object.keys方法进行遍历，不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + '. ' + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// ['0', '1', '2'] 上面的对比可以知道，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 5.3 forEach()该方法与map()类似，都是使数组的每个元素执行一个函数。与map()的最大区别是没有返回值，而map()返回一个新的数组。forEach()只关心数据的操作，而不关心返回值。forEach()方法传入的函数，实际上是有3个值。MDN的语法规范12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数列表的含义与map()方法的每个参数含义相同。callback()函数的array参数，通常省略，自己要脑补上。1234567//x就是数组的每一个元素，i是每一个元素的索引arr.forEach(function(x, i)&#123; console.log(i + ': ' + x)&#125;)0: 11: 22: 3 谁去调用的forEach()方法，那么callback()里面的array就会自动传入那个数组，但是是隐藏的。和我一样的初学者，都曾怀疑过，哪里传进来的数组呢，最好的答案都在MDN的callback()函数的语法规则里面，具体的细节分析和map()的分析一样。 注意: 用forEach()方法遍历数组，无法再某个条件时停止遍历，此时应该用普通的for循环1234567var arr1 = [1, 2, 3]undefinedfor (let i = 0; i &lt; arr1.length; i++)&#123; if(arr1[i] === 2)&#123;break;&#125; console.log(i)&#125;0 上面代码中，执行到数组的第二个成员时，就会中断执行。forEach方法做不到这一点。 与map()方法一样，forEach方法会跳过数组的空位。而不会跳过undefined和null。 1234567891011121314151617var log = function (n) &#123; console.log(n + 1);&#125;;[1, undefined, 2].forEach(log)// 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3 当然了，forEach方法也可以用于类似数组的对象和字符串。 1234567891011121314151617181920var obj = &#123; 0: 1, a: 'hello', length: 1&#125;Array.prototype.forEach.call(obj, function (value, i) &#123; console.log( i + ':' + value);&#125;);// 0:1var str = 'hello';Array.prototype.forEach.call(str, function (value, i) &#123; console.log( i + ':' + value);&#125;);// 0:h// 1:e// 2:l// 3:l// 4:o 对象和字符串使用foreach一定要用Array.prototype.forEach.call()的。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 shift()) ，之后的元素将被跳过 ε=(´ο｀*)))唉，上面这段话啊，可以看出forEach()和map()函数如此的相似啊。 举一个MDN上面的例子，一旦数组被修改了，遍历不受你的影响1234567891011var words = [\"one\", \"two\", \"three\", \"four\"];words.forEach(function(word) &#123; console.log(word); if (word === \"two\") &#123; words.push('aaa'); &#125;&#125;);onetwothreefour 我们发现遍历出了原来的所有元素，在forEach()开始之后的添加的&#39;aaa&#39;并不会遍历到。不过MDN的例子比我的难度大多了啊。12345678910var words = [\"one\", \"two\", \"three\", \"four\"];words.forEach(function(word) &#123; console.log(word); if (word === \"two\") &#123; words.shift(); &#125;&#125;);// one// two// four 当到达包含值”two”的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 “four”现在在原数组的第三个位置，three跑到了第二个位置，而此时要去遍历第三个位置，所以不会打印three。 5.4 filter()filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。通俗的理解就是过滤器。callback()函数与以上两个一样，也是传入三个参数。第一个参数是当前数组成员的值，这个是必须的。123456var arr = [1, 3, 5, 7]undefinedarr.filter(function(value)&#123;return value&gt;5&#125;)[7]arr.filter(function(value)&#123;return value&gt;1&#125;)(3) [3, 5, 7] 可以理解为给filter()传入的函数一个规则，满足规则的才能返回。 5.5 reduce() reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。以上是MDN的解释，挺难理解字面意思的。直接用实例来理解吧。 累加求和123456var arr = [1, 3, 10, 6] undefinedarr.reduce(function(preSum, ele)&#123; return preSum + ele;&#125;)20 reduce()函数传入一个函数作为参数，函数里面传入两个参数，preSum默认是数组的第一个元素，每次都把数组的两个元素相加并返回，ele就是每个数组元素。你也快成规定起始的累加值1234arr.reduce(function(preSum, ele)&#123; return preSum + ele;&#125;, 10)30 起始的累加值是10，那么加上数组的20就是30。 用reduce表示map()1234567var arr = [1, 3, 4]undefinedarr.reduce(function(arr, n)&#123; arr.push(n*2) return arr&#125;, [])//[]空数组作为一个初始值(3) [2, 6, 8] 利用reduce()完成了map()一样的功能 用reduce表示filter()123456789var arr = [1, 3, 4, 10, 30]undefinedarr.reduce(function(arr, n)&#123; if(n&gt;3)&#123; arr.push(n) &#125; return arr&#125;, [])(3) [4, 10, 30] 如果原数组里面的值大于3,就放到新的数组里面。和filter()道理一样。 计算数组里面技术的和var a = [1,2,3,4,5,6,7,8,9]计算所有奇数的和123456789var a = [1,2,3,4,5,6,7,8,9]a.reduce(function(sum, n)&#123; if(n % 2 === 0)&#123; return sum &#125; else&#123; return sum + n &#125;&#125;)25 先判断一下，再把奇数相加 5.6 几个方法组合使用 计算数组的偶数和给定一个 数组 var a = [1,2,3,4,5,6,7,8,9] 获取所有偶数 得到所有偶数的平方1234567a.filter(function(n)&#123; if (n %2 ===0)&#123; return n &#125;&#125;).map(function(n)&#123; return n*n&#125;)//[4,16,36,64] 先调用filter()获得所有偶数，再调用map()获得所有偶数平方和 5.7 some()，every() some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。传入的参数也是一个callback()函数，callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。其实一般只要发现时传入callback()函数，基本都是这些参数。123456789101112131415161718arr(5) [1, 3, 4, 10, 30, notNumber: \"not a number\"] 0: 1 1: 3 2: 4 3: 10 4: 30 notNumber: \"not a number\" length: 5 __proto__: Array(0)arr.some(function(value, index)&#123; return index &gt; 5&#125;)falsearr.some(function(value, index)&#123; return index &gt; 3&#125;)true some()方法的作用是只要数组中的某个元素满足传入的函数的要求就返回true。 every() 方法测试数组的所有元素是否都通过了指定函数的测试。12345var arr = [1, 2, 3, 4, 5];arr.every(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// false every()是要求数组的所有元素都满足传入的函数的要求才返回true。 注意：对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。12345678function isEven(x) &#123; return x % 2 === 0 &#125;undefined[].every(isEven)true[].some(isEven)false 对上面的结果，我又有什么办法呢，只能选择背过呗。这两个方法都不改变原数组 6. 上述数组的方法的使用总结数组的上述方法种类繁多，不过有几个特点很明显，一些方法会改变原数组，一些方法不会改变原数组，我以这个细节把上述方法分类如下 6.1 改变原数组的方法 方法名字 方法作用 push() 在元素末尾添加元素，返回添加新元素后的数组长度 pop() 删除数组末尾的元素，返回删除的那个元素。与push()方法一起模拟栈这个数据结构 shift() 删除数组的第一个元素，返回删除的那个元素。与push()方法结合，模拟队列这个数列这个数据结构 unshift() 在数组的起始位置添加新元素，返回添加新元素后的数组长度 reverse() 把数组的每一个元素的位置互换，返回翻转后的数组 splice() 根据方法传入的参数删除原数组的部分元素，返回被删除的元素。可以用来拆分数组 indexOf()，lastIndexOf() 返回括号里面 的元素第一次出现和最后一次出现的位置。NaN元素无法获得位置 sort() 默认按照数组元素的Unicode码点排序，可以自己传入函数，规定排序准则 6.2 不改变原数组的方法 方法名字 方法作用 join() 以某种形式把数组的所有元素以字符串的形式返回，默认以逗号分隔，返回生成的新数组 concat() 专业合并数组，把新数组添加到旧数组的后面，返回生成的新数组 slice() 根据方法传入的参数提取原数组的部分，返回提取的这个新数组。也可以用来把伪数组变成真数组 map() 必须传入一个callback()函数，数组的每一个元素执行这个函数，返回执行回调函数后的新数组。该方法会跳过空位 forEach() 必须传入一个callback()函数，数组的每一个元素执行这个函数。没有返回值，无法终止循环 filter() 必须传入一个callback()函数，数组的每一个元素执行这个函数，返回结果为true的成员组成一个新数组返回 reduce() 对数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。具体理解看例子吧 some() 只要数组中的某个元素满足传入的函数的要求就返回true every() 数组的所有元素都满足传入的函数的要求才返回true 正是因为以上的方法对原数组不造成影响，所以我们可以组合使用filter()、map()先过滤再匹配。 6.3 数组的遍历对于有序无序的数据，我们有时候会希望获得所有的key或者value，数组对这个需求尤甚。一般来说，数组的遍历有三种方法 for…in循环 12345678910var arr = [1, 3, 4, 10, 30]undefinedfor (var key in arr)&#123; console.log(arr[key])&#125;1341030 切忌把arr[key]手抖写成了arr.key。因为arr.key等同于arr[‘key’]，很明显数组没有这个名字叫key的键。for…in循环有个弊端就是它会把非数字的索引也打印出来 12345678910111213141516arr(5) [1, 3, 4, 10, 30]arr.notNumber = 'not a number'\"not a number\"arr(5) [1, 3, 4, 10, 30, notNumber: \"not a number\"]for (var key in arr)&#123; console.log(key + ':' + arr[key])&#125;0: 11: 32: 43: 104: 30notNumber: not a number 如果我们只关心数组的数字索引，用传统的下面的传统for循环 传统for循环12345678910arr(5) [1, 3, 4, 10, 30, notNumber: \"not a number\"]for (let i = 0; i &lt; arr.length; i++)&#123; console.log(i + ':' + arr[i])&#125;0:11:32:43:104:30 这种方法其实是我们人为规定了只遍历数字索引，O(∩_∩)O哈哈~ forEach(）循环12345678910arr(5) [1, 3, 4, 10, 30, notNumber: \"not a number\"]arr.forEach(function(value, index)&#123; console.log(index + ':' + value)&#125;)0:11:32:43:104:30 这种方法也不会遍历非数字的索引。","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"margin为负的理解","slug":"margin为负的理解","date":"2017-12-29T13:36:55.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/29/margin为负的理解/","link":"","permalink":"https://codevvvv9.github.io/2017/12/29/margin为负的理解/","excerpt":"引子 解决一个问题的关键在于马上着手去解决这个问题。我们都觉得CSS难学，那么就抓紧时间去学，去学，去学margin的概念margin是盒模型中一个很重要的概念，是border之外的区域，我们通常称作外边距，有margin-top,margin-right,margin-bottom.moargin-left四个外边距。注意我书写的顺序是从上开始顺时针的顺序。","text":"引子 解决一个问题的关键在于马上着手去解决这个问题。我们都觉得CSS难学，那么就抓紧时间去学，去学，去学margin的概念margin是盒模型中一个很重要的概念，是border之外的区域，我们通常称作外边距，有margin-top,margin-right,margin-bottom.moargin-left四个外边距。注意我书写的顺序是从上开始顺时针的顺序。 对于这四个值，我们在设置的时候必然只能有4种情况：一个值、两个值、三个值、四个值。 第一种：margin: 10px; 表示四个外边距全都是10px; 第二种：margin: 10px 5px 10px 5px; 表盘上按照从上开始顺时针转一圈，分别表示上外边距10px、右外边距5px、下外边距10px、左外边距5px; 第三种：margin: 10px 5px; 只有两个数字，上、右都有了，另外的两个去哪找呢。众所周知表盘是对称的，那么第一个数是上外边距和下外边距10px、右外边距和左外边距5px; 第四种：margin: 10px 5px 10px; 只有三个数，那么还是用对称来找，第二个右外边距依然对应左外边距，那么结果就显而易见了。上外边距10px、左外边距和右外边距5px、下外边距10px； 以上第二种是核心，方便理解其他的三种方式。同理，padding也是这个顺序。 上面这些必备知识，对于任何一个自学的前端，相信都会，没有任何新意。 接下来，我们探讨一下，以margin为例，它的值是负数的时候意味着什么呢？这是一个很有趣的实验，对于像我一样的新人来说，负值这个概念还是挺奇怪的，我是理解了好一会才搞明白的。先上栗子以margin的margin-left为例来演示，看官们也可以管中窥豹。 1234&lt;!-- HTML的核心代码--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;测试margin为负值的情况&lt;/div&gt;&lt;/div&gt; demo很简单，就是一个大div包裹了一个小div。由简单入手，正是删繁就简三秋树，领异标新二月花。下面是CSS的代码 123456789101112131415html&#123; border: 1px solid green;&#125;body&#123; outline: 1px solid orange;&#125;.container&#123; border: 1px solid red; margin-left:30px;&#125;.box1&#123; margin: 10px; outline: 1px solid blue; margin-left: -30px;&#125; 之所以把html以及body样式也加上，是因为我发现，要想把这个负值的概念理解的很透彻，经过我的多次实践，一定要采取这种自底向上的，完全展现整个过程的变化，才能说真的理解了这个概念。真正的原因如下 html的border让我们发现body的默认外边距是8px body的outline让我们直观的体会改变box1的margin-left的时候是如何变化的（我假设大家都知道改变左外边距会类名是container的div的border） 至于body box我没有用border，是因为这个border的宽度会影响图片的效果，进而影响理解。我是用了outline来替代border,它的作用和border一样，也是让我们知道我们要观察的元素的到底在网页的什么位置，人类还是以直观展现为主，太抽象不利于分析，不过他没有宽度，只要颜色。 实验的目的：改变margin-left的负值的大小，观察他的移动方向，而container的div的margin-left:30px;的设置正是确立边界，我通过对比margin-left的负值的大小与移动方向、移动距离来推论下面我们具体分析整个过程，以下面的图的变化来分析。通常科学的分析方法是找临界值，我采用的是去问题的的对立面来找线索，要分析负值，我们先看margin是正值的情况。 由正值变为 0 再变为负值不正是一个科学探索的过程吗 首先，要记得margin-left的第二次赋值会改变他的第一次值，也就是页面显示的永远是你最后赋的值。第一步 margin-left: 30px的情况如图所示，效果很直观。margin-left第二次赋值为30px,覆盖了它的初始值10px。图中绿色是html的border,橘黄色是body的outline,大div的border是红色，内部的box1outline是蓝色。第二步 margin-left: 30px变大的情况 对比上述两个图，很容易的发现：margin-left变大，content的宽度变小，理解为挤扁了 第三步 margin-left: 30px变小的情况对比二、三步的图发现，margin-left变小，content的宽度变大，理解为外扩了，当让了，此时还没分析完，我们不能很确定这个结论，继续变小，来分析。 这是一个伟大分界线，临界值 第四步 margin-left: 30px变小变为0了 又是一条伟大分界线，开辟了二次元 第五步 margin-left: 30px变小变为负值了 又是一条伟大分界线,与body的outline重合 第六步 margin-left: 30px变小变为-30px了 又是一条伟大分界线,都超出天际了，还能小 第七步 margin-left: 30px变小变为-60px了 至此，整个过程分析完毕，可以肯定一个结论了：margin-left变大，content的宽度变小，理解为挤扁了，margin-left变小，content的宽度变大，理解为外扩了 接下来我将继续探索margin-bottom为负的情况，因为这个会改变父元素的高度 以上就是我总结的结论。很喜欢张鑫旭老师的一段话，今天就以张老师的关于CSS学习瓶颈的一段话，来结束这篇文章。 理解的对错每个人的成长经历不同，大脑擅长处理的东西也不同，导致其看待与理解事物的方式也不同。因此，对于同一CSS表现的差异，每个人的理解都不同。一旦有所差异，就有所谓的“对错”之争。估计不少人会拿《CSS权威指南》上的东西说事：你那种理解是错误的，CSS权威指南上说……或W3C官方文档解释说……我大学电路老师最后一节课专门讲了她的科学观：何为科学？能够自圆其说，自成体系即是科学。中医算科学吗？算！因其有一套自己解释畅通的理论体系。同样，对于CSS的理解，我个人一直认为什么对错的争执等都是没有意义的。如果你的解释可以自圆其说，自成体系，且应用无误，哪怕你的解释与什么规范啊权威啊八竿子都打不着，别人压根理解不了，你都是对的，OK的！拘泥只会限制自身的创造力以及认知能力。火影的世界算是世界吗？是，自圆其说，自成体系！海贼王的世界算是世界吗？是自圆其说，自成体系。因此，如果你是设计出身，或文学出身的。什么复杂逻辑，深奥解释理解不了，你大可摒弃之，用你自己的世界去解释其表现，你的感性思维以及艺术情怀只会让这个世界变得更精彩！那些自以为是，抱残守缺的杂碎们就不用鸟他们，让他们随着时间消逝去吧~~","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"https://codevvvv9.github.io/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://codevvvv9.github.io/tags/CSS/"}]},{"title":"前端校验图片尺寸","slug":"前端校验图片尺寸","date":"2017-12-27T17:00:13.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/28/前端校验图片尺寸/","link":"","permalink":"https://codevvvv9.github.io/2017/12/28/前端校验图片尺寸/","excerpt":"这篇文章主要记录最近实习工作中遇到的前端检查图片尺寸的问题，在这个过程明白的一些道理。 我由于目前的水平有限，只能借助网络来完成这个功能。在这个查找的过程中，发现很多博客都写的有问题，虽然表面完成了，但是一测试，很多不对的地方，感觉都是抄的别人的，没抄完整。那么我希望我写的文章，读者都是可以完美复写的。 先上完美运行的代码以下是我亲测可以运行的代码。连我这种前端0.1年的人都能学会。","text":"这篇文章主要记录最近实习工作中遇到的前端检查图片尺寸的问题，在这个过程明白的一些道理。 我由于目前的水平有限，只能借助网络来完成这个功能。在这个查找的过程中，发现很多博客都写的有问题，虽然表面完成了，但是一测试，很多不对的地方，感觉都是抄的别人的，没抄完整。那么我希望我写的文章，读者都是可以完美复写的。 先上完美运行的代码以下是我亲测可以运行的代码。连我这种前端0.1年的人都能学会。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function setImg() &#123; var docObj = document.getElementById(&quot;imgPath&quot;); //获得上传的文件的数组形式 var files = document.getElementById(&quot;imgPath&quot;).value; console.log(docObj.files) console.log(files) if (docObj.files &amp;&amp; docObj.files[0]) &#123; var img = new Image(); img.onload = function()&#123; var width = img.width; //图片的宽 var height=img.height; //图片的高 var filesize = img console.log(width) console.log(height) console.log(filesize) if (width != 257 || height != 100)&#123; alert(&apos;图片尺寸不符合规范，请更新宽高比为257*100的图片&apos;); &#125; else&#123; //后续代码 &#125; if(docObj.files[0].size &gt; maxSize)&#123; alert(&apos;您上传的图片大小超过了50k，请更新符合规范的图片&apos;); &#125; &#125;; img.onerror=function()&#123; alert(&quot;error!&quot;); &#125;; img.src=window.URL.createObjectURL(docObj.files[0]); console.log(img.src); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;imgPath&quot; type=&quot;file&quot; onchange=&quot;setImg()&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 上述代码的image和file的操作在历经寻找多个不合适的博客之后终于成功了。 File API以及Image对象如果input的type=file，就可以选择文件从本地上传到网页。读取文件内容按照MDN操作files的方法如下所示 1.使用普通的类选择器选择要操作的input元素里面的文件var files = document.getElementById(‘imgpath’).files;要注意获得的是一个file的数组！！！ 如果只要一个文件，就可以用var file = files[0];获得file的所有信息。input元素后面写上multiple，就可以上传多个文件。同理多个文件的第一个文件也使用这个方法。 2.通过change事件来访问被选择的文件，即为onchange绑定一个函数只要用户选择了一个文件，那么就会传入这个file对象。 3.再创建一个image对象，一定要先onload。 4.给img赋上地址img.src=window.URL.createObjectURL(docObj.files[0]);","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"深挖JS语法第三集","slug":"深挖JS语法第三集","date":"2017-12-27T12:24:59.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/27/深挖JS语法第三集/","link":"","permalink":"https://codevvvv9.github.io/2017/12/27/深挖JS语法第三集/","excerpt":"","text":"这次的内容是研究JS里面的对象 在研究对象之前，我们先研究一下全局对象。 那么什么是全局对象呢？ECMAScript规定全局对象是global，但是浏览器有规定window是全局对象。 window就是一个hash表。 window的属性就是全局变量。 两种全局变量 第一种是ECMAScript规定的，常见的有如下几种 global.parseInt global.parseFloat global.Number global.String global.Boolean global.Obejct 第二种是浏览器规定的 window.alert window.prompt window.comfirm window.console.log window.console.dir window.document 要格外注意这是window的，是由W3C规定的。 window.document.createElement window.document.getElementById 先认识一下第一种的全局函数 Number 搞清楚var a = 1 和 var a = new Number(1)的区别是啥 123456var a = 1typeof a\"number\"var a = new Number(1)typeof a\"object\" 使用了Number全局函数了，就要画上节课的内存图，来分析 String ‘hello’ 与 new String(‘hello’) 的区别是什么 Boolean true 与 new Boolean(true) 的区别是什么 Object var o1 = {}和var o2 = new Object()的区别是什么 上面的区别都是简单类型和对象的区别，那到底有区别呢？ 上图就是以Number全局函数为例的具体调用过程，String() Boolean Object() 都是类似的过程 公有属性藏到哪里了呢通过上图我们发现，JS把一些大家都公有的东西抽离出来，放到一个单独的地方，谁想调用，就通过自己的一个proto的属性去调用，可以省的每个对象自己都存 toString() valueOf() 这种公共的方法。 在调用的过程中，自己的特有属性又放到自己的对应的公有属性里面。 由此形成了原型链。 一个伟大的等式 var 对象 = new 函数() 那么必然有 对象.proto === 函数.prototype 而函数.prototype又可以看做一个对象，那么 函数.prototype.proto === Function.prototype 而Function 也是对象啊，那么 又有 Function.proto === Function.prototype 而 Function.prototype又可以被看做对象，那么 Function.prototype.proto === Object.prototype 以上几个式子中要格外注意Function的那个式子，自己的proto又指向了自己的prototype 123456f.__proto__ === Function.prototypetruef.__proto__ === Object.prototypefalsef.__proto__.__proto__ === Object.prototypetrue 最有一点要强调的是Object.proto 是真的指向了null","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"CSS的五个奇怪特性","slug":"CSS的五个奇怪特性","date":"2017-12-24T14:08:36.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/24/CSS的五个奇怪特性/","link":"","permalink":"https://codevvvv9.github.io/2017/12/24/CSS的五个奇怪特性/","excerpt":"margin会受到border和display的影响以div元素为例三个并列的div，必然是上下排列，外边距是10px,也就是我们通常说的上下间隔10pxdemo123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .demo&#123; border: 1px solid red; height: 100px; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;!-- &lt;div class=&quot;demo2&quot; style=&quot;border: 0.1px solid green&quot;&gt;&lt;/div&gt; --&gt; &lt;div style=&quot;display: flex&quot; class=&quot;demo2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","text":"margin会受到border和display的影响以div元素为例三个并列的div，必然是上下排列，外边距是10px,也就是我们通常说的上下间隔10pxdemo123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .demo&#123; border: 1px solid red; height: 100px; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;!-- &lt;div class=&quot;demo2&quot; style=&quot;border: 0.1px solid green&quot;&gt;&lt;/div&gt; --&gt; &lt;div style=&quot;display: flex&quot; class=&quot;demo2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上是正常的效果图但是凡事总有例外一个boder就可以给你分开，像一条隐形的线分隔开了而且，你改变中间那个div的display即使没有border也可以分割 display: flex 可以分割对比的效果图如上 displa: table 可以分割 最令我震惊的是display: inline-block,间距是40px 以上特例要记住 li的样式受到display的影响ul标签的字标签li标签默认会有小圆点，但是一旦你想给li的display属性点更改，圆点就消失 上图是默认样式 你更改了display就完蛋了绝对定位会改变display的属性一旦你使用了position: relative position: absolute之后，即使你写了display: inline，但是浏览器计算出来的的仍然是block 以上是没绝对定位的时候你会发现绝对定位之后的display不是你规定的inline.inline-block 和 inline都会被改成blocktransform会对fixed的元素影响正常来说fixed的元素是相对于视口定位的，但是与transform结合后就不是这个现象了。CSS3规范说的是会整体缩放，所以要根据父元素定位。实例如下上图是正常的，无论你如何拖动滚动条都无所谓。但是float影响inline元素其实float属性不是真正的浮起来来了，而是希望做到文图环绕的效果。文字会环绕在浮动元素的周围。没有浮动的时候，通过这个图，你也会发现一个奇怪的现象，两个子元素的高度可以超过父元素的高度，而父元素不影响。下图是浮动后神奇的效果一般人的理解是你浮起来的，我是正常元素啊这几个字会出现到 一个浮动元素的下面，也就是它本体灰色框的左边，而实际上不是的，会感知到有个浮动元素，文字环绕在哪个浮动元素的旁边。 以上是目前碰到的比较奇怪的五个坑，CSS的坑继续探索中，加油！！！","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"https://codevvvv9.github.io/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://codevvvv9.github.io/tags/CSS/"}]},{"title":"深挖JavaScript第二集","slug":"深挖JavaScript语法第二集","date":"2017-12-23T10:15:26.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/23/深挖JavaScript语法第二集/","link":"","permalink":"https://codevvvv9.github.io/2017/12/23/深挖JavaScript语法第二集/","excerpt":"","text":"JS一定要抠细节，逻辑性。我们这次探讨 内存 的问题、一个IE的BUG以及深拷贝和浅拷贝，和typeof运算符的小技巧 在第一集里面知道了7个基本的数据类型number string boolean symbol null underdefined object那么这七个数据类型如何转换呢 其他数据类型转string String()函数 1234567891011121314String(0)&quot;0&quot;String(true)&quot;true&quot;String(false)&quot;false&quot;String(null)&quot;null&quot;String(undefined)&quot;undefined&quot;String(&#123;&#125;)&quot;[object Object]&quot;String(&#123;name: 9&#125;)&quot;[object Object]&quot; toString()属性注意null和undefined只是两个值，没有toString()属性 12345678null.toString()VM371:1 Uncaught TypeError: Cannot read property &apos;toString&apos; of null at &lt;anonymous&gt;:1:6(anonymous) @ VM371:1undefined.toString()VM400:1 Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined at &lt;anonymous&gt;:1:11(anonymous) @ VM400:1 还有一个要注意的 1234&#123;&#125;.toString()VM91:1 Uncaught SyntaxError: Unexpected token .(&#123;&#125;).toString()&quot;[object Object]&quot; 其他的都可以123456789var a = 8;a.toString()&quot;8&quot;var a = truea.toString()&quot;true&quot;var a = &#123;&#125;a.toString()&quot;[object Object]&quot; 最常见的方法 ‘ ‘+无敌的方法 12345678&apos;&apos; +1&quot;1&quot;&apos;&apos;+ true&quot;true&quot;&apos;&apos;+ null&quot;null&quot;&apos;&apos;+ undefined&quot;undefined&quot; 其它数据类型转number Number()函数 123456789101112Number(&apos;fff&apos;)NaNNumber(&apos;30&apos;)30Number(null) //注意是00Number(undefined) //注意是NaNNaNNumber(true)1Number(false)0 parseInt()和parseFloat()属性parseInt()有个大坑，是从左边第一个字符开始看，不是数字，就停下了，而不是我理解 的有几个数字就打印几个数字 12345678910111213141516parseInt(&apos;122&apos;) //默认是十进制122parseInt(&apos;011&apos;)11parseInt(&apos;011&apos;, 2) //规定是二进制3parseInt(&apos;123&apos;, 10)123parseInt(&apos;011&apos;, 8) //规定是八进制9parseInt(&apos;A09&apos;) //发现第一个字符就不是数字，不往后面判断了NaNparseInt(&apos;09A12&apos;)9parseFloat(&apos;11.4&apos;)11.4 没见过的操作 其他数据类型-0 12345678910111213141516null-00undefined-0NaN&apos;91&apos; - 091&apos;91.09&apos; - 091.09&apos;str&apos; - 0NaNvar a = &#123;&#125;a-0NaNvar a = &apos;123&apos;a-0123 又是一个没见过的操作 + &#39;&#39; 123456789101112+&apos;124&apos;124+&apos;12.4&apos;12.4+false0+true1+null0+undefinedNaN 其它数据类型转成boolean注意5个特殊的falsey值，当然了false必然也是falsey值 0NaN‘ ‘ 这是空字符串，啥也没有，空格也没有nullundefined 除了以上6个falsey值，其他的都是true Boolean()函数 1234567891011121314151617181920Boolean(&apos;&apos;)falseBoolean(&apos; &apos;)trueBoolean(0)falseBoolean(NaN)falseBoolean(null)falseBoolean(undefined)falseBoolean([])trueBoolean(&#123;&#125;)trueBoolean(9)trueBoolean(&apos;pp&apos;)true !!的操作怎么理解呢，一个!是取反的操作，再加一个就是双重取反，就是我们想要的结果了 1234!0true!1false 123456789101112131415161718!!0false!!NaNfalse!!&apos;&apos;false!!nullfalse!!undefinedfalse!!1true!!&apos;pp&apos;true!![]true!!&#123;&#125;true 四个经典的内存题 粗糙的内存图的引入var a = 1 和var a = new Number(1)分别发生了什么简单数据类型存在stack中，存储位置是连续的，像弹匣一样，与数据结构中的栈一样，先进后出(FILO)，而复杂数据类型存储在heap中，存储位置不连续，与数据结构中的堆一样，是树状的发散结构，这一点超级重要啊。时时刻刻要记着数据结构啊。 第一个题 简单数据类型的判断 a=? 123456var a = 1b = ab = 2a1 答案是a=1 第二个题 复杂数据类型 的判断 a =?123456var a = &#123;name: &apos;wushao&apos;&#125;b =ab=&#123;name: &apos;shao&apos;&#125;a&#123;name: &quot;wushao&quot;&#125; 答案是a={name: ‘wushao’}，结果不变 第三个题 复杂数据类型 的判断 a.name=? 123456var a = &#123;name: &apos;wushao&apos;&#125;b =ab.name = &apos;qwert&apos;a.name&quot;qwert&quot; 答案是a.name = ‘qwert’,已经被b.name改变了 第四个题 复杂数据类型 的判断 a=? 123456var a = &#123;name: &apos;a&apos;&#125;var b = ab = nulla&#123;name: &quot;a&quot;&#125; 答案是 a = {name: “a”} 不受b的影响 如图所示 一个很贱的面试题123456var a = &#123;n: 1&#125;var b = aa.x = a = &#123;n: 2&#125;alert(a.x) //是啥呢 undefinedalert(b.x) //是啥呢 [object Object] 大坑之处在于那个a.x一开始浏览器先从左边看的 IE6 的关于垃圾回收机制的一个BUG有以下情形 1234var fn = function( )&#123; &#125;document.body.onclick = fnfn = null问你 function()&#123;&#125;是不是垃圾 第一种情况，你没有关闭这个tab页那么function不是垃圾 第二种情况，我关闭了这个tab页,那么function就是垃圾了 IE6的BUG在于，你关闭了网页，但是蓝色圆里面的他不认为是垃圾，除非你关闭浏览器。所以你要在网页关闭的时候手动加上一个1234//onunload不加载，就是关闭了嘛window.onunload = function()&#123; document.body.onclick = null; //所有的都要有&#125; 由以上几个题引出深拷贝和浅拷贝 的问题深拷贝是你改变了，原来的不受改变的影响，而浅拷贝会改变原来的属性。对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。 右边蓝色框才是一个完整的复制 typeof运算符的坑 JavaScript有三种方法，可以确定一个值到底是什么类型。typeof 运算符instanceof 运算符Object.prototype.toString方法 typeof运算符可以判断你要的值得数据类型，有如下结果先看大坑 1234567typeof null&quot;object&quot;typeof Function&quot;function&quot;function f()&#123;&#125;typeof f&quot;function&quot; 函数竟然是function类型的数据，坑爹啊。null竟然是object，尼玛，吓坏了，一查原来是历史遗留问题。 1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，object对应的值是000。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），完全没考虑null，只把它当作object的一种特殊值，32位全部为0。这是typeof null返回object的根本原因。为了兼容以前的代码，后来就没法修改了。这并不是说null就属于对象，本质上null是一个类似于undefined的特殊值。 你只需要记住，null不是对象 ！null不是对象！ null不是对象！就是一个值null。其他的类型是符合预期的 12345678910typeof 123&quot;number&quot;typeof &apos;123&apos;&quot;string&quot;typeof true&quot;boolean&quot;typeof []&quot;object&quot;typeof &#123;&#125;&quot;object&quot; 一个小技巧1234typeof undefined&quot;undefined&quot;typeof a&quot;undefined&quot; 上面的a未声明,直接使用会报错 123aVM412:1 Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:1:1 但是用了typeof就可以啦可以用来判断某个变量是否声明了 123if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 第二个小技巧既然typeof对数组（array）和对象（object）的显示结果都是object，那么怎么区分它们呢？instanceof运算符可以做到。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"深挖JS语法第一集","slug":"深挖JS语法第一集","date":"2017-12-23T10:15:26.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/23/深挖JS语法第一集/","link":"","permalink":"https://codevvvv9.github.io/2017/12/23/深挖JS语法第一集/","excerpt":"从今天开始用重新认识JS，毕竟前端是靠JS吃饭的，开始深挖一下细节，在这个过程中也反思了一下，为啥java没学好。果然是基础不牢，地动山摇啊，古人诚不欺我也！ 1. JS的数据类型有哪几种？以前一直说会JS,却连这个问题没好好搞过，给自己两耳光…… 数据类型 名称 1. 基本数据类型(也叫简单数据类型) number string boolean symbol undefined null 2. 复杂数据类型 object 注意，array和function属于object类型;symbol是ES6的内容。","text":"从今天开始用重新认识JS，毕竟前端是靠JS吃饭的，开始深挖一下细节，在这个过程中也反思了一下，为啥java没学好。果然是基础不牢，地动山摇啊，古人诚不欺我也！ 1. JS的数据类型有哪几种？以前一直说会JS,却连这个问题没好好搞过，给自己两耳光…… 数据类型 名称 1. 基本数据类型(也叫简单数据类型) number string boolean symbol undefined null 2. 复杂数据类型 object 注意，array和function属于object类型;symbol是ES6的内容。 2. 几个大坑 长字符串里面的大坑长字符串可以用+连接符，优雅易懂。但是还可以这么写 12345var longStr = &apos;agggggg\\bgggggg\\cgggggg\\d&apos;//结果依然是aggggggbggggggcggggggd 上述代码不报错的前提是\\后面不能有除了换行符以外的任何字符，即使一个空格就报错 字符串的length属性和字符集 字符串的length属性是不可更改的,你爱写啥写啥，length属性不变。 java的8个基本数据类型：byte short int long float double char booleanjava里面的判断长度的方法只有三个 字符串的length属性 数组的length()方法 集合类的size()方法 字符串的字符集 由于JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符，导致所有字符串处理函数遇到这类字符，都会产生错误的结果（详见《标准库》一章的String对象章节）。如果要完成字符串相关操作，就必须判断字符是否落在0xD800到0xDFFF这个区间。替换（String.prototype.replace）、截取子字符串（String.prototype.substring, String.prototype.slice）等其他字符串操作，都必须做类似的处理。 代码如下1234567891011121314151617181920212223function getSymbols(string) &#123; var length = string.length; var index = -1; var output = []; var character; var charCode; while (++index &lt; length) &#123; character = string.charAt(index); charCode = character.charCodeAt(0); if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125; &#125; return output;&#125;var symbols = getSymbols(&apos;𝌆&apos;);symbols.forEach(function(symbol) &#123; // ...&#125;); JavaScript原生提供两个Base64相关方法。 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节可表示4个可打印字符。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。 两个方法btoa()：字符串或二进制值转为Base64编码atob()：Base64编码转为原来的编码123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 这两个方法不适合非ASCII码的字符，会报错。 123btoa(&apos;你好&apos;)VM1195:1 Uncaught DOMException: Failed to execute &apos;btoa&apos; on &apos;Window&apos;: The string to be encoded contains characters outside of the Latin1 range. at &lt;anonymous&gt;:1:1 要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; undefined和null的区别？这是一个历史遗留问题。JS之父在Twitter上的话，需要FQ才能看我们应该如何区分呢 两个角度来看待 原因 1. 语法规范 变量没有值，就是undefined。事实上，你在console上随便写一个语句，都是undefined 2. 习惯上理解 如果有一个对象，你声明了，但是此时不给他赋值，让他等于null;如果你有一个非对象的变量，你此时不想赋值，就让他等于undefined。 var obj = null,别人一眼就能看出你是想声明一个对象,不过此时不想赋值；var a = undefinded，别人一眼就能看出你是想声明一个非对象，此时不想赋值 对象的key的问题对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。你用for…in的时候那个顺序的随机的大坑来啦……如下代码123456var obj = &#123; &apos;name&apos;: &apos;wushao&apos;, &apos;age&apos;: 8&#125;for (var key in obj)&#123; console.log(obj.key)&#125; 你是想打印出’wushao’和8来，结果屁都没有。 注意 [ ]运算符里面必须是字符串，而且是对象的键。这个例子中，key才是字符串，而且是obj的key;你obj.key相当于obj[‘key’]，obj没有这个叫key的键。对象的基本结构式{key: value}key必须是字符串，valu是那7种 的任意一个。 1234var obj = &#123; &apos; &apos;: &apos;frank&apos; 没问题&#125; 关于key加不加引号的问题。你保证你的key符合标识符规范，可以不加，但是有个默认的引号在上面。如果不符合标识符规范的，必须加引号同理，obj[ ]括号里面不符合标识符规范的，必须加引号。 1234var person = &#123; &apos;09a&apos;: &apos;我不符合标识符规范,key必须加引号保护，否则就报错&apos;, name: &apos;我符合标识符规范,引号加不加都可以，反正key一定是个字符串&apos;&#125; -还有啊，对象的每个key-value的结束，一定记得加逗号啊！！！！，能多写不能少写，最新的ES6可以都写逗号，不报错 总之，记住一个公式 obj.name 等同于 obj.[‘name’]","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"Form表单的两个新属性","slug":"Form表单的两个新属性","date":"2017-12-21T15:07:09.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/21/Form表单的两个新属性/","link":"","permalink":"https://codevvvv9.github.io/2017/12/21/Form表单的两个新属性/","excerpt":"引子今天在实习工作中看到了两个新属性，其实一直就在，但是一直眼瞎，没去MDN去搜搜，今天搜了一下。明白了这俩属性。在这个表单里面的两个以前没见的属性 12345&lt;form name=&quot;upFileForm&quot; method=&quot;post&quot; action=&quot;/cgi-bin/action&quot; onsubmit=&quot;return isUploadLogo();&quot; target=&quot;returnMsg&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;uploadfile&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;uploadLogo&quot; name=&quot;TAGET_FILENAME&quot; value=&quot;logo.gif&quot; /&gt; &lt;input type=&quot;submit&quot; id=&quot;immUpdate&quot; class=&quot;newButtonStyle&quot; name=&quot;uploadLogo&quot; value=&quot;立即更新&quot; /&gt;&lt;/form&gt;","text":"引子今天在实习工作中看到了两个新属性，其实一直就在，但是一直眼瞎，没去MDN去搜搜，今天搜了一下。明白了这俩属性。在这个表单里面的两个以前没见的属性 12345&lt;form name=&quot;upFileForm&quot; method=&quot;post&quot; action=&quot;/cgi-bin/action&quot; onsubmit=&quot;return isUploadLogo();&quot; target=&quot;returnMsg&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;uploadfile&quot; /&gt; &lt;input type=&quot;file&quot; id=&quot;uploadLogo&quot; name=&quot;TAGET_FILENAME&quot; value=&quot;logo.gif&quot; /&gt; &lt;input type=&quot;submit&quot; id=&quot;immUpdate&quot; class=&quot;newButtonStyle&quot; name=&quot;uploadLogo&quot; value=&quot;立即更新&quot; /&gt;&lt;/form&gt; enctype属性 当 method属性值为 post 时, enctype 是提交form给服务器的内容的 MIME 类型，可能的取值有: application/x-www-form-urlencoded: 如果属性未指定时的默认值。 multipart/form-data: 这个值用于一个 type 属性设置为 “file” 的 &lt;input&gt; 元素。text/plain (HTML5)这个值可以被 &lt;button&gt;或者 &lt;input&gt; 元素中的 formenctype属性重载（覆盖）。 MDN写的真是好啊我这个例子中就是设置的是multipart/form-data ,对应的第二个input target 属性 target一个名字或者说关键字，用来指示在提交表单之后，在哪里显示收到的回复。在 HTML 4 里, 这是一个用于 frame 的名字/关键字. 在 HTML5 里, 这是一个用于 browsing context 浏览器上下文 的名字/关键字 (举例来说, 标签页tab, 窗口window, or 或者行内 frame). 如下的关键字含有特别的含义: _self: 在当前HTML4或HTML5文档页面重新加载返回值。这个是默认值。译注：也就是说如果这个文档在一个frame中的话，self是在当前frame（document）中重新加载的，而不是整个页面（window）。 _blank: 以新的HTML4或HTML5文档窗口加载返回值。 _parent: 在父级的frame中以HTML4或HTML5文档形式加载返回值，如果没有父级的frame，行为和_self一致。 _top: 如果是HTML 4文档: 清空当前文档，加载返回内容；HTML5: 在当前文档的最高级内加载返回值，如果没有父级，和_self的行为一致。 iframename: 返回值在指定frame中加载。HTML5: 这个值可以被 &lt;button&gt;或者 &lt;input&gt; 元素中的formtarget属性重载（覆盖）。 不过有疑问的是这里写的是returnMsg是啥意思呢？","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"https://codevvvv9.github.io/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://codevvvv9.github.io/tags/HTML/"}]},{"title":"Form表单不能嵌套的大坑","slug":"Form表单不能嵌套的大坑","date":"2017-12-20T12:28:50.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/20/Form表单不能嵌套的大坑/","link":"","permalink":"https://codevvvv9.github.io/2017/12/20/Form表单不能嵌套的大坑/","excerpt":"","text":"07年就有很多人问的大坑，我今天遇到啦 StackOverflow上07年的这个问题就很火 Form表单不可以嵌套 sf 上都给出了w3c的form标准 国内的CSDN也给出了可行的解决方案1 解决方案2","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"https://codevvvv9.github.io/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://codevvvv9.github.io/tags/HTML/"}]},{"title":"阮一峰JS入门的强制转换部分","slug":"阮一峰JS入门的强制转换部分","date":"2017-12-20T12:24:59.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/20/阮一峰JS入门的强制转换部分/","link":"","permalink":"https://codevvvv9.github.io/2017/12/20/阮一峰JS入门的强制转换部分/","excerpt":"神奇的传送门 书籍 1. 简介、基本语法基本没啥问题，和以前的认知相同2. 强制转换 知识主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。 2.1 Number()函数例如 12345678910111213//数值还是数值Number(42)//42//字符串 能全转 才能全转Number(&apos;42&apos;) //42//空字符串转为0Number(&apos; &apos;)//0// 布尔值：true 转成1，false 转成0Number(&apos; true&apos;)//1Number(&apos; false&apos;)//0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number()很严格，比parseInt()严格。","text":"神奇的传送门 书籍 1. 简介、基本语法基本没啥问题，和以前的认知相同2. 强制转换 知识主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。 2.1 Number()函数例如 12345678910111213//数值还是数值Number(42)//42//字符串 能全转 才能全转Number(&apos;42&apos;) //42//空字符串转为0Number(&apos; &apos;)//0// 布尔值：true 转成1，false 转成0Number(&apos; true&apos;)//1Number(&apos; false&apos;)//0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number()很严格，比parseInt()严格。12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 只要有一个不能转的字符就是NaN Number函数会自动过滤一个字符串前导和后缀的空格。 1Number(&apos;\\t\\v\\r12.34\\n&apos;) // 12.34 分割线强力来袭 ~~~ 强调一下对象的转换规则简单的规则是 ***简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。举例: 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 接下来了解一下Number()背后的原理。哇擦嘞,以前真是不注意这些东西，菜鸡一枚啊。 1、调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步 骤。2、如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。3、如果toString方法返回的是对象，就报错。 原理不好理解，上栗子 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125; 上面的代码意思是：Number函数接收到了obj，先调用obj.valueOf()方法，判断是不是object,结果返回对象自身，于是，继续调用obj.toString方法，这时返回字符串[object Object]，对这个字符串使用Number函数，必然得到NaN 默认情况下，对象的valueOf()方法总是会返回对象自身，所以一般会调用对象的toString()方法，如果toString()方法，返回对象的类型字符串（比如[object Object]），那么Number()，结果就是NaN； 1Number(&#123;&#125;) // NaN 如果toString()方法返回不是原始类型的值，就报错(这句话的另一层意思也就是toString()方法被重写了啊) 依然上栗子obj对象重写了两个方法，注意 toString()方法返回的又是一个对象报的错 TypeError: Cannot convert object to primitive value1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;Number(obj)// TypeError: Cannot convert object to primitive value 2.2 String()函数使用String函数，可以将任意类型的值转化成字符串。转换规则如下。 原始数据类型转换 数值：转为相应的字符串。字符串：转换后还是原来的值。布尔值：true转为”true”，false转为”false”。undefined：转为”undefined”。null：转为”null”。 12345String(123) // &quot;123&quot;String(&apos;abc&apos;) // &quot;abc&quot;String(true) // &quot;true&quot;String(undefined) // &quot;undefined&quot;String(null) // &quot;null&quot; 对象的转换String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; 背后的原理基本与Number()相同，只是方法的调用相反 1、先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 2、 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 3、如果valueOf方法返回的是对象，就报错。 1234567String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。12345678910111213var obj = &#123; valueOf: function () &#123; console.log(&apos;valueOf&apos;); return &#123;&#125;; &#125;, toString: function () &#123; console.log(&apos;toString&apos;); return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 2.3 Boolean()除了以下六个值的转换结果为false，其他的值全部为true。 undefinednull-00或+0NaN‘ ‘（空字符串） 12345Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&apos;&apos;) // false 注意一下注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。 123Boolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true","categories":[{"name":"JS语法详解","slug":"JS语法详解","permalink":"https://codevvvv9.github.io/categories/JS语法详解/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://codevvvv9.github.io/tags/JavaScript/"}]},{"title":"打开CSS世界的大门","slug":"打开CSS世界的大门","date":"2017-12-16T14:15:35.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/16/打开CSS世界的大门/","link":"","permalink":"https://codevvvv9.github.io/2017/12/16/打开CSS世界的大门/","excerpt":"这只是一篇让我重新认识CSS的文章，写这篇文章的时候还未搞明白原理，只知其然，不知其所以然。我的这篇文章的小demo让我信心倍增。 一、CSS(Cascading Style Sheets)是个啥？惯例是先了解了解历史，请点击这俩链接。 中文百科 英文百科 CSS从2.1流行，现在主流的是CSS 3，还有更简练、功能更强的LESS、SASS好了，历史了解完了，你肯定还是啥也不会，因为我曾经学了都还是啥也不会。所以 这个系列的原则就是 先做出来，做多了，有感觉了才有资格喷人 学习资源 CSS-Tricks 你就模仿吧，全是你想不到的 Codrops 我长这么大，可能这是第一次知道原来能把网页显示的这么漂亮，难道你不心动吗？你可以看模拟选座，各种进度条的显示 张鑫旭 是真的牛 阮一峰，你就看吧","text":"这只是一篇让我重新认识CSS的文章，写这篇文章的时候还未搞明白原理，只知其然，不知其所以然。我的这篇文章的小demo让我信心倍增。 一、CSS(Cascading Style Sheets)是个啥？惯例是先了解了解历史，请点击这俩链接。 中文百科 英文百科 CSS从2.1流行，现在主流的是CSS 3，还有更简练、功能更强的LESS、SASS好了，历史了解完了，你肯定还是啥也不会，因为我曾经学了都还是啥也不会。所以 这个系列的原则就是 先做出来，做多了，有感觉了才有资格喷人 学习资源 CSS-Tricks 你就模仿吧，全是你想不到的 Codrops 我长这么大，可能这是第一次知道原来能把网页显示的这么漂亮，难道你不心动吗？你可以看模拟选座，各种进度条的显示 张鑫旭 是真的牛 阮一峰，你就看吧 二、实战 各种工具 名称 作用 取色器 你猜这能是干啥的 QQ截图功能 既可以量尺错也可以取色，取色后按住 ctrl 可以看到16进制的色 word 查看字体 查看页面字体和图片的方式 还是使用开发者工具的Network 来看image和font CSS引用的四种方式 名字 代码 style 标签 在head里面写上&lt;style&gt; &lt;/style&gt; 标签里面就可以写css代码了 在每个标签的style属性里面直接写 &lt;div style=&quot;&quot;&gt; &lt;/div&gt; 外部引入 在head里面写上 &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css &quot;&gt; css import 在你的css文件开头写上@import url(./b.css) 第一次见脱离文档流1234567.topNavBar&#123; padding: 15px 0px 15px 0px; position: fixed; top: 0; left: 0; width: 100%;&#125; padding: 15px 16px 15px 16px这串代码等同于下列代码1234padding-top: 15px;padding-bottom: 15px;padding-left: 16px;padding-right: 16px; 顺序是从上开始顺时针取值，上 右 下 左position: fixed; 这是核心代码，让你的topNavBar导航栏固定在顶部，而且不占body的高度。 如何做横向布局呢？原则 在子类元素的CSS规定 float:left,父类元素必须有一个class=”clearfix”下面是经典的消除横向布局的bug的代码，要记住。12345.clearfix::after&#123; content: &apos;&apos;; display: block; clear: both;&#125; 用一个计算题来验证一下，topNavBar真的脱离了文档流 先看未脱离文档流的时候topNavBar的原始尺寸高度是69.59，图片里面的计算写错了没脱离文档流的时候body的高度是1325.09那么脱离之后，body的高度必然是1325.09-69.59=1255.5接下来就是见证奇迹的时刻果然是1255.5,脱离成功！！！ 此时也应该明白文档流的含义了，块级元素display: block(一下占一行，后面有空也不给你用)从上到下流动，内联元素display: inline（不换行，占满为止）从左往右流动。 块级元素示例 内联元素示例 注意英文单词一个大整体，打断的话修改word-block属性 请各部门注意：插播一条内联元素的特点呢 内联元素无法规定宽和高 margin的上右下左可以设置不信你看图，有图有真相，还附带链接 而且还会有空格的影响 12&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 1、2之间必然出现空格的。直观点我们可以看图 明白了文档流（其实还是不明白，后续要继续研究），那么高度是由什么决定的，也差不多了是由其内部的文档流的高度总和决定的。比如div没有内容，那么高度为零。后期要深入了解 合并的一些知识，目前没搞懂 ？？？？ 在这也明白了，display可以改变内联还是块级，比如把span的display改为block他就是div了。 盒模型内部是element,外面是padding、border，这是通常F12检查元素的尺寸的来源。再往外就是margin。目前就了解这些。 a标签的默认样式如果你不继承的的话，默认会有一个蓝色带下划线的模样，那是浏览器默认的。text-decoration属性可以去掉他的下划线。color属性是可以继承的1234a&#123; color: inherit; text-decoration: none;&#125; 注意：小技巧有时候如果我们发现a标签包裹不了内部的元素可以采用以下方法 1display: inline-block; line-height很难，看了专栏，也没懂，大约知道，字体有个基线baseline，上部下部还有高度，所以给字体有个建议行高。默认值是normal,值浏览器规定约为1.2,但是还根据font-family。那么我们就认为你说line-height默认值是1.2错了。line-height 的值是多少像素，那么 span 所占的高度就是多少 先记住吧。举个例子 我需要一个 div 高度为 30px，div 里有一行字垂直居中，字的大小为 14px，应该怎么写 CSS?答案：两种写法。12345div &#123; font-size: 14px; line-height: 20px; padding: 5px 0px;&#125; 1234div &#123; font-size: 14px; line-height: 30px;&#125; CSS position的探讨MDN的解释是 CSS属性position用于指定一个元素在文档中的定位方式。top right bottom left属性则决定了该元素的最终位置。默认值是static 1、可以取那些值static relative absolute fixed sticky由此引出 脱离文档流第二种方法12position: relative;//父级元素加上这句position: absolute;//子类加上这句话 例子如下 relative和absolute的例子 12345678910&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;d&quot;&gt; &lt;div class=&quot;e&quot;&gt; &lt;div class=&quot;f&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.a,.d&#123; width: 200px; height: 200px; background: red; padding:20px;&#125;.b,.e&#123; width: 150px; height: 150px; background: yellow;&#125;.c,.f&#123; width: 100px; height: 100px; background: green; position: absolute; left: 15px;&#125;.a,.e&#123; position: relative;&#125; 相互对应，而没有对应错是因为，被不同的大div包裹住了。 width height属性指明了最内部的内容区的宽、高。width的默认值是auto具体理解看图max-width会覆盖width的值，mix-width又会覆盖max-width的值，初始值是none。max-width用以限制width的最大宽度。 box-sizing元素的作用 两种盒子模型 作用 传统的盒子模型content-box 详见下面的解释 新型的盒子模型border-box 详见下面的解释 box-sizing属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。 原始的盒子模型content-box存在弊端，当你规定了width height之后，浏览器显示的宽度是你写的width+padding &times; 2+border&times;2的宽度，已经不是你想要的宽度，如果你想显示的就是你想要的宽度，你就要在你的想要的宽度上减去（padding&times;2 + boder&times;2）的宽度，这个值才是你要规定的width。很麻烦吧。你如果上面的分析没看懂，就看这个 比如. 如果 .box {width: 350px}; 而且 {border: 10px solid black;} 那么在浏览器中的渲染的实际宽度将是370px; border-box告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。 用CSS画个三角形出来画各种shape的好去处 CSS-Tricks shapes ，可以画出一个太极图 其实还是理解的盒子模型，灵活运用boder有用的代码如下 12345678910111213141516171819.span&#123; display: block; width: 0px; height: 0px; border: 30px solid red; /* border-top-color: blue; */ border-right-color: transparent; border-bottom-color: transparent; border-left-color: black; border-top-width: 0px; &#125;//到最后，其实就是这么几句话 display: block; width: 0px; height: 0px; border: 30px solid transpatent; border-left-color: black; border-top-width: 0px; 在这个过程中发现两点好玩的 width: 0px和不写是完全不同的，我总被习惯所误导，详见下图1、你要是width: 0px height: 0px，是下面这样式的，是正确的~2、但是你要是不写的话，这世界立马就变了 border-top-width的真实含义，对比图可以知道border-top-width具体是哪块了综上所述，CSS不能按照惯性思维去随手就写，不能想当然啊。 图标的引用 阿里SVG矢量图库1、先把图标添加到购物车里面，再添加到项目里面然后按照下面的图片来操作 1&lt;script src=&quot;//at.alicdn.com/t/font_511143_hb7eteggodj6pqfr.js&quot;&gt;&lt;/script&gt; 2、再打开使用帮助 12345&lt;a href=&quot;#&quot;&gt; &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-github&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/a&gt; svg的不同属性注意一下 fill颜色属性 123456.userCard svg &#123; width: 30px; height: 30px; fill: white; vertical-align: top;&#125; CSS还没有深入，但是有句话我觉得该记下来，要对CSS保持一颗敬畏的心~ 加油 ~~ 骚年 ~~","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"https://codevvvv9.github.io/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://codevvvv9.github.io/tags/CSS/"}]},{"title":"HTML重点学习","slug":"HTML重点学习","date":"2017-12-14T14:20:46.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/14/HTML重点学习/","link":"","permalink":"https://codevvvv9.github.io/2017/12/14/HTML重点学习/","excerpt":"通过重点标签的学习前进 一、 iframe 的学习iframe通俗的的理解就是，可以在页面里面嵌套新的页面它的使用会使页面变卡，一般会有一个固定的尺寸，默认的。他也属于可替换元素行列。我们可以通过CSS来改变尺寸frameborder消除边框name属性与a标签结合 &lt;!-- &lt;iframe name=iframe src=&quot;http://qq.com&quot; &gt;&lt;/iframe&gt; --&gt; &lt;iframe name=&quot;000&quot; src=&quot;&quot; &gt;&lt;/iframe&gt; &lt;a target=&quot;000&quot; href=&quot;http://qq.com&quot;&gt;aaaa&lt;/a&gt; a标签的链接会在iframe的内嵌窗口里面打开","text":"通过重点标签的学习前进 一、 iframe 的学习iframe通俗的的理解就是，可以在页面里面嵌套新的页面它的使用会使页面变卡，一般会有一个固定的尺寸，默认的。他也属于可替换元素行列。我们可以通过CSS来改变尺寸frameborder消除边框name属性与a标签结合 &lt;!-- &lt;iframe name=iframe src=&quot;http://qq.com&quot; &gt;&lt;/iframe&gt; --&gt; &lt;iframe name=&quot;000&quot; src=&quot;&quot; &gt;&lt;/iframe&gt; &lt;a target=&quot;000&quot; href=&quot;http://qq.com&quot;&gt;aaaa&lt;/a&gt; a标签的链接会在iframe的内嵌窗口里面打开 二、a标签的学习a标签四种常见的target 1234&lt;a href=&quot;http://qq.com&quot; target=&quot;_blank&quot;&gt;topQQ&lt;/a&gt; //在新的页面打开链接 &lt;a href=&quot;http://qq.com&quot; target=&quot;_self&quot;&gt;topQQ&lt;/a&gt; //在当前窗口打开链接 &lt;a href=&quot;http://qq.com&quot; target=&quot;_parent&quot;&gt;parentQQ&lt;/a&gt; //在父级 &lt;a href=&quot;http://qq.com&quot; target=&quot;_top&quot;&gt;topQQ&lt;/a&gt; // 在顶级 a标签可以设置download属性，使其不打开链接。而是下载当前页面的HTML。 也可以把你当前目录下的文件下载。 12&lt;a href=&quot;http://qq.com&quot; download&gt;下载&lt;/a&gt;&lt;a href=&quot;222/分配的ip地址.xls&quot; download&gt;下载文件&lt;/a&gt; a标签会自动添加当前页面的协议。例如以下例子，如果不写http协议，会根据当前页面的协议自动加上，如果当前页面是http协议（通过下面的http-server模拟），那么就打开qq.com，如果只是本地的HTML，那么协议时file协议，不会下载 1&lt;a href=&quot;//qq.com&quot; download&gt;下载&lt;/a&gt; 1&lt;a href=&quot;//qq.com&quot; download&gt;下载&lt;/a&gt; a标签会在地址栏后加上锚点，即#开始的那串字符串 1&lt;a href=&quot;#kkkk&quot; download&gt;下载文件&lt;/a&gt; a标签会在地址栏后加上?name=wushao 一定要记得a标签可以发起get请求1&lt;a href=&quot;?name=wushao&quot; download&gt;下载文件&lt;/a&gt; a标签可以使用伪协议，这是历史遗留问题，以前的前端想在a标签里面直接打开js代码。现在常用于一些奇葩需求。如果，你不想这个a标签，有任何动作，无法点击，就用伪协议。 12&lt;a href=&quot;javaScript:;&quot; target=&quot;_top&quot;&gt;topQQ&lt;/a&gt; //无法操作了&lt;a href=&quot;javaScript:alert(1);&quot; target=&quot;_top&quot;&gt;topQQ&lt;/a&gt; 反之如果你只是加锚点，那么会定位到开始位置。如果你href=&quot; &quot;，那么会刷新页面。综上所述，如果你对a标签什么也不想做，就用伪协议 小型服务器 npm i -g http-server它会安装在npm目录下，把bin目录添加到~/.bashrc脚本配置文件里面，在文件的最后一行加上 1export PATH=&quot;http-server的绝对路径:$PATH&quot; 配置好path之后，就可以直接使用了。在你想模拟http协议环境的时候，在那个目录下打开http-server就可以用了 三、form标签的学习form a 标签最大的区别就是form标签是post提交，虽然你可以修改成get,但是没有人蛋疼的这么做。 默认的get方法演示1234567&lt;form action=&quot;users&quot; &gt; 用户:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; --&gt; &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;button&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; 以上是智障的写法，下面是优雅的写法。 注意form必须要用一个type=submit的input不然无法提交数据！！！！123456&lt;form action=&quot;users&quot; method=&quot;post&quot;&gt; 用户:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;button&quot;&gt; &lt;/form&gt; 以前我们在请求里面只能看见前三个部分，有了form标签之后，终于能看到第四部分，form data啦 如果你的form表单里面没有一个type=submit的input,可以使用type=submit的button的标签,也可以使用提交 12345678&lt;form action=&quot;users&quot; &gt; 用户:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; --&gt; &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;button&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; //等价于 &lt;button &gt;提交&lt;/button&gt; &lt;/form&gt; form表单有且只有两个方法，你不规定method那么就是get,你就是智障；所以你规定method=”post”，你不智障；如果你写了这两种之外的方法，那么还是按照get方法提交，你是智障中的战斗机。 四、input button标签的学习 input button 标签的最大区别就是input标签是空标签。 input 标签的type有很多种而且input必须有name属性，因为你提交的数据要用，组成name=value。 12345&lt;input id=&quot;POST-name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; //普通文本&lt;input id=&quot;POST-name&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; //密码&lt;input id=&quot;POST-name&quot; type=&quot;submit&quot; value=&quot;提交&quot;&gt; //提交&lt;input id=&quot;POST-name&quot; type=&quot;checkbox&quot; name=&quot;name&quot;&gt; //复选框&lt;input id=&quot;POST-name&quot; type=&quot;radio&quot; name=&quot;name&quot;&gt; //单选框 复选框和单选框的小练习 12345678910111213&lt;form action=&quot;users&quot; method=&quot;post&quot;&gt; 用户:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; --&gt; &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;button&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;br&gt; &lt;input id=&quot;love&quot; type=&quot;checkbox&quot; name=&quot;loveme&quot;&gt; &lt;label for=&quot;love&quot;&gt;爱我 &lt;/label&gt; &lt;input id=&quot;eat&quot; type=&quot;checkbox&quot; name=&quot;loveme&quot;&gt; &lt;label for=&quot;eat&quot;&gt;馒头 &lt;/label&gt; &lt;input id=&quot;play&quot; type=&quot;checkbox&quot; name=&quot;loveme&quot; checked&gt; &lt;label for=&quot;play&quot;&gt;篮球 &lt;/label&gt; &lt;input id=&quot;apple&quot; type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot;&gt;&lt;label for=&quot;apple&quot;&gt;苹果 &lt;/label&gt; &lt;input id=&quot;orange&quot; type=&quot;radio&quot; name=&quot;name&quot;&gt;&lt;label for=&quot;orange&quot;&gt;橘子 &lt;/label&gt; &lt;/form&gt; checked=”checked” 与 直接书写 checked 一样的效果 注意以上的代码中，包含的 label标签，有时候我们为了人性化的需求，只要鼠标点中文字的一部分就算选中了，所以用 label标签的for属性与input的id属性关联。 1&lt;input id=&quot;play&quot; type=&quot;checkbox&quot; name=&quot;loveme&quot; checked&gt; &lt;label for=&quot;play&quot;&gt;篮球 &lt;/label&gt; 当然了，你身为一个老司机，应该这么写 1&lt;label &gt;&lt;input type=&quot;checkbox&quot; name=&quot;loveme&quot; checked&gt; 篮球 &lt;/label&gt; 省了两个属性，简洁优雅。button标签也有很多type 1234&lt;button name=&quot;button&quot; type=&quot;button&quot;&gt; Click me &lt;/button&gt; //仅表示按钮，没有任何作用.它可以有与元素事件相关的客户端脚本，当事件出现时可触发,与js结合使用&lt;button name=&quot;button&quot; type=&quot;submit&quot;&gt; Click me &lt;/button&gt;//此按钮提交表单数据给服务器 input 也可以实现滑动的效果 1&lt;input type=&quot;range&quot; name=&quot;&quot; value=&quot;&quot;&gt; 五、下拉框12345&lt;select&gt; &lt;option value=&quot;1&quot;&gt;湖人&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;凯尔特人人&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;马刺&lt;/option&gt; &lt;/select&gt; 凯尔特人人是默认勾选的 六、table标签的学习table在古代用来做布局，现在基本不用了。只有四个元素，thead、tbody、tfoot、colgroup。即使你不写tbody你也有这个标签，而且可以不止一个。thead里面有tr、th，tbody里面有tr、td，tfoot里面有tr、td，colgroup里面有col,用来控制列的宽度，基本不使用了。我现在维护的网页，用的table 布局，修改很麻烦 tr table row th table header td table data 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Header content 1&lt;/th&gt; &lt;th&gt;Header content 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Footer content 1&lt;/td&gt; &lt;td&gt;Footer content 2&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; //即使写在这里。浏览器也会把他放到底部去 &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Body content 1&lt;/td&gt; &lt;td&gt;Body content 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; //可以包含多个tbody noscript标签表示如果用户禁用了js,就显示该标签里面的内容 七、空元素就是里面不能有内容的标签 八、可替换标签 CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类 外观渲染独立于CSS的 外部对象。 典型的可替换元素有 &lt;img&gt; &lt;object&gt; &lt;video&gt; 和 表单元素，如&lt;textarea&gt; &lt;input&gt; 。 某些元素只在一些特殊情况下表现为可替换元素，例如&lt;audio&gt; 和 &lt;canvas&gt;上面是MDN的原话，反正我看的云里雾里。用图片解释一下吧。img标签的尺寸其实是由src决定的，但只是第三级的重要性，你可以用width修改，你也可以用CSS来修改。 九、全局属性十、display不止三种不仅仅有 none inline block inline-block 还有很多常见的display默认的是block的有divp 、form 和HTML5中的新元素： header 、 footer 、 section。我们不需要特别关心display的，因为这个主要由CSS修改","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"https://codevvvv9.github.io/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://codevvvv9.github.io/tags/HTML/"}]},{"title":"服务器雏形","slug":"服务器雏形","date":"2017-12-12T09:58:59.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/12/服务器雏形/","link":"","permalink":"https://codevvvv9.github.io/2017/12/12/服务器雏形/","excerpt":"我们都知道李爵士建立了第一个网页、第一个浏览器、第一个服务器。前面两个，我们都见过了，但是服务器我们目前没有亲自实现过，所以有必要了解一下，服务器的一些基础知识。 以下是手写服务器脚本的必备知识 HTTP是建立在TCP/IP的基础之上的 TCP是什么TCP 传输控制协议（Transmission Control Protocol）12345678面试必问的两道题1、TCP和UDP的区别TCP是可靠的、面向连接的，相对UDP速度慢，UDP是不可靠的，不是面向连接的，速度快。可靠是指你的请求成不成功都会有响应，成功了就告诉你ok,失败了也告诉你访问失败，面向连接是指每次必须发起一个请求，这端是浏览器，另一端是你要访问的地址TCP可以看成是把石子扔到水里，UDP是把石头扔进草垛里面2、TCP的三次握手是啥第一次 客户端问服务器，我能连接吗第二次 服务器回答说，我准备好了，可以连接啦第三次 客户端说，那我就真的连接喽 上述两个面试题可以仔细阅读这两篇文章 TCP与UDP的区别、TCP三次握手详解","text":"我们都知道李爵士建立了第一个网页、第一个浏览器、第一个服务器。前面两个，我们都见过了，但是服务器我们目前没有亲自实现过，所以有必要了解一下，服务器的一些基础知识。 以下是手写服务器脚本的必备知识 HTTP是建立在TCP/IP的基础之上的 TCP是什么TCP 传输控制协议（Transmission Control Protocol）12345678面试必问的两道题1、TCP和UDP的区别TCP是可靠的、面向连接的，相对UDP速度慢，UDP是不可靠的，不是面向连接的，速度快。可靠是指你的请求成不成功都会有响应，成功了就告诉你ok,失败了也告诉你访问失败，面向连接是指每次必须发起一个请求，这端是浏览器，另一端是你要访问的地址TCP可以看成是把石子扔到水里，UDP是把石头扔进草垛里面2、TCP的三次握手是啥第一次 客户端问服务器，我能连接吗第二次 服务器回答说，我准备好了，可以连接啦第三次 客户端说，那我就真的连接喽 上述两个面试题可以仔细阅读这两篇文章 TCP与UDP的区别、TCP三次握手详解 路由器的基础只要我们在互联网中，就要用到IP 网络协议（Internet Protocol）,IP有分为内网IP和外网IP,它们的分界线就是路由器。 内网之间可以自由沟通，外网之间自由沟通。但是内外网不能直接沟通，必须通过路由，路由是一夫当关万夫莫开，也叫网关。 当路由器连上电信的服务器，就会获得一个外网IP(14.17.32.211),当你重启的时候又会重新分配一个。所以大多数的公司，会买一个固定的。 好了，此时路由和外界可以联通了，那么如何和你联通呢。答案就是 内网 路由器会在你家里创建一个内网，内网中的设备使用内网 IP，一般来说这个 IP 的格式都是 192.168.xxx.xxx。路由器还会给自己优先分配一个好的内网IP(192.168.1.1)，你就有可能是192.168.1.2。 现在路由器有两个 IP，一个外网 IP（14.17.32.211）和一个内网 IP（192.168.1.1）具有双重间谍的作用。它是内外沟通的桥梁 除此之外，还有一个localhost127.0.0.1和0.0.0.0这两个很重要的IP可以在你的hosts文件里面修改localhost文件 端口和 ip、各种服务你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，还必须指定端口（Port）。端口就是一个编号，并不是物理设备。因为一个设备里面有很多功能，你不知道用哪个功能，所以要用端口来区分你要哪个服务。-两个问题1、我怎么知道使用哪个端口详见0-1023端口详解2、总共有多少个端口啊每个机器一共有 65535（2的16次方减1）个端口（这是协议规定的）。不过这些端口的使用由一些规定 1231、0 到 1023（2的10次方减1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。2、其他端口可以给普通用户使用3、如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。以后你们会经常遇到这个问题。 综上所述，要想访问一个地址，必须提供IP和端口号！！！IP通过DNS解析你的域名，给你。端口号必须给出问题来了我访问http://qq.com 时并没有提供端口号，为什么我依然可以访问 1因为浏览器给你加上了80端口 用node.js脚本搭建最简单的服务器 用server接收请求 2.用server发挥响应，完成网页的解析核心代码如下所示，可以模拟一个微型的服务器一定要注意，response.setHeader(‘ContentType’, ‘text/html;charset=utf-8’)这是告诉浏览器两件事，一是设置头文件，告诉浏览器响应的第四部分按照什么格式来响应，二是告诉浏览器字符编码采用utf-8,避免乱码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;)var port = process.argv[2]if(!port)&#123; console.log(&apos;请指定端口号好不啦？\\nnode server.js 8888 这样不会吗？&apos;) process.exit(1)&#125;var server = http.createServer(function(request, response)&#123; var parsedUrl = url.parse(request.url, true) var path = request.url var query = &apos;&apos; if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125; var pathNoQuery = parsedUrl.pathname var queryObject = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log(&apos;方方说：得到 HTTP 路径\\n&apos; + path) if (path == &apos;/style&apos;)&#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/css;charset=utf-8&apos;) response.write(&apos;body&#123;backgroun-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;) response.end() &#125;else if(path == &apos;/script&apos;)&#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript;charset=utf-8&apos;) response.write(&apos;alert(&quot;这是js执行的&quot;)&apos;) response.end() &#125;else if(path == &apos;/index&apos;)&#123; response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) response.write(&apos;&lt;!DOCTYPE&gt;\\n&lt;html&gt;&apos; + &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&lt;/head&gt;&apos; + &apos;&lt;body&gt;&apos; + &apos;&lt;h1&gt;你好，Node.js&lt;/h1&gt;&apos; + &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;) response.end() &#125;else&#123; response.statusCode = 404 response.end() &#125; /******** 代码结束，下面不要看 ************/&#125;)server.listen(port)console.log(&apos;监听 &apos; + port + &apos; 成功\\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port) 再次强调 再次强调，后缀是废话。文件内容是有 HTTP 头中的 Content-Type 保证的HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件HTTP 路径不是文件路径！！！/xxx.html 不一定对应 xxx.html 文件 你请求的时候，查询的内容是？后面的内容当你在地址栏输入一个网页的时候发生了什么呢？你输入完之后，缺http,浏览器帮你加上，缺路径，帮你加上/，缺端口，帮你加上80。","categories":[{"name":"服务器原理学习","slug":"服务器原理学习","permalink":"https://codevvvv9.github.io/categories/服务器原理学习/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://codevvvv9.github.io/tags/Server/"}]},{"title":"http入门","slug":"http入门","date":"2017-12-12T09:48:48.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/12/http入门/","link":"","permalink":"https://codevvvv9.github.io/2017/12/12/http入门/","excerpt":"李爵士发明了万维网，从此世界上的人便可以一起上网了主要包含三个概念 URI、HTTP(HyperText Transfer Protocol)、HTML(HyperText Markup Language)他还发明了以下技术：1、发明了第一个服务器2、发明了第一个浏览器3、写出了第一个网页 名称 作用 URI 俗称网址，通常用它得孩子URL HTTP 让你能够下载这个网页 HTML 让你能看懂这个网页","text":"李爵士发明了万维网，从此世界上的人便可以一起上网了主要包含三个概念 URI、HTTP(HyperText Transfer Protocol)、HTML(HyperText Markup Language)他还发明了以下技术：1、发明了第一个服务器2、发明了第一个浏览器3、写出了第一个网页 名称 作用 URI 俗称网址，通常用它得孩子URL HTTP 让你能够下载这个网页 HTML 让你能看懂这个网页 URI 分为 URL(Uniform Resource Locator)和URNURI 是统一资源标识符URL 是统一资源定位符，可以访问到某个网页的具体位置，就是我们平常所说的网址https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5 通过这个你就可以访问到一个 “唯一的” 网址 名字 作用 https: 协议 www.baidu.com 域名 /s 路径 wd=hello&amp;rsv_spt=1 查询参数 #5 锚点，就是你搜素的结果的div的id 端口还没有学，但是完整的URL包括这6部分 URN 是统一资源命名，类似于书籍的ISBN,唯一的一个编号 DNS(Domain Name System)你输入一个网址，先向DNS去问一下，这个网址的ip,返会给你，然后就可以访问到了。 输入域名 可以返回对应的IP12nslookup baidu.comping baidu.com 我们可以修改hosts,文件去访问谷歌1234C:\\Windows\\System32\\drivers\\etc\\hosts# Github Start192.30.253.118 gist.github.com151.101.72.249 global-ssl.fastly.net 服务器和浏览器的交互 ——server client HTTP之间的关系1、client发送请求1curl -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; 123456//这是get请求&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.49.1&gt; Accept: */*&gt; frank: xxx 1234567curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot;//这是post请求&gt; POST / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.49.1&gt; Accept: */*&gt; Frank: xxx 12345678910curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot;//提交一些内容到百度&gt; POST / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.49.1&gt; Accept: */*&gt; Frank: xxx&gt; Content-Length: 10&gt; Content-Type: application/x-www-form-urlencoded&gt; 如果是获得数据用get 如果是提交数据用post在https://www.baidu.com 模仿用户登录，你的密码在 Form Data里面，打开network查看，一定记得 view source在浏览器和服务器交互的那块代码里面，没有带查询参数，下面这个是带参数的1curl -s -v -- &quot;https://www.baidu.com/s...后面一堆参数&quot; 总结一下 请求和响应的基本格式 请求的基本格式123456789101、动词 路径 协议/版本号2、key1: value12、key2: value22、key3: value32、key4: value42、Content-Type: application/x-www-form-urlencoded2、Host: www.baidu.com2、User-Agent: curl/7.54.03、 必然是一个换行，用以区分第2部分和第4部分4、 要上传的数据 1.请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）2.第三部分永远都是一个回车（\\n）3.动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等4.这里的路径包括「查询参数」，但不包括「锚点」详见上图的请求路径5.如果你没有写路径，那么路径默认为 /6.第 2 部分中的 Content-Type 标注了第 4 部分的格式 2、服务器开放80端口，接收请求，返回内容(响应)3、浏览器负责下载响应内容 响应的基本格式123456789101112131415HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了…… 1234567891、协议/版本 状态码 解释2、key1: value12、key2: value22、key3: value32、key4: value42、Content-Length: 179312、Content-Type: text/html34 要下载的内容 同样的Content-Type规定了第4部分要下载的内容 12345678常见状态码解释200 ok301 访问的内容永久转移了302 暂时的重定向 要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。403 服务器已经理解请求，但是拒绝执行它404 你访问的文件不存在500 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息502 服务器关闭 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应","categories":[{"name":"HTTP入门","slug":"HTTP入门","permalink":"https://codevvvv9.github.io/categories/HTTP入门/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://codevvvv9.github.io/tags/HTTP/"}]},{"title":"hexo初探","slug":"hexo初探","date":"2017-12-12T07:20:46.000Z","updated":"2018-11-18T09:46:05.000Z","comments":true,"path":"2017/12/12/hexo初探/","link":"","permalink":"https://codevvvv9.github.io/2017/12/12/hexo初探/","excerpt":"","text":"如果第一次就仔细点，何必这么多麻烦呢","categories":[],"tags":[{"name":"hexo环境搭建","slug":"hexo环境搭建","permalink":"https://codevvvv9.github.io/tags/hexo环境搭建/"}]}]}