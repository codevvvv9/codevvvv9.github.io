<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>持久化存储与HTTP缓存 | WuShaoLin&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="HTTP,">
  

  <meta name="description" content="本文主要学习一下一些高级的HTTP知识，例如Session LocalStorage Cache-Control Expires ETag 其实主要就是涉及到了持久化存储与缓存的技术  在此之前已经学习了Cookie的相关知识，其中Cookie有个缺点可以人为修改，有一定的安全隐患。 所以，针对这个缺点，诞生了Session Session一般来说Session是基于Cookie实现的，它利用一">
<meta name="keywords" content="HTTP">
<meta property="og:type" content="article">
<meta property="og:title" content="持久化存储与HTTP缓存">
<meta property="og:url" content="https://codevvvv9.github.io/2018/02/11/持久化存储与HTTP缓存/index.html">
<meta property="og:site_name" content="WuShaoLin&#39;s Blog">
<meta property="og:description" content="本文主要学习一下一些高级的HTTP知识，例如Session LocalStorage Cache-Control Expires ETag 其实主要就是涉及到了持久化存储与缓存的技术  在此之前已经学习了Cookie的相关知识，其中Cookie有个缺点可以人为修改，有一定的安全隐患。 所以，针对这个缺点，诞生了Session Session一般来说Session是基于Cookie实现的，它利用一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-9/12510112.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-9/79629274.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-9/18117336.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-9/60377714.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/81124953.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/20129031.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/59253426.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/1670868.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68564030.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/42636461.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/78046653.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/74542817.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/18997396.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/82913073.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/23771996.jpg">
<meta property="og:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68663233.jpg">
<meta property="og:updated_time" content="2018-11-18T09:46:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="持久化存储与HTTP缓存">
<meta name="twitter:description" content="本文主要学习一下一些高级的HTTP知识，例如Session LocalStorage Cache-Control Expires ETag 其实主要就是涉及到了持久化存储与缓存的技术  在此之前已经学习了Cookie的相关知识，其中Cookie有个缺点可以人为修改，有一定的安全隐患。 所以，针对这个缺点，诞生了Session Session一般来说Session是基于Cookie实现的，它利用一">
<meta name="twitter:image" content="http://p3tha6q4v.bkt.clouddn.com/18-2-9/12510112.jpg">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/categories/" rel="noopener noreferrer" target="_blank">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tags/" rel="noopener noreferrer" target="_blank">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_blank">
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Session"><span class="toc-text">Session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sessionId"><span class="toc-text">sessionId</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化存储"><span class="toc-text">持久化存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalStorage"><span class="toc-text">LocalStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个实际应用"><span class="toc-text">一个实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不基于Cookie的session"><span class="toc-text">不基于Cookie的session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结一下"><span class="toc-text">小结一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionStorage"><span class="toc-text">SessionStorage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP缓存技术三兄弟"><span class="toc-text">HTTP缓存技术三兄弟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control"><span class="toc-text">Cache-Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#首页尽量不用缓存技术"><span class="toc-text">首页尽量不用缓存技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新缓存"><span class="toc-text">更新缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结一下-1"><span class="toc-text">小结一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires"><span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5"><span class="toc-text">MD5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETag"><span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#304状态码的含义"><span class="toc-text">304状态码的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几个常见的考题"><span class="toc-text">几个常见的考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie和Session的区别"><span class="toc-text">Cookie和Session的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-和-LocalStorage-的区别"><span class="toc-text">Cookie 和 LocalStorage 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalStorage-和-SessionStorage-的区别"><span class="toc-text">LocalStorage 和 SessionStorage 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-如何设置过期时间？如何删除-Cookie？"><span class="toc-text">Cookie 如何设置过期时间？如何删除 Cookie？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？"><span class="toc-text">Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-持久化存储与HTTP缓存" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">持久化存储与HTTP缓存</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.02.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>shaolin-wu</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/HTTP高级知识/">HTTP高级知识</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p>本文主要学习一下一些高级的HTTP知识，例如<code>Session</code> <code>LocalStorage Cache-Control Expires ETag</code></p>
<p>其实主要就是涉及到了<strong>持久化存储与缓存的技术</strong></p>
</blockquote>
<p>在此之前已经学习了<code>Cookie</code>的相关知识，其中<code>Cookie</code>有个缺点可以人为修改，有一定的安全隐患。</p>
<p>所以，针对这个缺点，诞生了<code>Session</code></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>一般来说<code>Session</code>是基于Cookie实现的，它利用一个<code>sessionId</code>把用户的敏感数据隐藏起来，除非暴力穷举才有可能获得敏感数据。</p>
<h3 id="sessionId"><a href="#sessionId" class="headerlink" title="sessionId"></a><code>sessionId</code></h3><p>我们使用<code>Cookie</code>的时候，一般是服务器给用户一个响应头，设置<code>Cookie</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">'sign_in_email=...;HTTPOnly'</span>)</span><br></pre></td></tr></table></figure>
<p>既然Session还是基于<code>Cookie</code>实现的，那么还是应该在<code>Set-Cookie</code>上搞事情。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预先在服务器端预留对象准备存储各种session</span></span><br><span class="line"><span class="keyword">let</span> sessions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> sessionId = <span class="built_in">Math</span>.random() * <span class="number">100000</span></span><br><span class="line">sessions[sessionId] = &#123;<span class="attr">sign_in_email</span>: email&#125;</span><br><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`sessionId=<span class="subst">$&#123;sessionId&#125;</span>;HTTPOnly`</span>)</span><br></pre></td></tr></table></figure>
<p>使用随机数来做<code>sessionId</code>,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的<code>sessions</code>对象里面。它就像一个密码簿一样，有效的信息与<code>sessionId</code>一一对应，这是服务器的事，保证了安全性。</p>
<p>当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个<code>sessionId</code>，服务器获得这个<code>sessionId</code>后，然后一转化就知道是正确的用户了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sessions = &#123;</span><br><span class="line">  sessionId: &#123;</span><br><span class="line">    sign_in_email: ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><p>在HTML里面<code>js文件</code>里面的变量或对象，每当网页刷新的时候，就会死掉，又重新生成，虽然还是那个<code>a</code>，但是刷新后已经是另一块内存了。既然它也没变，我们为什么不把它一直保留着呢，即使刷新了<code>a</code>还是那个<code>a</code>，也就是持久化存储的意义。以前使用<code>Cookie</code>做这个功能，不过<code>Cookie</code>每次发请求会把Cookie里面的所有东西都带着去服务器，加重内存的负担，而且请求响应时间长，所以<code>html5</code>给了一个新的API <code>localStorage</code></p>
<p>关于Cookie如何工作的，我发现<a href="https://segmentfault.com/u/ruoyiqing" target="_blank" rel="noopener">这篇文章</a>写得特别好</p>
<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a><code>LocalStorage</code></h3><p>它本质上还是个<code>hash</code>，不过是存在于浏览器端的，不同于<code>session</code>存在与服务器端的<code>hash</code>。一般存储的都是没有用的或者不敏感的信息。</p>
<p><code>localStorage</code>是window的全局属性，常用的有三个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 添加键、值</span></span><br><span class="line">localStorage.setItem(<span class="string">'a'</span>, <span class="string">'...'</span>)</span><br><span class="line"><span class="comment">//2. 获得键、值</span></span><br><span class="line">localStorage。getItem(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">//3.清空localStorage</span></span><br><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure>
<p>注意，它存的值全是字符串，即使你写的像对象也没有卵用。</p>
<p>如果想存储字符串需要用到<code>JSON.stringify( )</code></p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/12510112.jpg" alt="全是字符串"></p>
<h3 id="一个实际应用"><a href="#一个实际应用" class="headerlink" title="一个实际应用"></a>一个实际应用</h3><p>很简单的一个例子：网站进行更新了，用户登录进来了，想提示用户一下—我有新东西啦，这个提示并不应该在每次刷新的时候反复告诉用户，只是在第一次用户进来的时候告诉他即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> already = localStorage.getItem(<span class="string">'已经提示过了'</span>)</span><br><span class="line"> <span class="keyword">if</span> (!already) &#123;</span><br><span class="line">   alert(<span class="string">'我们的网站新进了一些货物，您看一下有没有您需要的啊O(∩_∩)O～'</span>)</span><br><span class="line">   localStorage.setItem(<span class="string">'已经提示过了'</span>, <span class="literal">true</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当第一次访问的时候，<code>already</code>为null，所以进入<code>if</code>代码片段，提示用户一次，接着把<code>already</code>设为<code>true</code>，不会进入<code>if</code>，也就不再提示了。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/79629274.jpg" alt="实际应用"></p>
<h3 id="不基于Cookie的session"><a href="#不基于Cookie的session" class="headerlink" title="不基于Cookie的session"></a>不基于<code>Cookie</code>的<code>session</code></h3><p>学习了<code>localStorage</code>，就可以搞一些黑科技了，前面说了，<code>session</code>一般是基于<code>Cookie</code>的，那么有没有例外呢。</p>
<p>有的。利用查询参数和<code>localStorage</code>可是实现<code>session</code>Id`。</p>
<h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><ol>
<li>Cookie的特点<ul>
<li>服务器通过 Set-Cookie 头给客户端一串字符串</li>
<li>客户端每次访问相同域名的网页时，必须带上这段字符串</li>
<li>客户端要在一段时间内保存这个Cookie</li>
<li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间。比如max-age和后面要讲的<code>Expires</code></li>
<li><a href="https://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key" target="_blank" rel="noopener">大小大概在 4kb 以内</a></li>
</ul>
</li>
<li>Session的特点<ul>
<li>将 SessionID（随机数）通过 Cookie 发给客户端</li>
<li>客户端访问服务器时，服务器读取 SessionID</li>
<li>服务器有一块内存（哈希表）保存了所有 session</li>
<li>通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email</li>
<li>这块内存（哈希表）就是服务器上的所有 session</li>
</ul>
</li>
<li>LocalStorage的特点<ul>
<li>LocalStorage 跟 HTTP 无关</li>
<li>也就是说发送任何请求都不会带上 LocalStorage 的值</li>
<li>只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）</li>
<li>每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）</li>
<li>常用场景：记录有没有提示过用户（没有用的信息，不能记录密码等敏感信息）</li>
<li>LocalStorage 永久有效，除非用户清理缓存</li>
</ul>
</li>
</ol>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/18117336.jpg" alt="清理缓存"></p>
<h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><p>会话存储主要特点与<code>localStorage</code>基本相同，最大的不同是<code>SessionStorage</code>在用户关闭页面（会话结束）后就失效。</p>
<h2 id="HTTP缓存技术三兄弟"><a href="#HTTP缓存技术三兄弟" class="headerlink" title="HTTP缓存技术三兄弟"></a>HTTP缓存技术三兄弟</h2><p>假如说我们要访问的的文件比较大，我们请求完之后，下载需要花很长时间，当我们刷新页面的时候，虽然文件没有任何更新，但是我们又从服务器端下载了一遍大文件，导致每次响应时间依然很长。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-9/60377714.jpg" alt="加载时间很长"></p>
<p>通过上图的实验可以看到<code>localhost</code>的请求响应很快，10ms；而<code>default.css</code>、<code>main.js</code>文件较大，响应时间是<code>localhost</code>的25倍，而<code>jq</code>文件使用了<code>cdn</code>加速，是从内存的缓存中获得的，几乎瞬间。如果每次都这样的话，用户体验肯定很差。</p>
<hr>
<p>那么我们能不能在第一次响应完毕之后，如果资源没有更新，就不去服务器端下载，而是去某个地方获得呢？</p>
<p>答案是肯定的，可以实现，通过缓存，正如上图的<code>jq</code>实现的方法一样。</p>
<p>这部分可以作为web性能优化的一个方法。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a></h3><p>通过<code>max-age</code>设置缓存的有效时间(持续时间)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/css/default.css'</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./css/default.css'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">   response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/css;charset=utf-8'</span>)</span><br><span class="line">   response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">   response.write(string)</span><br><span class="line">   response.end()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在响应头里面加上<code>Cache-Control</code>，表示在100000秒内不要再去向服务器要这个资源了，就从我的内存缓存里面获得。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/81124953.jpg" alt="缓存的技术"></p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/20129031.jpg" alt="多次刷新后"></p>
<p>虽然使用了缓存技术，不过有一点疑惑的就是有时候从硬盘的缓存里面获得，这个速度提升并不大，但是仍然避免了向服务器再次发起请求获得资源的过程；有时候从内存的缓存里面获得，这个就特别快了。大概是因为内存的缓存特别快吧。</p>
<p>通常我们把<code>Cache-Control</code>的有效时间设的很长。</p>
<p>以经常逛得知乎为例。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/59253426.jpg" alt=""></p>
<p>如果一个文件长期不变，把它设为从缓存里面获得，知乎设置了32596169秒的有效时间，超过了1年=31536000秒的时间。</p>
<h3 id="首页尽量不用缓存技术"><a href="#首页尽量不用缓存技术" class="headerlink" title="首页尽量不用缓存技术"></a>首页尽量不用缓存技术</h3><p>我们刷一些论坛性质的或者新闻性质的网站，注重时效性，一般会把爆炸性的、高质量的内容放到首页去，如果我们看了一会，想刷新看看新的更新的内容，而你设了缓存，看到的还是10分钟之前的首页，那就太尴尬了☺……</p>
<p>所以首页尽量不用缓存技术，只对那些长期不变的文件、图片等使用缓存技术。</p>
<p>还是以知乎为例。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/1670868.jpg" alt="以知乎为例"></p>
<p>对于知乎的<code>Cache-Control</code>的写法我是比较懵逼的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">MDN的语法</a>上</p>
<blockquote>
<ol>
<li><code>public</code></li>
</ol>
<p>Indicates that the response may be cached by any cache.</p>
<ol start="2">
<li><code>private</code></li>
</ol>
<p>Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.</p>
<ol start="3">
<li><code>no-cache</code></li>
</ol>
<p>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</p>
<ol start="4">
<li><code>no-store</code></li>
</ol>
<p>The cache should not store anything about the client request or server response.</p>
<ol start="5">
<li><code>must-revalidate</code></li>
</ol>
<p>The cache must verify the status of the stale resources before using it and expired ones should not be used.</p>
</blockquote>
<p>MDN推荐关闭缓存的写法是<code>Cache-Control: no-cache, no-store, must-revalidate</code>。</p>
<p>那么如果有的资源确实被更新了，如何去更新缓存呢。</p>
<h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>通过服务器端代码<code>server.js</code>我们可以发现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/js/main.js'</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (path === <span class="string">'/css/default.css'</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  response.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1000000'</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要当<code>URL</code>符合要求的时候，会使用缓存技术，不去发起请求重新下载资源。</p>
<p>所以当文件确实被更新了之后，我们可以改变<code>URL</code>，那么就会去重新下载新的文件了。</p>
<p>既然我们的网页入口是<code>html</code>，可以在这里面动手脚</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;script src=<span class="string">"./js/main.js?V2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当你更新代码之后，理论上只需要在URL上添加查询参数<code>？V2</code>即可。</p>
<hr>
<p>我们还是去知乎看看他们的例子。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68564030.jpg" alt="更新缓存"></p>
<p>可以看到知乎也是把<code>URL</code>改了，只不过比我那种高级，它在文件名字动了手脚，大概是用了什么框架或者处理工具吧，不过更新缓存的思路上是一样的。文件变了，知乎就把文件缓存的<code>URL</code>填点东西；没变的话，就缓存一年，在你的硬盘某处睡一年^_^。</p>
<h3 id="小结一下-1"><a href="#小结一下-1" class="headerlink" title="小结一下"></a>小结一下</h3><p>使用缓存就用<code>response.setHeader(&#39;Cache-Control&#39;, &#39;max-age=100000&#39;)</code>，当你想更新的时候就改变文件的<code>URL</code>。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/42636461.jpg" alt="缓存技术"></p>
<p>当然，缓存存多了，你的硬盘估计就爆了，浏览器会去权衡这些的，应该优先清楚哪些缓存，是浏览器的事。</p>
<p>俗话说得好啊，吃井不忘挖井人啊，要学会忆苦思甜啊，我们现在用的可爽的<code>Cache-Control</code>也不是凭空冒出来的，是有历史原因的，以前呢，是用<code>Expires</code>实现缓存的技术。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires" target="_blank" rel="noopener">Expires</a></h3><p><code>Expires</code>的英文是到期的意思，很明显是与缓存有关的技术，不过从其英文意思也能看出它是到某个时间点截止的意思，不是<code>Cache-Control</code>的有效时间。</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/78046653.jpg" alt="MDN的语法"></p>
<p>从语法和示例可以看出它是基于格林威治时间的。</p>
<p>我们还要处理一下时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//Sat Feb 10 2018 11:18:54 GMT+0800 (CST)</span></span><br><span class="line">d.toGMTString() <span class="comment">//"Sat, 10 Feb 2018 03:18:54 GMT"</span></span><br></pre></td></tr></table></figure>
<p>能看出来，这个响应头的最大的弊端在于，<strong>时间戳是与你的本地时间关联的</strong></p>
<p>如果本地电脑的时间系统错乱了，而且这种毛病还真的时常发生，那你的缓存就毫无作用了。maybe这就是HTTP要升级这个响应头的原因吧O(∩_∩)O～</p>
<p>当<code>Cache-Control</code>和<code>Expires</code>共同存在的时候</p>
<blockquote>
<p>如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener"><code>Cache-Control</code></a>响应头，那么  <code>Expires</code> 头就会被忽略。</p>
</blockquote>
<p>关于缓存的技术，还有最后一个兄弟<code>ETag</code>，在搞定它之前，先来学习一下它的小跟班<code>MD5</code></p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a><a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5</a></h3><p><code>MD5</code>是一个摘要算法。经常用于比较两个文件是否完全一样，如果有一点不一样，误差会放大。例如我们经常重装系统的话，有良心的系统提供者会给你一个对应的<code>MD5</code>值，当你下载完毕后，查看你下载的系统的MD5值是否与官方提供给你的一样，确保是否会因为网络原因导致你下载的东西不完整。</p>
<p>在<code>Linux</code>系统里面使用<code>md5sum</code>指令进行MD5校验</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/74542817.jpg" alt="MD5校验"></p>
<p>第一个红框里面就是<code>1.txt</code>文件(内容设定为123456)的MD5值，第二个红框里面就是<code>1-copy</code>文件(内容被我改为了123460)的MD5值。</p>
<p>在<code>nodejs</code>里面如何使用呢，Google后发现有<code>npm</code>的<a href="https://www.npmjs.com/package/md5" target="_blank" rel="noopener">MD5</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install md5</span><br><span class="line">...</span><br><span class="line"><span class="comment">//在server.js引入</span></span><br><span class="line"><span class="keyword">var</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>);</span><br></pre></td></tr></table></figure>
<p>准备工作做完，可以搞<code>ETag</code>了。</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">ETag</a></h3><blockquote>
<p>The <strong>ETag</strong> HTTP response header is an identifier for a specific version of a resource.It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (“mid-air collisions”).</p>
<p>If the resource at a given URL changes, a new <code>Etag</code> value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</p>
</blockquote>
<ul>
<li>这个响应头是特定资源版本的标识符。     </li>
<li>如果给定URL中的资源更改，则一定要生成新的Etag值。因此Etags类似于指纹，也可能被某些服务器用于跟踪。 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。</li>
</ul>
<p>可以看出<code>ETag</code>应该是一串值，此时上一节的<code>MD5</code>就派上用场了，我们使用MD5来比较前后两次请求文件的内容。</p>
<p>当某个URL来访问服务器的资源的时候，如果服务器设置了响应头<code>ETag:一串md5值</code>，那么</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/18997396.jpg" alt="设置响应头"></p>
<p>现在没有什么其他变化，如果第二次刷新的话，你会发现</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/82913073.jpg" alt="请求头变了"></p>
<p>请求头多了一个<code>If-None-Match:一串MD5值</code>。</p>
<p>比较上述两图，我的<code>main.js</code>没有改变过，发现<code>ETag:一串md5值</code>和<code>If-None-Match:一串MD5值</code>的一样，稍微一思考的话，就能明白，第二次刷新的时候如果我的<code>main.js</code>变了的话，那么</p>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/23771996.jpg" alt="MD5变了"></p>
<p>第二次向服务器发起请求，下载的<code>main.js</code>的<code>ETag</code>的MD5值必然不同了。</p>
<p>根据这个现象，然后结合MDN文档</p>
<blockquote>
<p>ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None%20-Match" target="_blank" rel="noopener"><code>If-None -Match</code></a> header字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a>未修改状态，告诉客户端缓存版本可用（新鲜）。</p>
</blockquote>
<p>可以推理出如下的代码了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/js/main.js'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string = fs.readFileSync(<span class="string">'./js/main.js'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/javascript;charset=utf-8'</span>)</span><br><span class="line">    <span class="keyword">let</span> fileMd5 = md5(string)</span><br><span class="line">    response.setHeader(<span class="string">'ETag'</span>, fileMd5)</span><br><span class="line">    <span class="keyword">if</span> (request.headers[<span class="string">'if-none-match'</span>] === fileMd5) &#123;</span><br><span class="line">      response.statusCode = <span class="number">304</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.write(string) </span><br><span class="line">    &#125;</span><br><span class="line">    response.end()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="304状态码的含义"><a href="#304状态码的含义" class="headerlink" title="304状态码的含义"></a>304状态码的含义</h3><blockquote>
<p> HTTP <strong>304</strong> 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="noopener">safe</a>），例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> 或在请求中附带了头部信息： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match" target="_blank" rel="noopener"><code>If-None-Match</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" target="_blank" rel="noopener"><code>If-Modified-Since</code></a>。</p>
</blockquote>
<p>304和缓存的区别：</p>
<ol>
<li>缓存不会发起请求了，直接从内存或者硬盘中获得</li>
<li>304依然会发起请求与响应，只不过响应的第四部分不用再次下载了，因为没有更改，所以还是第一次下载的资源。</li>
</ol>
<p><img src="http://p3tha6q4v.bkt.clouddn.com/18-2-10/68663233.jpg" alt="304与缓存的区别"></p>
<h2 id="几个常见的考题"><a href="#几个常见的考题" class="headerlink" title="几个常见的考题"></a>几个常见的考题</h2><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><ol>
<li>Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的<code>cookie</code>。</li>
<li>而Session是存放在服务器端的内存中，其 Session ID 是通过 Cookie 发送给客户端的，这个Session ID每次都随请求发送给 Server。</li>
</ol>
<h3 id="Cookie-和-LocalStorage-的区别"><a href="#Cookie-和-LocalStorage-的区别" class="headerlink" title="Cookie 和 LocalStorage 的区别"></a>Cookie 和 LocalStorage 的区别</h3><ol>
<li><code>Set-Cookie</code>之后，用户的每次访问服务器，请求里面都会带着<code>Cookie</code>到服务器上，与HTTP有关，而<code>LocalStorage</code>不用发到服务器端，它是存储在浏览器里面的，与HTTP无关，是浏览器的属性，<code>window.localStorage</code>。</li>
<li><code>Cookie</code>一般比较小，大约4k左右，而<code>LocalStorage</code>大约能用5M</li>
<li><code>Cookie</code>默认会在用户关闭页面后失效，不过后端可以设置保存时间，而<code>LocalStorage</code>永久有效，除非用户手动清理。</li>
</ol>
<h3 id="LocalStorage-和-SessionStorage-的区别"><a href="#LocalStorage-和-SessionStorage-的区别" class="headerlink" title="LocalStorage 和 SessionStorage 的区别"></a>LocalStorage 和 SessionStorage 的区别</h3><ol>
<li><code>LocalStorage</code>永久有效，除非用户手动清理<code>localStorage.clear()</code>。不会自动过期</li>
<li>但是SessionStorage在会话结束后就会失效，也就是用户关闭了页面，就失效了。会自动过期</li>
</ol>
<h3 id="Cookie-如何设置过期时间？如何删除-Cookie？"><a href="#Cookie-如何设置过期时间？如何删除-Cookie？" class="headerlink" title="Cookie 如何设置过期时间？如何删除 Cookie？"></a>Cookie 如何设置过期时间？如何删除 Cookie？</h3><ol>
<li><p>设置过期时间：<code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</code></p>
<p>data`是格林威治时间，响应头里里面应该这么写代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Expires'</span>, <span class="string">'Fri, 09 Feb 2018 11:29:48 GMT'</span>)</span><br></pre></td></tr></table></figure>
<p>也就是说Cookie在格林威治时间的2018年2月9号的11点29分48秒失效。</p>
</li>
<li><p>设置cookie过期时间小于当前时间，那么就会删除该cookie。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.cookie = name + <span class="string">'=;  expires=Thu, 01 Jan 1970 00:00:01 GMT;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？"><a href="#Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？" class="headerlink" title="Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？"></a>Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？</h3><ol>
<li><code>Cache-Control: max-age=1000</code>的缓存 是直接不发请求的，1000秒内相同URL的用户请求资源的时候，不会再去发请求访问服务器了，直接从本地内存的缓存里面获取</li>
<li><code>ETag</code>的缓存是不管怎么样都要发起请求，第二次访问的是时候会多一个请求头<code>If-None-Match : md5值</code>，如果两次请求之间的MD5值相同就不会去下载新的文件，响应体是第一次下载的；如果MD5值变了，就要去下载新的文件。</li>
</ol>

    
  </div>
  <!-- 使用gitalk作为评论系统 -->
  
</article>



   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/02/09/一块小饼干的故事-Cookie-的故事-下篇/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/02/13/爱搞事情的webpack/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/categories/" rel="noopener noreferrer" target="_blank">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tags/" rel="noopener noreferrer" target="_blank">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_blank">
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'eaa718397d7fb04087e1',
  clientSecret: '4a3ec626703295108b5194694ecbe378502287eb',
  repo: 'blog-comment',
  owner: 'codevvvv9',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  id: location.pathname.split('/').pop().substring(0, 49),
  admin: ['codevvvv9'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
